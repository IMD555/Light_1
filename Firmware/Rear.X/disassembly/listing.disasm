Disassembly Listing for Rear
Generated From:
C:/Users/imada/OneDrive/Documents/EAGLE/projects/Light_1/Mother_R/Rear.X/dist/default/production/Rear.X.production.elf
2021/03/09 1:09:24

---  C:/Users/imada/OneDrive/Documents/EAGLE/projects/Light_1/Mother_R/Rear.X/newmain.c  ----------------
1:             /*
2:              * File:   newmain.c
3:              * Author: imada
4:              *
5:              * Created on 2021/03/02, 0:01
6:              */
7:             
8:             #include <xc.h>
9:             #include "MAX17320.h"
10:            #include "MAX17345.h"
11:            
12:            // PIC18LF67K40 Configuration Bit Settings
13:            
14:            // 'C' source line config statements
15:            
16:            // CONFIG1L
17:            #pragma config FEXTOSC = OFF    // External Oscillator mode Selection bits (Oscillator not enabled)
18:            #pragma config RSTOSC = HFINTOSC_1MHZ// Power-up default value for COSC bits (HFINTOSC with HFFRQ = 4 MHz and CDIV = 4:1)
19:            
20:            // CONFIG1H
21:            #pragma config CLKOUTEN = OFF   // Clock Out Enable bit (CLKOUT function is disabled)
22:            #pragma config CSWEN = ON       // Clock Switch Enable bit (Writing to NOSC and NDIV is allowed)
23:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
24:            
25:            // CONFIG2L
26:            #pragma config MCLRE = EXTMCLR  // Master Clear Enable bit (If LVP = 0, MCLR pin function is port defined function; If LVP =1, RG5 pin fuction is MCLR)
27:            #pragma config PWRTE = OFF      // Power-up Timer Enable bit (Power up timer disabled)
28:            #pragma config LPBOREN = ON     // Low-power BOR enable bit (ULPBOR enabled)
29:            #pragma config BOREN = OFF      // Brown-out Reset Enable bits (Brown-out Reset disabled)
30:            
31:            // CONFIG2H
32:            #pragma config BORV = VBOR_190  // Brown Out Reset Voltage selection bits (Brown-out Reset Voltage (VBOR) set to 1.90V)
33:            #pragma config ZCD = OFF        // ZCD Disable bit (ZCD disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON)
34:            #pragma config PPS1WAY = OFF    // PPSLOCK bit One-Way Set Enable bit (PPSLOCK bit can be set and cleared repeatedly (subject to the unlock sequence))
35:            #pragma config STVREN = ON      // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
36:            #pragma config DEBUG = OFF      // Debugger Enable bit (Background debugger disabled)
37:            #pragma config XINST = OFF      // Extended Instruction Set Enable bit (Extended Instruction Set and Indexed Addressing Mode disabled)
38:            
39:            // CONFIG3L
40:            #pragma config WDTCPS = WDTCPS_31// WDT Period Select bits (Divider ratio 1:65536; software control of WDTPS)
41:            #pragma config WDTE = OFF       // WDT operating mode (WDT Disabled)
42:            
43:            // CONFIG3H
44:            #pragma config WDTCWS = WDTCWS_7// WDT Window Select bits (window always open (100%); software control; keyed access not required)
45:            #pragma config WDTCCS = SC      // WDT input clock selector (Software Control)
46:            
47:            // CONFIG4L
48:            #pragma config WRT0 = OFF       // Write Protection Block 0 (Block 0 (000800-003FFFh) not write-protected)
49:            #pragma config WRT1 = OFF       // Write Protection Block 1 (Block 1 (004000-007FFFh) not write-protected)
50:            #pragma config WRT2 = OFF       // Write Protection Block 2 (Block 2 (008000-00BFFFh) not write-protected)
51:            #pragma config WRT3 = OFF       // Write Protection Block 3 (Block 3 (00C000-00FFFFh) not write-protected)
52:            #pragma config WRT4 = OFF       // Write Protection Block 3 (Block 4 (010000-013FFFh) not write-protected)
53:            #pragma config WRT5 = OFF       // Write Protection Block 3 (Block 5 (014000-017FFFh) not write-protected)
54:            #pragma config WRT6 = OFF       // Write Protection Block 3 (Block 6 (018000-01BFFFh) not write-protected)
55:            #pragma config WRT7 = OFF       // Write Protection Block 3 (Block 7 (01C000-01FFFFh) not write-protected)
56:            
57:            // CONFIG4H
58:            #pragma config WRTC = ON        // Configuration Register Write Protection bit (Configuration registers (300000-30000Bh) write-protected)
59:            #pragma config WRTB = ON        // Boot Block Write Protection bit (Boot Block (000000-0007FFh) write-protected)
60:            #pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not write-protected)
61:            #pragma config SCANE = OFF      // Scanner Enable bit (Scanner module is NOT available for use, SCANMD bit is ignored)
62:            #pragma config LVP = OFF        // Low Voltage Programming Enable bit (HV on MCLR/VPP must be used for programming)
63:            
64:            // CONFIG5L
65:            #pragma config CP = OFF         // UserNVM Program Memory Code Protection bit (UserNVM code protection disabled)
66:            #pragma config CPD = OFF        // DataNVM Memory Code Protection bit (DataNVM code protection disabled)
67:            
68:            // CONFIG5H
69:            
70:            // CONFIG6L
71:            #pragma config EBTR0 = OFF      // Table Read Protection Block 0 (Block 0 (000800-003FFFh) not protected from table reads executed in other blocks)
72:            #pragma config EBTR1 = OFF      // Table Read Protection Block 1 (Block 1 (004000-007FFFh) not protected from table reads executed in other blocks)
73:            #pragma config EBTR2 = OFF      // Table Read Protection Block 2 (Block 2 (008000-00BFFFh) not protected from table reads executed in other blocks)
74:            #pragma config EBTR3 = OFF      // Table Read Protection Block 3 (Block 3 (00C000-00FFFFh) not protected from table reads executed in other blocks)
75:            #pragma config EBTR4 = OFF      // Table Read Protection Block 4 (Block 4 (010000-013FFFh) not protected from table reads executed in other blocks)
76:            #pragma config EBTR5 = OFF      // Table Read Protection Block 5 (Block 5 (014000-017FFFh) not protected from table reads executed in other blocks)
77:            #pragma config EBTR6 = OFF      // Table Read Protection Block 6 (Block 6 (018000-01BFFFh) not protected from table reads executed in other blocks)
78:            #pragma config EBTR7 = OFF      // Table Read Protection Block 7 (Block 7 (01C000-01FFFFh) not protected from table reads executed in other blocks)
79:            
80:            // CONFIG6H
81:            #pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot Block (000000-0007FFh) not protected from table reads executed in other blocks)
82:            
83:            
84:            
85:            #define	USB_CBUS0		RF6
86:            #define	USB_CBUS1		RF7
87:            #define	USB_CBUS3		RF5
88:            #define	USB_PWREN		!USB_CBUS0	//PWREN#
89:            #define	USB_SLEEP		!USB_CBUS1	//SLEEP#
90:            #define	USB_BCD_CHGR	USB_CBUS3	//BCD_Charger
91:            #define USB_Host		(USB_PWREN&&!USB_SLEEP&&!USB_BCD_CHGR)
92:            #define	USB_SetReady(x)	(LATF0=x)
93:            #define	USB_Ready		RF0
94:            
95:            #define LED		LATD7
96:            
97:            char hello[] = "\r\nHello!\r\n";
98:            
99:            void SendCharUSB(unsigned char d);
100:           void showError(unsigned char* t);
101:           void showText(unsigned char* t);
102:           
103:           
104:           void main(void)
105:           {
106:           	//Reset RN42
107:           	TRISAbits.TRISA4 = 0;
126CA  9881     BCF TRISA, 4, ACCESS
108:           	
109:           	//LED ON
110:           	TRISDbits.TRISD7 = 0;
126CC  9E84     BCF TRISD, 7, ACCESS
111:           	LED = 1;
126CE  8E7C     BSF LATD, 7, ACCESS
112:           
113:           	//PAUSE FT230X
114:           	ODCONFbits.ODCF0 = 1;
126D0  010E     MOVLB 0xE
126D2  81B2     BSF 0xB2, 0, BANKED
115:           	TRISFbits.TRISF0 = 0;
126D4  9086     BCF TRISF, 0, ACCESS
116:           	ANSELFbits.ANSELF0 = 0;
126D6  91B4     BCF 0xB4, 0, BANKED
117:           	USB_SetReady(0);
126D8  907E     BCF LATF, 0, ACCESS
118:           
119:           	// Initialize the device to bootloader
120:           	// NOSC HFINTOSC; NDIV 1; 
121:           	OSCCON1 = 0x60;
126DA  0E60     MOVLW 0x60
126DC  6F43     MOVWF c, BANKED
122:           	// HFFRQ 4_MHz; 
123:           	OSCFRQ = 0x02;
126DE  0E02     MOVLW 0x2
126E0  6F49     MOVWF ap, BANKED
124:           
125:           	ANSELF &= 0x1f;
126E2  0E1F     MOVLW 0x1F
126E4  17B4     ANDWF 0xB4, F, BANKED
126:           
127:           	ANSELGbits.ANSELG2 = 0;
126E6  95BC     BCF 0xBC, 2, BANKED
128:           	RX5PPSbits.RX5PPS = 0x32; //RG2->EUSART5:RX5;
126E8  5117     MOVF p, W, BANKED
126EA  0BC0     ANDLW 0xC0
126EC  0932     IORLW 0x32
126EE  6F17     MOVWF p, BANKED
129:           
130:           	// ABDOVF no_overflow; SCKP Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
131:           	BAUD5CON = 0x18;
126F0  0E18     MOVLW 0x18
126F2  6FE2     MOVWF 0xE2, BANKED
132:           	// SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
133:           	RC5STA = 0x90;
126F4  0E90     MOVLW 0x90
126F6  6FE0     MOVWF 0xE0, BANKED
134:           	// TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
135:           	TX5STA = 0x24;
126F8  0E24     MOVLW 0x24
126FA  6FE1     MOVWF 0xE1, BANKED
136:           	// SP5BRGL	9600bps
137:           	SP5BRGL = 103;
126FC  0E67     MOVLW 0x67
126FE  6FDE     MOVWF 0xDE, BANKED
138:           	//	// SP5BRGH
139:           	//	SP5BRGH = 0;
140:           
141:           	RG3PPS = 0x14; //RG3->EUSART5:TX5;
12700  0E14     MOVLW 0x14
12702  6F85     MOVWF 0x85, BANKED
142:           	TRISGbits.TRISG3 = 0;
12704  9687     BCF TRISG, 3, ACCESS
143:           
144:           	//Start receiving
145:           	USB_SetReady(1);
12706  807E     BSF LATF, 0, ACCESS
146:           
147:           	showText(hello);
12708  0EA6     MOVLW 0xA6
1270A  6E02     MOVWF t, ACCESS
1270C  0E00     MOVLW 0x0
1270E  6E03     MOVWF a, ACCESS
12710  EC95     CALL 0x12B2A, 0
12712  F095     NOP
148:           	
149:           //	MAX17345_init();
150:           	MAX17320_init();
12714  EC09     CALL 0x12812, 0
12716  F094     NOP
151:           	
152:           	T2PR = 0x3f;
12718  0E3F     MOVLW 0x3F
1271A  6EBC     MOVWF T2PR, ACCESS
153:           	T2CON = 0x80;
1271C  0E80     MOVLW 0x80
1271E  6EBD     MOVWF T2CON, ACCESS
154:           	T2CLKCON = 0x01;
12720  0E01     MOVLW 0x1
12722  6EBF     MOVWF T2CLKCON, ACCESS
155:           	CCPTMRS1bits.P7TSEL = 0;
12724  0ECF     MOVLW 0xCF
12726  16AE     ANDWF CCPTMRS1, F, ACCESS
156:           	PWM7DC = 0x03c0;
12728  0E03     MOVLW 0x3
1272A  6EA0     MOVWF PWM7DCH, ACCESS
1272C  0EC0     MOVLW 0xC0
1272E  6E9F     MOVWF PWM7DC, ACCESS
157:           	PWM7CON = 0x80;
12730  0E80     MOVLW 0x80
12732  6EA1     MOVWF PWM7CON, ACCESS
158:           	RE0PPS = 0x0b;
12734  0E0B     MOVLW 0xB
12736  010E     MOVLB 0xE
12738  6F72     MOVWF 0x72, BANKED
159:           	RE1PPS = 0x0b;
1273A  0E0B     MOVLW 0xB
1273C  6F73     MOVWF 0x73, BANKED
160:           	TRISEbits.TRISE0 = 0;
1273E  9085     BCF TRISE, 0, ACCESS
161:           	TRISEbits.TRISE1 = 0;
12740  9285     BCF TRISE, 1, ACCESS
162:           			
163:           	while (1) {
164:               MAX17320_dump();
12742  EC00     CALL 0x10000, 0
12744  F080     NOP
12746  EFA1     GOTO 0x12742
12748  F093     NOP
1274A  EF00     GOTO 0x0
1274C  F000     NOP
165:           //	MAX17345_dump();
166:           	}
167:           }
168:           
169:           void SendCharUSB(unsigned char d)
1298E  6E01     MOVWF __pcstackCOMRAM, ACCESS
170:           {
171:           	while (!PIR4bits.TX5IF);
12990  010E     MOVLB 0xE
12992  A937     BTFSS w, 4, BANKED
12994  EFCE     GOTO 0x1299C
12996  F094     NOP
12998  EFD0     GOTO 0x129A0
1299A  F094     NOP
1299C  EFC8     GOTO 0x12990
1299E  F094     NOP
172:           
173:           	if (USB_Host)
129A0  BC8E     BTFSC PORTF, 6, ACCESS
129A2  EFD5     GOTO 0x129AA
129A4  F094     NOP
129A6  EFD7     GOTO 0x129AE
129A8  F094     NOP
129AA  EFE7     GOTO 0x129CE
129AC  F094     NOP
129AE  AE8E     BTFSS PORTF, 7, ACCESS
129B0  EFDC     GOTO 0x129B8
129B2  F094     NOP
129B4  EFDE     GOTO 0x129BC
129B6  F094     NOP
129B8  EFE7     GOTO 0x129CE
129BA  F094     NOP
129BC  BA8E     BTFSC PORTF, 5, ACCESS
129BE  EFE3     GOTO 0x129C6
129C0  F094     NOP
129C2  EFE5     GOTO 0x129CA
129C4  F094     NOP
129C6  EFE7     GOTO 0x129CE
129C8  F094     NOP
174:           	{
175:           		//		if (!USB_Ready)
176:           		//		{
177:           		//			unsigned char cccc = 0;
178:           		//			for (; cccc < 10; cccc++)
179:           		//			{
180:           		//				Nop();
181:           		//			}
182:           		//		}
183:           
184:           		TX5REG = d;
129CA  C001     MOVFF __pcstackCOMRAM, TX5REG
129CC  FEDD     NOP
185:           	}
186:           
187:           	//	while (!TX5STAbits.TRMT);
188:           }
129CE  0012     RETURN 0
189:           
190:           void showText(unsigned char* t)
191:           {
192:           	TBLPTRU = 0;
12B2A  0E00     MOVLW 0x0
12B2C  6EF8     MOVWF TBLPTRU, ACCESS
193:           	while (*t)
12B2E  EFA2     GOTO 0x12B44
12B30  F095     NOP
12B44  C002     MOVFF t, FSR2
12B46  FFD9     NOP
12B48  C003     MOVFF a, FSR2H
12B4A  FFDA     NOP
12B4C  50DF     MOVF INDF2, W, ACCESS
12B4E  A4D8     BTFSS STATUS, 2, ACCESS
12B50  EFAC     GOTO 0x12B58
12B52  F095     NOP
12B54  EFAE     GOTO 0x12B5C
12B56  F095     NOP
12B58  EF99     GOTO 0x12B32
12B5A  F095     NOP
194:           	{
195:           		SendCharUSB(*t++);
12B32  C002     MOVFF t, FSR2
12B34  FFD9     NOP
12B36  C003     MOVFF a, FSR2H
12B38  FFDA     NOP
12B3A  50DF     MOVF INDF2, W, ACCESS
12B3C  ECC7     CALL 0x1298E, 0
12B3E  F094     NOP
12B40  4A02     INFSNZ t, F, ACCESS
12B42  2A03     INCF a, F, ACCESS
196:           	}
197:           }
12B5C  0012     RETURN 0
198:           
199:           //void showHex2(unsigned char n)
200:           //{
201:           //	SendCharUSB('0');
202:           //	SendCharUSB('x');
203:           //	SendCharUSB(hex[n / 0x10]);
204:           //	SendCharUSB(hex[ n % 0x10]);
205:           //	SendCharUSB(',');
206:           //}
207:           //
208:           //void showHex4(unsigned short n)
209:           //{
210:           //	SendCharUSB('0');
211:           //	SendCharUSB('x');
212:           //	SendCharUSB(hex[n / 0x1000]);
213:           //	SendCharUSB(hex[n / 0x100 % 0x10]);
214:           //	SendCharUSB(hex[n / 0x10 % 0x10]);
215:           //	SendCharUSB(hex[n % 0x10]);
216:           //	SendCharUSB(',');
217:           //}
---  C:/Users/imada/OneDrive/Documents/EAGLE/projects/Light_1/Mother_R/Rear.X/MAX17320.c  ---------------
1:             #include <xc.h>
2:             #include <stdio.h>
3:             
4:             #include "MAX17320.h"
5:             
6:             #define _str(x)  #x
7:             #define str(x)  _str(x)
8:             
9:             #define ONEWIRE
10:            #ifdef	ONEWIRE
11:            #define PIN_PORT	C
12:            #define PIN_N		0
13:            #define	P(R,P,r,p)	R##P##bits.r##P##p
14:            
15:            #define	PIN_WRITE	P(LAT,C,LAT,0)
16:            #define	PIN_READ	P(PORT,C,R,0)
17:            #define	PIN_TRIS	P(TRIS,C,TRIS,0)
18:            #define	PIN_OD		P(ODCON,C,ODC,0)
19:            #define	PIN_ANSEL	P(ANSEL,C,ANS,0)
20:            #define	PIN_WPU		P(WPU,C,WPU,0)
21:            #define	PIN_INLVL	P(INLVL,C,INLVL,0)
22:            #define BCF()       asm("BCF LATC,0,0")
23:            #define	BSF()       asm("BSF LATC,0,0")
24:            #define	BTFSC()     asm("BTFSC PORTC,0,0")
25:            #define	BTFSS()     asm("BTFSS PORTC,0,0")
26:            
27:            #define ERROR	1
28:            #define OK		0
29:            
30:            #define	NET_SKIP	0x00CC
31:            #define	F_READ		0x6900
32:            #define	F_WRITE		0x6C00
33:            
34:            #endif
35:            
36:            #define LED		LATD7
37:            
38:            void SendCharUSB(unsigned char d);
39:            
40:            void putch(unsigned char data){
12BEA  6E02     MOVWF t, ACCESS
41:                SendCharUSB(data);
12BEC  5002     MOVF t, W, ACCESS
12BEE  ECC7     CALL 0x1298E, 0
12BF0  F094     NOP
42:            }
12BF2  0012     RETURN 0
43:            
44:            unsigned char ow_reset(void) {
45:                unsigned char r = 0;
46:                PIN_WRITE = 0;
11C6C  907B     BCF LATC, 0, ACCESS
47:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11C6E  F000     NOP
11C70  F000     NOP
11C72  F000     NOP
11C74  F000     NOP
11C76  F000     NOP
11C78  F000     NOP
11C7A  F000     NOP
11C7C  F000     NOP
11C7E  F000     NOP
11C80  F000     NOP
48:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11C82  F000     NOP
11C84  F000     NOP
11C86  F000     NOP
11C88  F000     NOP
11C8A  F000     NOP
11C8C  F000     NOP
11C8E  F000     NOP
11C90  F000     NOP
11C92  F000     NOP
11C94  F000     NOP
49:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11C96  F000     NOP
11C98  F000     NOP
11C9A  F000     NOP
11C9C  F000     NOP
11C9E  F000     NOP
11CA0  F000     NOP
11CA2  F000     NOP
11CA4  F000     NOP
11CA6  F000     NOP
11CA8  F000     NOP
50:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11CAA  F000     NOP
11CAC  F000     NOP
11CAE  F000     NOP
11CB0  F000     NOP
11CB2  F000     NOP
11CB4  F000     NOP
11CB6  F000     NOP
11CB8  F000     NOP
11CBA  F000     NOP
11CBC  F000     NOP
51:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11CBE  F000     NOP
11CC0  F000     NOP
11CC2  F000     NOP
11CC4  F000     NOP
11CC6  F000     NOP
11CC8  F000     NOP
11CCA  F000     NOP
11CCC  F000     NOP
11CCE  F000     NOP
11CD0  F000     NOP
52:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11CD2  F000     NOP
11CD4  F000     NOP
11CD6  F000     NOP
11CD8  F000     NOP
11CDA  F000     NOP
11CDC  F000     NOP
11CDE  F000     NOP
11CE0  F000     NOP
11CE2  F000     NOP
11CE4  F000     NOP
53:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11CE6  F000     NOP
11CE8  F000     NOP
11CEA  F000     NOP
11CEC  F000     NOP
11CEE  F000     NOP
11CF0  F000     NOP
11CF2  F000     NOP
11CF4  F000     NOP
11CF6  F000     NOP
11CF8  F000     NOP
54:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11CFA  F000     NOP
11CFC  F000     NOP
11CFE  F000     NOP
11D00  F000     NOP
11D02  F000     NOP
11D04  F000     NOP
11D06  F000     NOP
11D08  F000     NOP
11D0A  F000     NOP
11D0C  F000     NOP
55:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11D0E  F000     NOP
11D10  F000     NOP
11D12  F000     NOP
11D14  F000     NOP
11D16  F000     NOP
11D18  F000     NOP
11D1A  F000     NOP
11D1C  F000     NOP
11D1E  F000     NOP
11D20  F000     NOP
56:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11D22  F000     NOP
11D24  F000     NOP
11D26  F000     NOP
11D28  F000     NOP
11D2A  F000     NOP
11D2C  F000     NOP
11D2E  F000     NOP
11D30  F000     NOP
11D32  F000     NOP
11D34  F000     NOP
57:                PIN_WRITE = 1;
11D36  807B     BSF LATC, 0, ACCESS
58:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11D38  F000     NOP
11D3A  F000     NOP
11D3C  F000     NOP
11D3E  F000     NOP
11D40  F000     NOP
11D42  F000     NOP
11D44  F000     NOP
11D46  F000     NOP
11D48  F000     NOP
11D4A  F000     NOP
59:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();
11D4C  F000     NOP
11D4E  F000     NOP
11D50  F000     NOP
11D52  F000     NOP
11D54  F000     NOP
11D56  F000     NOP
60:                r = !PIN_READ;
11D58  A08B     BTFSS PORTC, 0, ACCESS
11D5A  EFB1     GOTO 0x11D62
11D5C  F08E     NOP
11D5E  EFB4     GOTO 0x11D68
11D60  F08E     NOP
11D62  0E01     MOVLW 0x1
11D64  EFB5     GOTO 0x11D6A
11D66  F08E     NOP
11D68  0E00     MOVLW 0x0
11D6A  6E01     MOVWF __pcstackCOMRAM, ACCESS
61:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11D6C  F000     NOP
11D6E  F000     NOP
11D70  F000     NOP
11D72  F000     NOP
11D74  F000     NOP
11D76  F000     NOP
11D78  F000     NOP
11D7A  F000     NOP
11D7C  F000     NOP
11D7E  F000     NOP
62:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11D80  F000     NOP
11D82  F000     NOP
11D84  F000     NOP
11D86  F000     NOP
11D88  F000     NOP
11D8A  F000     NOP
11D8C  F000     NOP
11D8E  F000     NOP
11D90  F000     NOP
11D92  F000     NOP
63:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11D94  F000     NOP
11D96  F000     NOP
11D98  F000     NOP
11D9A  F000     NOP
11D9C  F000     NOP
11D9E  F000     NOP
11DA0  F000     NOP
11DA2  F000     NOP
11DA4  F000     NOP
11DA6  F000     NOP
64:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11DA8  F000     NOP
11DAA  F000     NOP
11DAC  F000     NOP
11DAE  F000     NOP
11DB0  F000     NOP
11DB2  F000     NOP
11DB4  F000     NOP
11DB6  F000     NOP
11DB8  F000     NOP
11DBA  F000     NOP
65:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11DBC  F000     NOP
11DBE  F000     NOP
11DC0  F000     NOP
11DC2  F000     NOP
11DC4  F000     NOP
11DC6  F000     NOP
11DC8  F000     NOP
11DCA  F000     NOP
11DCC  F000     NOP
11DCE  F000     NOP
66:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11DD0  F000     NOP
11DD2  F000     NOP
11DD4  F000     NOP
11DD6  F000     NOP
11DD8  F000     NOP
11DDA  F000     NOP
11DDC  F000     NOP
11DDE  F000     NOP
11DE0  F000     NOP
11DE2  F000     NOP
67:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11DE4  F000     NOP
11DE6  F000     NOP
11DE8  F000     NOP
11DEA  F000     NOP
11DEC  F000     NOP
11DEE  F000     NOP
11DF0  F000     NOP
11DF2  F000     NOP
11DF4  F000     NOP
11DF6  F000     NOP
68:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11DF8  F000     NOP
11DFA  F000     NOP
11DFC  F000     NOP
11DFE  F000     NOP
11E00  F000     NOP
11E02  F000     NOP
11E04  F000     NOP
11E06  F000     NOP
11E08  F000     NOP
11E0A  F000     NOP
69:            	NOP();	NOP();	NOP();	NOP();	NOP();NOP();	NOP();	NOP();	NOP();	NOP();
11E0C  F000     NOP
11E0E  F000     NOP
11E10  F000     NOP
11E12  F000     NOP
11E14  F000     NOP
11E16  F000     NOP
11E18  F000     NOP
11E1A  F000     NOP
11E1C  F000     NOP
11E1E  F000     NOP
70:                return r;
11E20  5001     MOVF __pcstackCOMRAM, W, ACCESS
71:            }
11E22  0012     RETURN 0
72:            
73:            #define OW_BIT_OUT(x)   BCF();\
74:            asm("BTFSC WREG,"x",0");BSF();\
75:            asm("NOP");asm("NOP");asm("NOP");asm("NOP");asm("NOP");asm("NOP");asm("NOP");asm("NOP");asm("NOP");\
76:            BSF();asm("NOP");asm("NOP");
77:            void ow_write_word(unsigned short data) {
78:            	WREG = data;
11A86  5001     MOVF __pcstackCOMRAM, W, ACCESS
79:            	OW_BIT_OUT("0");    OW_BIT_OUT("1");    OW_BIT_OUT("2");    OW_BIT_OUT("3");
11A88  907B     BCF LATC, 0, ACCESS
11A8A  B0E8     BTFSC WREG, 0, ACCESS
11A8C  807B     BSF LATC, 0, ACCESS
11A8E  F000     NOP
11A90  F000     NOP
11A92  F000     NOP
11A94  F000     NOP
11A96  F000     NOP
11A98  F000     NOP
11A9A  F000     NOP
11A9C  F000     NOP
11A9E  F000     NOP
11AA0  807B     BSF LATC, 0, ACCESS
11AA2  F000     NOP
11AA4  F000     NOP
11AA6  907B     BCF LATC, 0, ACCESS
11AA8  B2E8     BTFSC WREG, 1, ACCESS
11AAA  807B     BSF LATC, 0, ACCESS
11AAC  F000     NOP
11AAE  F000     NOP
11AB0  F000     NOP
11AB2  F000     NOP
11AB4  F000     NOP
11AB6  F000     NOP
11AB8  F000     NOP
11ABA  F000     NOP
11ABC  F000     NOP
11ABE  807B     BSF LATC, 0, ACCESS
11AC0  F000     NOP
11AC2  F000     NOP
11AC4  907B     BCF LATC, 0, ACCESS
11AC6  B4E8     BTFSC WREG, 2, ACCESS
11AC8  807B     BSF LATC, 0, ACCESS
11ACA  F000     NOP
11ACC  F000     NOP
11ACE  F000     NOP
11AD0  F000     NOP
11AD2  F000     NOP
11AD4  F000     NOP
11AD6  F000     NOP
11AD8  F000     NOP
11ADA  F000     NOP
11ADC  807B     BSF LATC, 0, ACCESS
11ADE  F000     NOP
11AE0  F000     NOP
11AE2  907B     BCF LATC, 0, ACCESS
11AE4  B6E8     BTFSC WREG, 3, ACCESS
11AE6  807B     BSF LATC, 0, ACCESS
11AE8  F000     NOP
11AEA  F000     NOP
11AEC  F000     NOP
11AEE  F000     NOP
11AF0  F000     NOP
11AF2  F000     NOP
11AF4  F000     NOP
11AF6  F000     NOP
11AF8  F000     NOP
11AFA  807B     BSF LATC, 0, ACCESS
11AFC  F000     NOP
11AFE  F000     NOP
80:                OW_BIT_OUT("4");    OW_BIT_OUT("5");    OW_BIT_OUT("6");    OW_BIT_OUT("7");
11B00  907B     BCF LATC, 0, ACCESS
11B02  B8E8     BTFSC WREG, 4, ACCESS
11B04  807B     BSF LATC, 0, ACCESS
11B06  F000     NOP
11B08  F000     NOP
11B0A  F000     NOP
11B0C  F000     NOP
11B0E  F000     NOP
11B10  F000     NOP
11B12  F000     NOP
11B14  F000     NOP
11B16  F000     NOP
11B18  807B     BSF LATC, 0, ACCESS
11B1A  F000     NOP
11B1C  F000     NOP
11B1E  907B     BCF LATC, 0, ACCESS
11B20  BAE8     BTFSC WREG, 5, ACCESS
11B22  807B     BSF LATC, 0, ACCESS
11B24  F000     NOP
11B26  F000     NOP
11B28  F000     NOP
11B2A  F000     NOP
11B2C  F000     NOP
11B2E  F000     NOP
11B30  F000     NOP
11B32  F000     NOP
11B34  F000     NOP
11B36  807B     BSF LATC, 0, ACCESS
11B38  F000     NOP
11B3A  F000     NOP
11B3C  907B     BCF LATC, 0, ACCESS
11B3E  BCE8     BTFSC WREG, 6, ACCESS
11B40  807B     BSF LATC, 0, ACCESS
11B42  F000     NOP
11B44  F000     NOP
11B46  F000     NOP
11B48  F000     NOP
11B4A  F000     NOP
11B4C  F000     NOP
11B4E  F000     NOP
11B50  F000     NOP
11B52  F000     NOP
11B54  807B     BSF LATC, 0, ACCESS
11B56  F000     NOP
11B58  F000     NOP
11B5A  907B     BCF LATC, 0, ACCESS
11B5C  BEE8     BTFSC WREG, 7, ACCESS
11B5E  807B     BSF LATC, 0, ACCESS
11B60  F000     NOP
11B62  F000     NOP
11B64  F000     NOP
11B66  F000     NOP
11B68  F000     NOP
11B6A  F000     NOP
11B6C  F000     NOP
11B6E  F000     NOP
11B70  F000     NOP
11B72  807B     BSF LATC, 0, ACCESS
11B74  F000     NOP
11B76  F000     NOP
81:            
82:            //	WREG = (unsigned char)(data >> 8);
83:            	WREG = *(((unsigned char*)&data)+1);
11B78  5002     MOVF t, W, ACCESS
84:            	OW_BIT_OUT("0");    OW_BIT_OUT("1");    OW_BIT_OUT("2");    OW_BIT_OUT("3");
11B7A  907B     BCF LATC, 0, ACCESS
11B7C  B0E8     BTFSC WREG, 0, ACCESS
11B7E  807B     BSF LATC, 0, ACCESS
11B80  F000     NOP
11B82  F000     NOP
11B84  F000     NOP
11B86  F000     NOP
11B88  F000     NOP
11B8A  F000     NOP
11B8C  F000     NOP
11B8E  F000     NOP
11B90  F000     NOP
11B92  807B     BSF LATC, 0, ACCESS
11B94  F000     NOP
11B96  F000     NOP
11B98  907B     BCF LATC, 0, ACCESS
11B9A  B2E8     BTFSC WREG, 1, ACCESS
11B9C  807B     BSF LATC, 0, ACCESS
11B9E  F000     NOP
11BA0  F000     NOP
11BA2  F000     NOP
11BA4  F000     NOP
11BA6  F000     NOP
11BA8  F000     NOP
11BAA  F000     NOP
11BAC  F000     NOP
11BAE  F000     NOP
11BB0  807B     BSF LATC, 0, ACCESS
11BB2  F000     NOP
11BB4  F000     NOP
11BB6  907B     BCF LATC, 0, ACCESS
11BB8  B4E8     BTFSC WREG, 2, ACCESS
11BBA  807B     BSF LATC, 0, ACCESS
11BBC  F000     NOP
11BBE  F000     NOP
11BC0  F000     NOP
11BC2  F000     NOP
11BC4  F000     NOP
11BC6  F000     NOP
11BC8  F000     NOP
11BCA  F000     NOP
11BCC  F000     NOP
11BCE  807B     BSF LATC, 0, ACCESS
11BD0  F000     NOP
11BD2  F000     NOP
11BD4  907B     BCF LATC, 0, ACCESS
11BD6  B6E8     BTFSC WREG, 3, ACCESS
11BD8  807B     BSF LATC, 0, ACCESS
11BDA  F000     NOP
11BDC  F000     NOP
11BDE  F000     NOP
11BE0  F000     NOP
11BE2  F000     NOP
11BE4  F000     NOP
11BE6  F000     NOP
11BE8  F000     NOP
11BEA  F000     NOP
11BEC  807B     BSF LATC, 0, ACCESS
11BEE  F000     NOP
11BF0  F000     NOP
85:                OW_BIT_OUT("4");    OW_BIT_OUT("5");    OW_BIT_OUT("6");    OW_BIT_OUT("7");
11BF2  907B     BCF LATC, 0, ACCESS
11BF4  B8E8     BTFSC WREG, 4, ACCESS
11BF6  807B     BSF LATC, 0, ACCESS
11BF8  F000     NOP
11BFA  F000     NOP
11BFC  F000     NOP
11BFE  F000     NOP
11C00  F000     NOP
11C02  F000     NOP
11C04  F000     NOP
11C06  F000     NOP
11C08  F000     NOP
11C0A  807B     BSF LATC, 0, ACCESS
11C0C  F000     NOP
11C0E  F000     NOP
11C10  907B     BCF LATC, 0, ACCESS
11C12  BAE8     BTFSC WREG, 5, ACCESS
11C14  807B     BSF LATC, 0, ACCESS
11C16  F000     NOP
11C18  F000     NOP
11C1A  F000     NOP
11C1C  F000     NOP
11C1E  F000     NOP
11C20  F000     NOP
11C22  F000     NOP
11C24  F000     NOP
11C26  F000     NOP
11C28  807B     BSF LATC, 0, ACCESS
11C2A  F000     NOP
11C2C  F000     NOP
11C2E  907B     BCF LATC, 0, ACCESS
11C30  BCE8     BTFSC WREG, 6, ACCESS
11C32  807B     BSF LATC, 0, ACCESS
11C34  F000     NOP
11C36  F000     NOP
11C38  F000     NOP
11C3A  F000     NOP
11C3C  F000     NOP
11C3E  F000     NOP
11C40  F000     NOP
11C42  F000     NOP
11C44  F000     NOP
11C46  807B     BSF LATC, 0, ACCESS
11C48  F000     NOP
11C4A  F000     NOP
11C4C  907B     BCF LATC, 0, ACCESS
11C4E  BEE8     BTFSC WREG, 7, ACCESS
11C50  807B     BSF LATC, 0, ACCESS
11C52  F000     NOP
11C54  F000     NOP
11C56  F000     NOP
11C58  F000     NOP
11C5A  F000     NOP
11C5C  F000     NOP
11C5E  F000     NOP
11C60  F000     NOP
11C62  F000     NOP
11C64  807B     BSF LATC, 0, ACCESS
11C66  F000     NOP
11C68  F000     NOP
86:            }
11C6A  0012     RETURN 0
87:            
88:            #define OW_BIT_IN(x) BCF();NOP();BSF();\
89:            NOP();\
90:            BTFSC();asm("BSF WREG,"x"&7,0");\
91:            NOP();NOP();NOP();NOP();NOP();NOP();NOP();\
92:            asm("Loop"x":");BTFSS();asm("GOTO Loop"x);
93:            
94:            //#define OW_BIT_IN(x) BCF();NOP();BSF();\
95:            //BTFSC();asm("BSF WREG,"x"&7,0");\
96:            //NOP();NOP();NOP();NOP();NOP();\
97:            //asm("Loop"x":");BTFSS();asm("GOTO Loop"x);
98:            
99:            unsigned short ow_read_word(void) {
100:               unsigned char H;
101:               unsigned char L;
102:               
103:           	WREG = 0;
11862  0E00     MOVLW 0x0
11864  6EE8     MOVWF WREG, ACCESS
104:               OW_BIT_IN("0");    OW_BIT_IN("1");    OW_BIT_IN("2");    OW_BIT_IN("3");
11866  907B     BCF LATC, 0, ACCESS
11868  F000     NOP
1186A  807B     BSF LATC, 0, ACCESS
1186C  F000     NOP
1186E  B08B     BTFSC PORTC, 0, ACCESS
11870  80E8     BSF WREG, 0, ACCESS
11872  F000     NOP
11874  F000     NOP
11876  F000     NOP
11878  F000     NOP
1187A  F000     NOP
1187C  F000     NOP
1187E  F000     NOP
11880  A08B     BTFSS PORTC, 0, ACCESS
11882  EF40     GOTO 0x11880
11884  F08C     NOP
11886  907B     BCF LATC, 0, ACCESS
11888  F000     NOP
1188A  807B     BSF LATC, 0, ACCESS
1188C  F000     NOP
1188E  B08B     BTFSC PORTC, 0, ACCESS
11890  82E8     BSF WREG, 1, ACCESS
11892  F000     NOP
11894  F000     NOP
11896  F000     NOP
11898  F000     NOP
1189A  F000     NOP
1189C  F000     NOP
1189E  F000     NOP
118A0  A08B     BTFSS PORTC, 0, ACCESS
118A2  EF50     GOTO 0x118A0
118A4  F08C     NOP
118A6  907B     BCF LATC, 0, ACCESS
118A8  F000     NOP
118AA  807B     BSF LATC, 0, ACCESS
118AC  F000     NOP
118AE  B08B     BTFSC PORTC, 0, ACCESS
118B0  84E8     BSF WREG, 2, ACCESS
118B2  F000     NOP
118B4  F000     NOP
118B6  F000     NOP
118B8  F000     NOP
118BA  F000     NOP
118BC  F000     NOP
118BE  F000     NOP
118C0  A08B     BTFSS PORTC, 0, ACCESS
118C2  EF60     GOTO 0x118C0
118C4  F08C     NOP
118C6  907B     BCF LATC, 0, ACCESS
118C8  F000     NOP
118CA  807B     BSF LATC, 0, ACCESS
118CC  F000     NOP
118CE  B08B     BTFSC PORTC, 0, ACCESS
118D0  86E8     BSF WREG, 3, ACCESS
118D2  F000     NOP
118D4  F000     NOP
118D6  F000     NOP
118D8  F000     NOP
118DA  F000     NOP
118DC  F000     NOP
118DE  F000     NOP
118E0  A08B     BTFSS PORTC, 0, ACCESS
118E2  EF70     GOTO 0x118E0
118E4  F08C     NOP
105:               OW_BIT_IN("4");    OW_BIT_IN("5");    OW_BIT_IN("6");    OW_BIT_IN("7");
118E6  907B     BCF LATC, 0, ACCESS
118E8  F000     NOP
118EA  807B     BSF LATC, 0, ACCESS
118EC  F000     NOP
118EE  B08B     BTFSC PORTC, 0, ACCESS
118F0  88E8     BSF WREG, 4, ACCESS
118F2  F000     NOP
118F4  F000     NOP
118F6  F000     NOP
118F8  F000     NOP
118FA  F000     NOP
118FC  F000     NOP
118FE  F000     NOP
11900  A08B     BTFSS PORTC, 0, ACCESS
11902  EF80     GOTO 0x11900
11904  F08C     NOP
11906  907B     BCF LATC, 0, ACCESS
11908  F000     NOP
1190A  807B     BSF LATC, 0, ACCESS
1190C  F000     NOP
1190E  B08B     BTFSC PORTC, 0, ACCESS
11910  8AE8     BSF WREG, 5, ACCESS
11912  F000     NOP
11914  F000     NOP
11916  F000     NOP
11918  F000     NOP
1191A  F000     NOP
1191C  F000     NOP
1191E  F000     NOP
11920  A08B     BTFSS PORTC, 0, ACCESS
11922  EF90     GOTO 0x11920
11924  F08C     NOP
11926  907B     BCF LATC, 0, ACCESS
11928  F000     NOP
1192A  807B     BSF LATC, 0, ACCESS
1192C  F000     NOP
1192E  B08B     BTFSC PORTC, 0, ACCESS
11930  8CE8     BSF WREG, 6, ACCESS
11932  F000     NOP
11934  F000     NOP
11936  F000     NOP
11938  F000     NOP
1193A  F000     NOP
1193C  F000     NOP
1193E  F000     NOP
11940  A08B     BTFSS PORTC, 0, ACCESS
11942  EFA0     GOTO 0x11940
11944  F08C     NOP
11946  907B     BCF LATC, 0, ACCESS
11948  F000     NOP
1194A  807B     BSF LATC, 0, ACCESS
1194C  F000     NOP
1194E  B08B     BTFSC PORTC, 0, ACCESS
11950  8EE8     BSF WREG, 7, ACCESS
11952  F000     NOP
11954  F000     NOP
11956  F000     NOP
11958  F000     NOP
1195A  F000     NOP
1195C  F000     NOP
1195E  F000     NOP
11960  A08B     BTFSS PORTC, 0, ACCESS
11962  EFB0     GOTO 0x11960
11964  F08C     NOP
106:           	L = WREG;
11966  6E06     MOVWF L, ACCESS
107:           	
108:           	WREG = 0;
11968  0E00     MOVLW 0x0
1196A  6EE8     MOVWF WREG, ACCESS
109:               OW_BIT_IN("8");    OW_BIT_IN("9");    OW_BIT_IN("10");    OW_BIT_IN("11");
1196C  907B     BCF LATC, 0, ACCESS
1196E  F000     NOP
11970  807B     BSF LATC, 0, ACCESS
11972  F000     NOP
11974  B08B     BTFSC PORTC, 0, ACCESS
11976  80E8     BSF WREG, 0, ACCESS
11978  F000     NOP
1197A  F000     NOP
1197C  F000     NOP
1197E  F000     NOP
11980  F000     NOP
11982  F000     NOP
11984  F000     NOP
11986  A08B     BTFSS PORTC, 0, ACCESS
11988  EFC3     GOTO 0x11986
1198A  F08C     NOP
1198C  907B     BCF LATC, 0, ACCESS
1198E  F000     NOP
11990  807B     BSF LATC, 0, ACCESS
11992  F000     NOP
11994  B08B     BTFSC PORTC, 0, ACCESS
11996  82E8     BSF WREG, 1, ACCESS
11998  F000     NOP
1199A  F000     NOP
1199C  F000     NOP
1199E  F000     NOP
119A0  F000     NOP
119A2  F000     NOP
119A4  F000     NOP
119A6  A08B     BTFSS PORTC, 0, ACCESS
119A8  EFD3     GOTO 0x119A6
119AA  F08C     NOP
119AC  907B     BCF LATC, 0, ACCESS
119AE  F000     NOP
119B0  807B     BSF LATC, 0, ACCESS
119B2  F000     NOP
119B4  B08B     BTFSC PORTC, 0, ACCESS
119B6  84E8     BSF WREG, 2, ACCESS
119B8  F000     NOP
119BA  F000     NOP
119BC  F000     NOP
119BE  F000     NOP
119C0  F000     NOP
119C2  F000     NOP
119C4  F000     NOP
119C6  A08B     BTFSS PORTC, 0, ACCESS
119C8  EFE3     GOTO 0x119C6
119CA  F08C     NOP
119CC  907B     BCF LATC, 0, ACCESS
119CE  F000     NOP
119D0  807B     BSF LATC, 0, ACCESS
119D2  F000     NOP
119D4  B08B     BTFSC PORTC, 0, ACCESS
119D6  86E8     BSF WREG, 3, ACCESS
119D8  F000     NOP
119DA  F000     NOP
119DC  F000     NOP
119DE  F000     NOP
119E0  F000     NOP
119E2  F000     NOP
119E4  F000     NOP
119E6  A08B     BTFSS PORTC, 0, ACCESS
119E8  EFF3     GOTO 0x119E6
119EA  F08C     NOP
110:               OW_BIT_IN("12");    OW_BIT_IN("13");    OW_BIT_IN("14");    OW_BIT_IN("15");
119EC  907B     BCF LATC, 0, ACCESS
119EE  F000     NOP
119F0  807B     BSF LATC, 0, ACCESS
119F2  F000     NOP
119F4  B08B     BTFSC PORTC, 0, ACCESS
119F6  88E8     BSF WREG, 4, ACCESS
119F8  F000     NOP
119FA  F000     NOP
119FC  F000     NOP
119FE  F000     NOP
11A00  F000     NOP
11A02  F000     NOP
11A04  F000     NOP
11A06  A08B     BTFSS PORTC, 0, ACCESS
11A08  EF03     GOTO 0x11A06
11A0A  F08D     NOP
11A0C  907B     BCF LATC, 0, ACCESS
11A0E  F000     NOP
11A10  807B     BSF LATC, 0, ACCESS
11A12  F000     NOP
11A14  B08B     BTFSC PORTC, 0, ACCESS
11A16  8AE8     BSF WREG, 5, ACCESS
11A18  F000     NOP
11A1A  F000     NOP
11A1C  F000     NOP
11A1E  F000     NOP
11A20  F000     NOP
11A22  F000     NOP
11A24  F000     NOP
11A26  A08B     BTFSS PORTC, 0, ACCESS
11A28  EF13     GOTO 0x11A26
11A2A  F08D     NOP
11A2C  907B     BCF LATC, 0, ACCESS
11A2E  F000     NOP
11A30  807B     BSF LATC, 0, ACCESS
11A32  F000     NOP
11A34  B08B     BTFSC PORTC, 0, ACCESS
11A36  8CE8     BSF WREG, 6, ACCESS
11A38  F000     NOP
11A3A  F000     NOP
11A3C  F000     NOP
11A3E  F000     NOP
11A40  F000     NOP
11A42  F000     NOP
11A44  F000     NOP
11A46  A08B     BTFSS PORTC, 0, ACCESS
11A48  EF23     GOTO 0x11A46
11A4A  F08D     NOP
11A4C  907B     BCF LATC, 0, ACCESS
11A4E  F000     NOP
11A50  807B     BSF LATC, 0, ACCESS
11A52  F000     NOP
11A54  B08B     BTFSC PORTC, 0, ACCESS
11A56  8EE8     BSF WREG, 7, ACCESS
11A58  F000     NOP
11A5A  F000     NOP
11A5C  F000     NOP
11A5E  F000     NOP
11A60  F000     NOP
11A62  F000     NOP
11A64  F000     NOP
11A66  A08B     BTFSS PORTC, 0, ACCESS
11A68  EF33     GOTO 0x11A66
11A6A  F08D     NOP
111:           	H = WREG;
11A6C  6E05     MOVWF product, ACCESS
112:           	
113:               return ((H<<8) | L);
11A6E  5006     MOVF L, W, ACCESS
11A70  C005     MOVFF product, a
11A72  F003     NOP
11A74  6A04     CLRF 0x4, ACCESS
11A76  C003     MOVFF a, 0x4
11A78  F004     NOP
11A7A  6A03     CLRF a, ACCESS
11A7C  1003     IORWF a, W, ACCESS
11A7E  6E01     MOVWF __pcstackCOMRAM, ACCESS
11A80  5004     MOVF 0x4, W, ACCESS
11A82  6E02     MOVWF t, ACCESS
114:           }
11A84  0012     RETURN 0
115:           
116:           unsigned char MAX17320_read_word(unsigned short address, unsigned short *data) {
117:           #ifdef	ONEWIRE
118:               if (ow_reset()) {
128BE  EC36     CALL 0x11C6C, 0
128C0  F08E     NOP
128C2  0900     IORLW 0x0
128C4  B4D8     BTFSC STATUS, 2, ACCESS
128C6  EF67     GOTO 0x128CE
128C8  F094     NOP
128CA  EF69     GOTO 0x128D2
128CC  F094     NOP
128CE  EF82     GOTO 0x12904
128D0  F094     NOP
119:                   // ack
120:                   ow_write_word(NET_SKIP | F_READ);
128D2  0E69     MOVLW 0x69
128D4  6E02     MOVWF t, ACCESS
128D6  0ECC     MOVLW 0xCC
128D8  6E01     MOVWF __pcstackCOMRAM, ACCESS
128DA  EC43     CALL 0x11A86, 0
128DC  F08D     NOP
121:                   ow_write_word(address);
128DE  C007     MOVFF c, __pcstackCOMRAM
128E0  F001     NOP
128E2  C008     MOVFF s, t
128E4  F002     NOP
128E6  EC43     CALL 0x11A86, 0
128E8  F08D     NOP
122:                   *data = ow_read_word();
128EA  EC31     CALL 0x11862, 0
128EC  F08C     NOP
128EE  C009     MOVFF divisor, FSR2
128F0  FFD9     NOP
128F2  C00A     MOVFF exp, FSR2H
128F4  FFDA     NOP
128F6  C001     MOVFF __pcstackCOMRAM, POSTINC2
128F8  FFDE     NOP
128FA  C002     MOVFF t, POSTDEC2
128FC  FFDD     NOP
123:                   return OK;
128FE  0E00     MOVLW 0x0
12900  EF83     GOTO 0x12906
12902  F094     NOP
124:               } else {
125:                   // nack
126:                   return ERROR;
12904  0E01     MOVLW 0x1
127:               }
128:           #endif
129:               return ERROR;
130:           }
12906  0012     RETURN 0
131:           
132:           unsigned char MAX17320_write_word(unsigned short address, unsigned short data) {
133:           #ifdef	ONEWIRE
134:               if (ow_reset()) {
1294C  EC36     CALL 0x11C6C, 0
1294E  F08E     NOP
12950  0900     IORLW 0x0
12952  B4D8     BTFSC STATUS, 2, ACCESS
12954  EFAE     GOTO 0x1295C
12956  F094     NOP
12958  EFB0     GOTO 0x12960
1295A  F094     NOP
1295C  EFC5     GOTO 0x1298A
1295E  F094     NOP
135:                   // ack
136:                   ow_write_word(NET_SKIP | F_WRITE);
12960  0E6C     MOVLW 0x6C
12962  6E02     MOVWF t, ACCESS
12964  0ECC     MOVLW 0xCC
12966  6E01     MOVWF __pcstackCOMRAM, ACCESS
12968  EC43     CALL 0x11A86, 0
1296A  F08D     NOP
137:                   ow_write_word(address);
1296C  C003     MOVFF a, __pcstackCOMRAM
1296E  F001     NOP
12970  C004     MOVFF 0x4, t
12972  F002     NOP
12974  EC43     CALL 0x11A86, 0
12976  F08D     NOP
138:                   ow_write_word(data);
12978  C005     MOVFF product, __pcstackCOMRAM
1297A  F001     NOP
1297C  C006     MOVFF L, t
1297E  F002     NOP
12980  EC43     CALL 0x11A86, 0
12982  F08D     NOP
139:                   return OK;
12984  0E00     MOVLW 0x0
12986  EFC6     GOTO 0x1298C
12988  F094     NOP
140:               } else {
141:                   // nack
142:                   return ERROR;
1298A  0E01     MOVLW 0x1
143:               }
144:           #endif
145:               return ERROR;
146:           }
1298C  0012     RETURN 0
147:           
148:           unsigned char MAX17320_init(void) {
149:           volatile    unsigned short x = 0x500a;
12812  0E50     MOVLW 0x50
12814  0100     MOVLB 0x0
12816  6FA2     MOVWF 0xA2, BANKED
12818  0E0A     MOVLW 0xA
1281A  6FA1     MOVWF x, BANKED
150:               unsigned char r = 0;
151:               unsigned short data;
152:               PIN_WRITE = 1;
1281C  807B     BSF LATC, 0, ACCESS
153:               PIN_TRIS = 0;
1281E  9083     BCF TRISC, 0, ACCESS
154:               PIN_OD = 1;
12820  010E     MOVLB 0xE
12822  81A0     BSF 0xA0, 0, BANKED
155:           //    PIN_ANSEL = 0;
156:               PIN_WPU = 1;
12824  81A1     BSF x, 0, BANKED
157:               PIN_INLVL = 1;
12826  819E     BSF 0x9E, 0, BANKED
158:           	
159:           	WPUE = 0xff;
12828  69AE     SETF 0xAE, BANKED
160:           //    putchar('c');
161:               printf("boot!");
1282A  0EF8     MOVLW 0xF8
1282C  6E57     MOVWF fmt, ACCESS
1282E  0EFF     MOVLW 0xFF
12830  6E58     MOVWF 0x58, ACCESS
12832  ECC8     CALL 0x12B90, 0
12834  F095     NOP
162:               
163:               MAX17320_dump();
12836  EC00     CALL 0x10000, 0
12838  F080     NOP
164:           
165:           //    while (1) {
166:           //	    if(!MAX17320_read_word(0x1b5,&data)){printf("nPackCfg   =%04x\n",data);}
167:           ////        ow_write_word(0x0aff);
168:           ////        ow_write_word(x);
169:           ////        x = ow_read_word();
170:           ////        NOP();
171:           //    }
172:           
173:               if ((r = MAX17320_read_word(0x01B5, &data)))return r;
1283A  0E01     MOVLW 0x1
1283C  6E08     MOVWF s, ACCESS
1283E  0EB5     MOVLW 0xB5
12840  6E07     MOVWF c, ACCESS
12842  0EA3     MOVLW 0xA3
12844  6E09     MOVWF divisor, ACCESS
12846  0E00     MOVLW 0x0
12848  6E0A     MOVWF exp, ACCESS
1284A  EC5F     CALL 0x128BE, 0
1284C  F094     NOP
1284E  0100     MOVLB 0x0
12850  6FA5     MOVWF r, BANKED
12852  51A5     MOVF r, W, BANKED
12854  B4D8     BTFSC STATUS, 2, ACCESS
12856  EF2F     GOTO 0x1285E
12858  F094     NOP
1285A  EF31     GOTO 0x12862
1285C  F094     NOP
1285E  EF33     GOTO 0x12866
12860  F094     NOP
12862  EF35     GOTO 0x1286A
12864  F094     NOP
174:           //    if (data != 0x4102) {
175:           //    if (1) {
176:               if (0) {
177:                   // if NVM programming is needed
178:           
179:                   // Unlock
180:                   if ((r = MAX17320_write_word(0x061, 0x0000)))return r;
181:                   if ((r = MAX17320_write_word(0x061, 0x0000)))return r;
182:           		
183:           		// nPackCfg 4-Cells No-Thrms AOLDO:3.4V
184:                   if ((r = MAX17320_write_word(0x01B5, 0x4102)))return r;
185:           
186:                   // nUVPrtTh UVP:2.88V UOCVP:3.00V UVShdn:2.80V
187:                   if ((r = MAX17320_write_word(0x01D0, 0x443E)))return r;
188:           
189:                   // nJEITAV 4.1V
190:                   if ((r = MAX17320_write_word(0x01D9, 0xEC59)))return r;
191:           
192:                   // nOVPrtTh Default
193:           
194:                   // nBalTh Zener 10.0mV 11.7mR 30mV
195:                   if ((r = MAX17320_write_word(0x01D4, 0x2C63)))return r;
196:           
197:                   // nODSCTh CHG:5.75A Short:7A DIS:5.5A
198:                   if ((r = MAX17320_write_word(0x01DD, 0x2314)))return r;
199:           
200:                   // nODSCCfg Default
201:           
202:                   // nIPrtTh1 Default(OCP ODP)
203:           
204:           //        // nJEITAC Charge current:5A
205:           //        if ((r = MAX17320_write_word(0x01D8, 0x7DFF)))return r;
206:                   // nJEITAC Charge current:1.5A
207:                   if ((r = MAX17320_write_word(0x01D8, 0x25FF)))return r;
208:           
209:                   // nTPrtTh1 TooHot:45C TooCold:0C
210:                   if ((r = MAX17320_write_word(0x01D1, 0x2D00)))return r;
211:           
212:                   // nTPrtTh2 Hot:35C Cold:5C
213:                   if ((r = MAX17320_write_word(0x01D5, 0x2305)))return r;
214:           
215:                   // nTPrtTh3 PFail:85C Warm:32C
216:                   if ((r = MAX17320_write_word(0x01D2, 0x5520)))return r;
217:           
218:                   // nProtMiscTh Default
219:                   // nDelayCfg Default
220:                   // nProtCfg2 Default
221:                   // nTCurve Default
222:           		
223:                   // nProtCfg Default
224:                   if ((r = MAX17320_write_word(0x1d7, 0x0900)))return r;
225:           		
226:                   // nDesignCap 10000mAh
227:                   if ((r = MAX17320_write_word(0x01B3, 10000)))return r;
228:           		
229:           //        // nNVCfg0 enDC:1
230:           //        if ((r = MAX17320_write_word(0x01B8, 0x0a10)))return r;
231:           		
232:           		// clear NV error
233:                   if ((r = MAX17320_write_word(0x061, 0x0000)))return r;
234:           		
235:           		LED = 0;
236:                   // TODO: writetoNVM
237:               }
238:           	
239:           //    MAX17320_reset();
240:           //	while(1){
241:               MAX17320_dump();
12866  EC00     CALL 0x10000, 0
12868  F080     NOP
242:           //	}
243:               return OK;
244:           }
1286A  0012     RETURN 0
245:           
246:           //unsigned char MAX17320_get_status(unsigned short *status)
247:           //{
248:           //
249:           //}
250:           
251:           unsigned char MAX17320_get_SOC_percentage(unsigned char *SOC) {
252:               unsigned char r = 0;
253:               unsigned short SOC_16 = 0;
254:           
255:               r = MAX17320_read_word(0x0006, &SOC_16);
256:           
257:               *SOC = SOC_16 >> 8;
258:           
259:               return r;
260:           }
261:           
262:           unsigned char MAX17320_get_capacity_remains(unsigned short *cap_rem) {
263:               unsigned char r = 0;
264:           
265:               r = MAX17320_read_word(0x0006, cap_rem);
266:           
267:               return r;
268:           }
269:           
270:           unsigned char MAX17320_get_capacity_full(unsigned short *cap_full) {
271:               unsigned char r = 0;
272:           
273:               r = MAX17320_read_word(0x0010, cap_full);
274:               return r;
275:           }
276:           
277:           void MAX17320_reset(void)
278:           {
279:           	unsigned short data;
280:           	MAX17320_write_word(0x0ab,0x8000);
281:           	while(MAX17320_read_word(0x0ab,&data) != OK || (data&0x8000)!=0);
282:           }
283:           
284:           void MAX17320_dump(void)
285:           {
286:               unsigned short data = 0;
10000  0E00     MOVLW 0x0
10002  6E5E     MOVWF 0x5E, ACCESS
10004  0E00     MOVLW 0x0
10006  6E5D     MOVWF data, ACCESS
287:           
288:               if(!MAX17320_read_word(0x005,&data)){printf("RC %5d[mAh]  ",data);}
10008  0E00     MOVLW 0x0
1000A  6E08     MOVWF s, ACCESS
1000C  0E05     MOVLW 0x5
1000E  6E07     MOVWF c, ACCESS
10010  0E5D     MOVLW 0x5D
10012  6E09     MOVWF divisor, ACCESS
10014  0E00     MOVLW 0x0
10016  6E0A     MOVWF exp, ACCESS
10018  EC5F     CALL 0x128BE, 0
1001A  F094     NOP
1001C  0900     IORLW 0x0
1001E  A4D8     BTFSS STATUS, 2, ACCESS
10020  EF14     GOTO 0x10028
10022  F080     NOP
10024  EF16     GOTO 0x1002C
10026  F080     NOP
10028  EF20     GOTO 0x10040
1002A  F080     NOP
1002C  0ECA     MOVLW 0xCA
1002E  6E57     MOVWF fmt, ACCESS
10030  0EFF     MOVLW 0xFF
10032  6E58     MOVWF 0x58, ACCESS
10034  C05D     MOVFF data, 0x59
10036  F059     NOP
10038  C05E     MOVFF 0x5E, 0x5A
1003A  F05A     NOP
1003C  ECC8     CALL 0x12B90, 0
1003E  F095     NOP
289:               if(!MAX17320_read_word(0x018,&data)){printf("DC %5d[mAh]  ",data);}
10040  0E00     MOVLW 0x0
10042  6E08     MOVWF s, ACCESS
10044  0E18     MOVLW 0x18
10046  6E07     MOVWF c, ACCESS
10048  0E5D     MOVLW 0x5D
1004A  6E09     MOVWF divisor, ACCESS
1004C  0E00     MOVLW 0x0
1004E  6E0A     MOVWF exp, ACCESS
10050  EC5F     CALL 0x128BE, 0
10052  F094     NOP
10054  0900     IORLW 0x0
10056  A4D8     BTFSS STATUS, 2, ACCESS
10058  EF30     GOTO 0x10060
1005A  F080     NOP
1005C  EF32     GOTO 0x10064
1005E  F080     NOP
10060  EF3C     GOTO 0x10078
10062  F080     NOP
10064  0EBC     MOVLW 0xBC
10066  6E57     MOVWF fmt, ACCESS
10068  0EFF     MOVLW 0xFF
1006A  6E58     MOVWF 0x58, ACCESS
1006C  C05D     MOVFF data, 0x59
1006E  F059     NOP
10070  C05E     MOVFF 0x5E, 0x5A
10072  F05A     NOP
10074  ECC8     CALL 0x12B90, 0
10076  F095     NOP
290:               if(!MAX17320_read_word(0x006,&data)){printf("RepSOC %3d[%%]  ",data>>8);}
10078  0E00     MOVLW 0x0
1007A  6E08     MOVWF s, ACCESS
1007C  0E06     MOVLW 0x6
1007E  6E07     MOVWF c, ACCESS
10080  0E5D     MOVLW 0x5D
10082  6E09     MOVWF divisor, ACCESS
10084  0E00     MOVLW 0x0
10086  6E0A     MOVWF exp, ACCESS
10088  EC5F     CALL 0x128BE, 0
1008A  F094     NOP
1008C  0900     IORLW 0x0
1008E  A4D8     BTFSS STATUS, 2, ACCESS
10090  EF4C     GOTO 0x10098
10092  F080     NOP
10094  EF4E     GOTO 0x1009C
10096  F080     NOP
10098  EF57     GOTO 0x100AE
1009A  F080     NOP
1009C  0EAB     MOVLW 0xAB
1009E  6E57     MOVWF fmt, ACCESS
100A0  0EFF     MOVLW 0xFF
100A2  6E58     MOVWF 0x58, ACCESS
100A4  505E     MOVF 0x5E, W, ACCESS
100A6  6E59     MOVWF 0x59, ACCESS
100A8  6A5A     CLRF 0x5A, ACCESS
100AA  ECC8     CALL 0x12B90, 0
100AC  F095     NOP
291:               if(!MAX17320_read_word(0x00e,&data)){printf("AvSOC  %3d[%%]  ",data>>8);}
100AE  0E00     MOVLW 0x0
100B0  6E08     MOVWF s, ACCESS
100B2  0E0E     MOVLW 0xE
100B4  6E07     MOVWF c, ACCESS
100B6  0E5D     MOVLW 0x5D
100B8  6E09     MOVWF divisor, ACCESS
100BA  0E00     MOVLW 0x0
100BC  6E0A     MOVWF exp, ACCESS
100BE  EC5F     CALL 0x128BE, 0
100C0  F094     NOP
100C2  0900     IORLW 0x0
100C4  A4D8     BTFSS STATUS, 2, ACCESS
100C6  EF67     GOTO 0x100CE
100C8  F080     NOP
100CA  EF69     GOTO 0x100D2
100CC  F080     NOP
100CE  EF72     GOTO 0x100E4
100D0  F080     NOP
100D2  0E9A     MOVLW 0x9A
100D4  6E57     MOVWF fmt, ACCESS
100D6  0EFF     MOVLW 0xFF
100D8  6E58     MOVWF 0x58, ACCESS
100DA  505E     MOVF 0x5E, W, ACCESS
100DC  6E59     MOVWF 0x59, ACCESS
100DE  6A5A     CLRF 0x5A, ACCESS
100E0  ECC8     CALL 0x12B90, 0
100E2  F095     NOP
292:               if(!MAX17320_read_word(0x01c,&data)){printf("%5d[mA]  ",(signed int)((signed int)data*0.3125));}
100E4  0E00     MOVLW 0x0
100E6  6E08     MOVWF s, ACCESS
100E8  0E1C     MOVLW 0x1C
100EA  6E07     MOVWF c, ACCESS
100EC  0E5D     MOVLW 0x5D
100EE  6E09     MOVWF divisor, ACCESS
100F0  0E00     MOVLW 0x0
100F2  6E0A     MOVWF exp, ACCESS
100F4  EC5F     CALL 0x128BE, 0
100F6  F094     NOP
100F8  0900     IORLW 0x0
100FA  A4D8     BTFSS STATUS, 2, ACCESS
100FC  EF82     GOTO 0x10104
100FE  F080     NOP
10100  EF84     GOTO 0x10108
10102  F080     NOP
10104  EFB6     GOTO 0x1016C
10106  F080     NOP
10108  0EEE     MOVLW 0xEE
1010A  6E57     MOVWF fmt, ACCESS
1010C  0EFF     MOVLW 0xFF
1010E  6E58     MOVWF 0x58, ACCESS
10110  0E00     MOVLW 0x0
10112  6E13     MOVWF a, ACCESS
10114  0E00     MOVLW 0x0
10116  6E14     MOVWF 0x14, ACCESS
10118  0EA0     MOVLW 0xA0
1011A  6E15     MOVWF n, ACCESS
1011C  0E3E     MOVLW 0x3E
1011E  6E16     MOVWF 0x16, ACCESS
10120  C05D     MOVFF data, __pcstackCOMRAM
10122  F001     NOP
10124  C05E     MOVFF 0x5E, t
10126  F002     NOP
10128  0E00     MOVLW 0x0
1012A  BE02     BTFSC t, 7, ACCESS
1012C  0EFF     MOVLW 0xFF
1012E  6E03     MOVWF a, ACCESS
10130  6E04     MOVWF 0x4, ACCESS
10132  0E01     MOVLW 0x1
10134  EC12     CALL 0x11E24, 0
10136  F08F     NOP
10138  C001     MOVFF __pcstackCOMRAM, b
1013A  F00F     NOP
1013C  C002     MOVFF t, c
1013E  F010     NOP
10140  C003     MOVFF a, i
10142  F011     NOP
10144  C004     MOVFF 0x4, sign
10146  F012     NOP
10148  EC3F     CALL 0x10E7E, 0
1014A  F087     NOP
1014C  C00F     MOVFF b, x
1014E  F028     NOP
10150  C010     MOVFF c, 0x29
10152  F029     NOP
10154  C011     MOVFF i, 0x2A
10156  F02A     NOP
10158  C012     MOVFF sign, 0x2B
1015A  F02B     NOP
1015C  EC34     CALL 0x12468, 0
1015E  F092     NOP
10160  C028     MOVFF x, 0x59
10162  F059     NOP
10164  C029     MOVFF 0x29, 0x5A
10166  F05A     NOP
10168  ECC8     CALL 0x12B90, 0
1016A  F095     NOP
293:               if(!MAX17320_read_word(0x0da,&data)){printf("%5d[mV]  \n",(int)(data*0.3125));}
1016C  0E00     MOVLW 0x0
1016E  6E08     MOVWF s, ACCESS
10170  0EDA     MOVLW 0xDA
10172  6E07     MOVWF c, ACCESS
10174  0E5D     MOVLW 0x5D
10176  6E09     MOVWF divisor, ACCESS
10178  0E00     MOVLW 0x0
1017A  6E0A     MOVWF exp, ACCESS
1017C  EC5F     CALL 0x128BE, 0
1017E  F094     NOP
10180  0900     IORLW 0x0
10182  A4D8     BTFSS STATUS, 2, ACCESS
10184  EFC6     GOTO 0x1018C
10186  F080     NOP
10188  EFC8     GOTO 0x10190
1018A  F080     NOP
1018C  EFF7     GOTO 0x101EE
1018E  F080     NOP
10190  0EE3     MOVLW 0xE3
10192  6E57     MOVWF fmt, ACCESS
10194  0EFF     MOVLW 0xFF
10196  6E58     MOVWF 0x58, ACCESS
10198  0E00     MOVLW 0x0
1019A  6E13     MOVWF a, ACCESS
1019C  0E00     MOVLW 0x0
1019E  6E14     MOVWF 0x14, ACCESS
101A0  0EA0     MOVLW 0xA0
101A2  6E15     MOVWF n, ACCESS
101A4  0E3E     MOVLW 0x3E
101A6  6E16     MOVWF 0x16, ACCESS
101A8  C05D     MOVFF data, __pcstackCOMRAM
101AA  F001     NOP
101AC  C05E     MOVFF 0x5E, t
101AE  F002     NOP
101B0  6A03     CLRF a, ACCESS
101B2  6A04     CLRF 0x4, ACCESS
101B4  0E00     MOVLW 0x0
101B6  EC12     CALL 0x11E24, 0
101B8  F08F     NOP
101BA  C001     MOVFF __pcstackCOMRAM, b
101BC  F00F     NOP
101BE  C002     MOVFF t, c
101C0  F010     NOP
101C2  C003     MOVFF a, i
101C4  F011     NOP
101C6  C004     MOVFF 0x4, sign
101C8  F012     NOP
101CA  EC3F     CALL 0x10E7E, 0
101CC  F087     NOP
101CE  C00F     MOVFF b, x
101D0  F028     NOP
101D2  C010     MOVFF c, 0x29
101D4  F029     NOP
101D6  C011     MOVFF i, 0x2A
101D8  F02A     NOP
101DA  C012     MOVFF sign, 0x2B
101DC  F02B     NOP
101DE  EC34     CALL 0x12468, 0
101E0  F092     NOP
101E2  C028     MOVFF x, 0x59
101E4  F059     NOP
101E6  C029     MOVFF 0x29, 0x5A
101E8  F05A     NOP
101EA  ECC8     CALL 0x12B90, 0
101EC  F095     NOP
294:           
295:           //    printf("\nRAM\n");
296:               if(!MAX17320_read_word(0x000,&data)){printf("Status    =%04x\n",data);}
101EE  0E00     MOVLW 0x0
101F0  6E08     MOVWF s, ACCESS
101F2  0E00     MOVLW 0x0
101F4  6E07     MOVWF c, ACCESS
101F6  0E5D     MOVLW 0x5D
101F8  6E09     MOVWF divisor, ACCESS
101FA  0E00     MOVLW 0x0
101FC  6E0A     MOVWF exp, ACCESS
101FE  EC5F     CALL 0x128BE, 0
10200  F094     NOP
10202  0900     IORLW 0x0
10204  A4D8     BTFSS STATUS, 2, ACCESS
10206  EF07     GOTO 0x1020E
10208  F081     NOP
1020A  EF09     GOTO 0x10212
1020C  F081     NOP
1020E  EF13     GOTO 0x10226
10210  F081     NOP
10212  0E12     MOVLW 0x12
10214  6E57     MOVWF fmt, ACCESS
10216  0EFF     MOVLW 0xFF
10218  6E58     MOVWF 0x58, ACCESS
1021A  C05D     MOVFF data, 0x59
1021C  F059     NOP
1021E  C05E     MOVFF 0x5E, 0x5A
10220  F05A     NOP
10222  ECC8     CALL 0x12B90, 0
10224  F095     NOP
297:               if(!MAX17320_read_word(0x0b0,&data)){printf("Status2   =%04x\n",data);}
10226  0E00     MOVLW 0x0
10228  6E08     MOVWF s, ACCESS
1022A  0EB0     MOVLW 0xB0
1022C  6E07     MOVWF c, ACCESS
1022E  0E5D     MOVLW 0x5D
10230  6E09     MOVWF divisor, ACCESS
10232  0E00     MOVLW 0x0
10234  6E0A     MOVWF exp, ACCESS
10236  EC5F     CALL 0x128BE, 0
10238  F094     NOP
1023A  0900     IORLW 0x0
1023C  A4D8     BTFSS STATUS, 2, ACCESS
1023E  EF23     GOTO 0x10246
10240  F081     NOP
10242  EF25     GOTO 0x1024A
10244  F081     NOP
10246  EF2F     GOTO 0x1025E
10248  F081     NOP
1024A  0E34     MOVLW 0x34
1024C  6E57     MOVWF fmt, ACCESS
1024E  0EFF     MOVLW 0xFF
10250  6E58     MOVWF 0x58, ACCESS
10252  C05D     MOVFF data, 0x59
10254  F059     NOP
10256  C05E     MOVFF 0x5E, 0x5A
10258  F05A     NOP
1025A  ECC8     CALL 0x12B90, 0
1025C  F095     NOP
298:               if(!MAX17320_read_word(0x0af,&data)){printf("ProtAlert =%04x\n",data);}
1025E  0E00     MOVLW 0x0
10260  6E08     MOVWF s, ACCESS
10262  0EAF     MOVLW 0xAF
10264  6E07     MOVWF c, ACCESS
10266  0E5D     MOVLW 0x5D
10268  6E09     MOVWF divisor, ACCESS
1026A  0E00     MOVLW 0x0
1026C  6E0A     MOVWF exp, ACCESS
1026E  EC5F     CALL 0x128BE, 0
10270  F094     NOP
10272  0900     IORLW 0x0
10274  A4D8     BTFSS STATUS, 2, ACCESS
10276  EF3F     GOTO 0x1027E
10278  F081     NOP
1027A  EF41     GOTO 0x10282
1027C  F081     NOP
1027E  EF4B     GOTO 0x10296
10280  F081     NOP
10282  0E78     MOVLW 0x78
10284  6E57     MOVWF fmt, ACCESS
10286  0EFF     MOVLW 0xFF
10288  6E58     MOVWF 0x58, ACCESS
1028A  C05D     MOVFF data, 0x59
1028C  F059     NOP
1028E  C05E     MOVFF 0x5E, 0x5A
10290  F05A     NOP
10292  ECC8     CALL 0x12B90, 0
10294  F095     NOP
299:               if(!MAX17320_read_word(0x0d9,&data)){printf("ProtStatus=%04x\n",data);}
10296  0E00     MOVLW 0x0
10298  6E08     MOVWF s, ACCESS
1029A  0ED9     MOVLW 0xD9
1029C  6E07     MOVWF c, ACCESS
1029E  0E5D     MOVLW 0x5D
102A0  6E09     MOVWF divisor, ACCESS
102A2  0E00     MOVLW 0x0
102A4  6E0A     MOVWF exp, ACCESS
102A6  EC5F     CALL 0x128BE, 0
102A8  F094     NOP
102AA  0900     IORLW 0x0
102AC  A4D8     BTFSS STATUS, 2, ACCESS
102AE  EF5B     GOTO 0x102B6
102B0  F081     NOP
102B2  EF5D     GOTO 0x102BA
102B4  F081     NOP
102B6  EF67     GOTO 0x102CE
102B8  F081     NOP
102BA  0E89     MOVLW 0x89
102BC  6E57     MOVWF fmt, ACCESS
102BE  0EFF     MOVLW 0xFF
102C0  6E58     MOVWF 0x58, ACCESS
102C2  C05D     MOVFF data, 0x59
102C4  F059     NOP
102C6  C05E     MOVFF 0x5E, 0x5A
102C8  F05A     NOP
102CA  ECC8     CALL 0x12B90, 0
102CC  F095     NOP
300:               if(!MAX17320_read_word(0x00b,&data)){printf("Config    =%04x\n",data);}
102CE  0E00     MOVLW 0x0
102D0  6E08     MOVWF s, ACCESS
102D2  0E0B     MOVLW 0xB
102D4  6E07     MOVWF c, ACCESS
102D6  0E5D     MOVLW 0x5D
102D8  6E09     MOVWF divisor, ACCESS
102DA  0E00     MOVLW 0x0
102DC  6E0A     MOVWF exp, ACCESS
102DE  EC5F     CALL 0x128BE, 0
102E0  F094     NOP
102E2  0900     IORLW 0x0
102E4  A4D8     BTFSS STATUS, 2, ACCESS
102E6  EF77     GOTO 0x102EE
102E8  F081     NOP
102EA  EF79     GOTO 0x102F2
102EC  F081     NOP
102EE  EF83     GOTO 0x10306
102F0  F081     NOP
102F2  0E01     MOVLW 0x1
102F4  6E57     MOVWF fmt, ACCESS
102F6  0EFF     MOVLW 0xFF
102F8  6E58     MOVWF 0x58, ACCESS
102FA  C05D     MOVFF data, 0x59
102FC  F059     NOP
102FE  C05E     MOVFF 0x5E, 0x5A
10300  F05A     NOP
10302  ECC8     CALL 0x12B90, 0
10304  F095     NOP
301:               if(!MAX17320_read_word(0x0ab,&data)){printf("Config2   =%04x\n",data);}
10306  0E00     MOVLW 0x0
10308  6E08     MOVWF s, ACCESS
1030A  0EAB     MOVLW 0xAB
1030C  6E07     MOVWF c, ACCESS
1030E  0E5D     MOVLW 0x5D
10310  6E09     MOVWF divisor, ACCESS
10312  0E00     MOVLW 0x0
10314  6E0A     MOVWF exp, ACCESS
10316  EC5F     CALL 0x128BE, 0
10318  F094     NOP
1031A  0900     IORLW 0x0
1031C  A4D8     BTFSS STATUS, 2, ACCESS
1031E  EF93     GOTO 0x10326
10320  F081     NOP
10322  EF95     GOTO 0x1032A
10324  F081     NOP
10326  EF9F     GOTO 0x1033E
10328  F081     NOP
1032A  0E23     MOVLW 0x23
1032C  6E57     MOVWF fmt, ACCESS
1032E  0EFF     MOVLW 0xFF
10330  6E58     MOVWF 0x58, ACCESS
10332  C05D     MOVFF data, 0x59
10334  F059     NOP
10336  C05E     MOVFF 0x5E, 0x5A
10338  F05A     NOP
1033A  ECC8     CALL 0x12B90, 0
1033C  F095     NOP
302:               if(!MAX17320_read_word(0x0a0,&data)){printf("RelaxCfg  =%04x\n",data);}
1033E  0E00     MOVLW 0x0
10340  6E08     MOVWF s, ACCESS
10342  0EA0     MOVLW 0xA0
10344  6E07     MOVWF c, ACCESS
10346  0E5D     MOVLW 0x5D
10348  6E09     MOVWF divisor, ACCESS
1034A  0E00     MOVLW 0x0
1034C  6E0A     MOVWF exp, ACCESS
1034E  EC5F     CALL 0x128BE, 0
10350  F094     NOP
10352  0900     IORLW 0x0
10354  A4D8     BTFSS STATUS, 2, ACCESS
10356  EFAF     GOTO 0x1035E
10358  F081     NOP
1035A  EFB1     GOTO 0x10362
1035C  F081     NOP
1035E  EFBB     GOTO 0x10376
10360  F081     NOP
10362  0E45     MOVLW 0x45
10364  6E57     MOVWF fmt, ACCESS
10366  0EFF     MOVLW 0xFF
10368  6E58     MOVWF 0x58, ACCESS
1036A  C05D     MOVFF data, 0x59
1036C  F059     NOP
1036E  C05E     MOVFF 0x5E, 0x5A
10370  F05A     NOP
10372  ECC8     CALL 0x12B90, 0
10374  F095     NOP
303:               if(!MAX17320_read_word(0x005,&data)){printf("RepCap    =%04x  %5d[mAh]\n",data,data);}
10376  0E00     MOVLW 0x0
10378  6E08     MOVWF s, ACCESS
1037A  0E05     MOVLW 0x5
1037C  6E07     MOVWF c, ACCESS
1037E  0E5D     MOVLW 0x5D
10380  6E09     MOVWF divisor, ACCESS
10382  0E00     MOVLW 0x0
10384  6E0A     MOVWF exp, ACCESS
10386  EC5F     CALL 0x128BE, 0
10388  F094     NOP
1038A  0900     IORLW 0x0
1038C  A4D8     BTFSS STATUS, 2, ACCESS
1038E  EFCB     GOTO 0x10396
10390  F081     NOP
10392  EFCD     GOTO 0x1039A
10394  F081     NOP
10396  EFDB     GOTO 0x103B6
10398  F081     NOP
1039A  0E6B     MOVLW 0x6B
1039C  6E57     MOVWF fmt, ACCESS
1039E  0EFD     MOVLW 0xFD
103A0  6E58     MOVWF 0x58, ACCESS
103A2  C05D     MOVFF data, 0x59
103A4  F059     NOP
103A6  C05E     MOVFF 0x5E, 0x5A
103A8  F05A     NOP
103AA  C05D     MOVFF data, 0x5B
103AC  F05B     NOP
103AE  C05E     MOVFF 0x5E, 0x5C
103B0  F05C     NOP
103B2  ECC8     CALL 0x12B90, 0
103B4  F095     NOP
304:               if(!MAX17320_read_word(0x018,&data)){printf("DesignCap =%04x  %5d[mAh]\n",data,data);}
103B6  0E00     MOVLW 0x0
103B8  6E08     MOVWF s, ACCESS
103BA  0E18     MOVLW 0x18
103BC  6E07     MOVWF c, ACCESS
103BE  0E5D     MOVLW 0x5D
103C0  6E09     MOVWF divisor, ACCESS
103C2  0E00     MOVLW 0x0
103C4  6E0A     MOVWF exp, ACCESS
103C6  EC5F     CALL 0x128BE, 0
103C8  F094     NOP
103CA  0900     IORLW 0x0
103CC  A4D8     BTFSS STATUS, 2, ACCESS
103CE  EFEB     GOTO 0x103D6
103D0  F081     NOP
103D2  EFED     GOTO 0x103DA
103D4  F081     NOP
103D6  EFFB     GOTO 0x103F6
103D8  F081     NOP
103DA  0E86     MOVLW 0x86
103DC  6E57     MOVWF fmt, ACCESS
103DE  0EFD     MOVLW 0xFD
103E0  6E58     MOVWF 0x58, ACCESS
103E2  C05D     MOVFF data, 0x59
103E4  F059     NOP
103E6  C05E     MOVFF 0x5E, 0x5A
103E8  F05A     NOP
103EA  C05D     MOVFF data, 0x5B
103EC  F05B     NOP
103EE  C05E     MOVFF 0x5E, 0x5C
103F0  F05C     NOP
103F2  ECC8     CALL 0x12B90, 0
103F4  F095     NOP
305:               if(!MAX17320_read_word(0x006,&data)){printf("RepSOC    =%04x  %3d[%%]\n",data,data>>8);}
103F6  0E00     MOVLW 0x0
103F8  6E08     MOVWF s, ACCESS
103FA  0E06     MOVLW 0x6
103FC  6E07     MOVWF c, ACCESS
103FE  0E5D     MOVLW 0x5D
10400  6E09     MOVWF divisor, ACCESS
10402  0E00     MOVLW 0x0
10404  6E0A     MOVWF exp, ACCESS
10406  EC5F     CALL 0x128BE, 0
10408  F094     NOP
1040A  0900     IORLW 0x0
1040C  A4D8     BTFSS STATUS, 2, ACCESS
1040E  EF0B     GOTO 0x10416
10410  F082     NOP
10412  EF0D     GOTO 0x1041A
10414  F082     NOP
10416  EF1A     GOTO 0x10434
10418  F082     NOP
1041A  0EBB     MOVLW 0xBB
1041C  6E57     MOVWF fmt, ACCESS
1041E  0EFD     MOVLW 0xFD
10420  6E58     MOVWF 0x58, ACCESS
10422  C05D     MOVFF data, 0x59
10424  F059     NOP
10426  C05E     MOVFF 0x5E, 0x5A
10428  F05A     NOP
1042A  505E     MOVF 0x5E, W, ACCESS
1042C  6E5B     MOVWF 0x5B, ACCESS
1042E  6A5C     CLRF 0x5C, ACCESS
10430  ECC8     CALL 0x12B90, 0
10432  F095     NOP
306:               if(!MAX17320_read_word(0x00e,&data)){printf("AvSOC     =%04x  %3d[%%]\n",data,data>>8);}
10434  0E00     MOVLW 0x0
10436  6E08     MOVWF s, ACCESS
10438  0E0E     MOVLW 0xE
1043A  6E07     MOVWF c, ACCESS
1043C  0E5D     MOVLW 0x5D
1043E  6E09     MOVWF divisor, ACCESS
10440  0E00     MOVLW 0x0
10442  6E0A     MOVWF exp, ACCESS
10444  EC5F     CALL 0x128BE, 0
10446  F094     NOP
10448  0900     IORLW 0x0
1044A  A4D8     BTFSS STATUS, 2, ACCESS
1044C  EF2A     GOTO 0x10454
1044E  F082     NOP
10450  EF2C     GOTO 0x10458
10452  F082     NOP
10454  EF39     GOTO 0x10472
10456  F082     NOP
10458  0EA1     MOVLW 0xA1
1045A  6E57     MOVWF fmt, ACCESS
1045C  0EFD     MOVLW 0xFD
1045E  6E58     MOVWF 0x58, ACCESS
10460  C05D     MOVFF data, 0x59
10462  F059     NOP
10464  C05E     MOVFF 0x5E, 0x5A
10466  F05A     NOP
10468  505E     MOVF 0x5E, W, ACCESS
1046A  6E5B     MOVWF 0x5B, ACCESS
1046C  6A5C     CLRF 0x5C, ACCESS
1046E  ECC8     CALL 0x12B90, 0
10470  F095     NOP
307:               if(!MAX17320_read_word(0x0d8,&data)){printf("CELL1     =%04x  %5d[mV]\n",data,(int)(data*0.078125));}
10472  0E00     MOVLW 0x0
10474  6E08     MOVWF s, ACCESS
10476  0ED8     MOVLW 0xD8
10478  6E07     MOVWF c, ACCESS
1047A  0E5D     MOVLW 0x5D
1047C  6E09     MOVWF divisor, ACCESS
1047E  0E00     MOVLW 0x0
10480  6E0A     MOVWF exp, ACCESS
10482  EC5F     CALL 0x128BE, 0
10484  F094     NOP
10486  0900     IORLW 0x0
10488  A4D8     BTFSS STATUS, 2, ACCESS
1048A  EF49     GOTO 0x10492
1048C  F082     NOP
1048E  EF4B     GOTO 0x10496
10490  F082     NOP
10492  EF7E     GOTO 0x104FC
10494  F082     NOP
10496  0E3D     MOVLW 0x3D
10498  6E57     MOVWF fmt, ACCESS
1049A  0EFE     MOVLW 0xFE
1049C  6E58     MOVWF 0x58, ACCESS
1049E  C05D     MOVFF data, 0x59
104A0  F059     NOP
104A2  C05E     MOVFF 0x5E, 0x5A
104A4  F05A     NOP
104A6  0E00     MOVLW 0x0
104A8  6E13     MOVWF a, ACCESS
104AA  0E00     MOVLW 0x0
104AC  6E14     MOVWF 0x14, ACCESS
104AE  0EA0     MOVLW 0xA0
104B0  6E15     MOVWF n, ACCESS
104B2  0E3D     MOVLW 0x3D
104B4  6E16     MOVWF 0x16, ACCESS
104B6  C05D     MOVFF data, __pcstackCOMRAM
104B8  F001     NOP
104BA  C05E     MOVFF 0x5E, t
104BC  F002     NOP
104BE  6A03     CLRF a, ACCESS
104C0  6A04     CLRF 0x4, ACCESS
104C2  0E00     MOVLW 0x0
104C4  EC12     CALL 0x11E24, 0
104C6  F08F     NOP
104C8  C001     MOVFF __pcstackCOMRAM, b
104CA  F00F     NOP
104CC  C002     MOVFF t, c
104CE  F010     NOP
104D0  C003     MOVFF a, i
104D2  F011     NOP
104D4  C004     MOVFF 0x4, sign
104D6  F012     NOP
104D8  EC3F     CALL 0x10E7E, 0
104DA  F087     NOP
104DC  C00F     MOVFF b, x
104DE  F028     NOP
104E0  C010     MOVFF c, 0x29
104E2  F029     NOP
104E4  C011     MOVFF i, 0x2A
104E6  F02A     NOP
104E8  C012     MOVFF sign, 0x2B
104EA  F02B     NOP
104EC  EC34     CALL 0x12468, 0
104EE  F092     NOP
104F0  C028     MOVFF x, 0x5B
104F2  F05B     NOP
104F4  C029     MOVFF 0x29, 0x5C
104F6  F05C     NOP
104F8  ECC8     CALL 0x12B90, 0
104FA  F095     NOP
308:               if(!MAX17320_read_word(0x0d7,&data)){printf("CELL2     =%04x  %5d[mV]\n",data,(int)(data*0.078125));}
104FC  0E00     MOVLW 0x0
104FE  6E08     MOVWF s, ACCESS
10500  0ED7     MOVLW 0xD7
10502  6E07     MOVWF c, ACCESS
10504  0E5D     MOVLW 0x5D
10506  6E09     MOVWF divisor, ACCESS
10508  0E00     MOVLW 0x0
1050A  6E0A     MOVWF exp, ACCESS
1050C  EC5F     CALL 0x128BE, 0
1050E  F094     NOP
10510  0900     IORLW 0x0
10512  A4D8     BTFSS STATUS, 2, ACCESS
10514  EF8E     GOTO 0x1051C
10516  F082     NOP
10518  EF90     GOTO 0x10520
1051A  F082     NOP
1051C  EFC3     GOTO 0x10586
1051E  F082     NOP
10520  0E57     MOVLW 0x57
10522  6E57     MOVWF fmt, ACCESS
10524  0EFE     MOVLW 0xFE
10526  6E58     MOVWF 0x58, ACCESS
10528  C05D     MOVFF data, 0x59
1052A  F059     NOP
1052C  C05E     MOVFF 0x5E, 0x5A
1052E  F05A     NOP
10530  0E00     MOVLW 0x0
10532  6E13     MOVWF a, ACCESS
10534  0E00     MOVLW 0x0
10536  6E14     MOVWF 0x14, ACCESS
10538  0EA0     MOVLW 0xA0
1053A  6E15     MOVWF n, ACCESS
1053C  0E3D     MOVLW 0x3D
1053E  6E16     MOVWF 0x16, ACCESS
10540  C05D     MOVFF data, __pcstackCOMRAM
10542  F001     NOP
10544  C05E     MOVFF 0x5E, t
10546  F002     NOP
10548  6A03     CLRF a, ACCESS
1054A  6A04     CLRF 0x4, ACCESS
1054C  0E00     MOVLW 0x0
1054E  EC12     CALL 0x11E24, 0
10550  F08F     NOP
10552  C001     MOVFF __pcstackCOMRAM, b
10554  F00F     NOP
10556  C002     MOVFF t, c
10558  F010     NOP
1055A  C003     MOVFF a, i
1055C  F011     NOP
1055E  C004     MOVFF 0x4, sign
10560  F012     NOP
10562  EC3F     CALL 0x10E7E, 0
10564  F087     NOP
10566  C00F     MOVFF b, x
10568  F028     NOP
1056A  C010     MOVFF c, 0x29
1056C  F029     NOP
1056E  C011     MOVFF i, 0x2A
10570  F02A     NOP
10572  C012     MOVFF sign, 0x2B
10574  F02B     NOP
10576  EC34     CALL 0x12468, 0
10578  F092     NOP
1057A  C028     MOVFF x, 0x5B
1057C  F05B     NOP
1057E  C029     MOVFF 0x29, 0x5C
10580  F05C     NOP
10582  ECC8     CALL 0x12B90, 0
10584  F095     NOP
309:               if(!MAX17320_read_word(0x0d6,&data)){printf("CELL3     =%04x  %5d[mV]\n",data,(int)(data*0.078125));}
10586  0E00     MOVLW 0x0
10588  6E08     MOVWF s, ACCESS
1058A  0ED6     MOVLW 0xD6
1058C  6E07     MOVWF c, ACCESS
1058E  0E5D     MOVLW 0x5D
10590  6E09     MOVWF divisor, ACCESS
10592  0E00     MOVLW 0x0
10594  6E0A     MOVWF exp, ACCESS
10596  EC5F     CALL 0x128BE, 0
10598  F094     NOP
1059A  0900     IORLW 0x0
1059C  A4D8     BTFSS STATUS, 2, ACCESS
1059E  EFD3     GOTO 0x105A6
105A0  F082     NOP
105A2  EFD5     GOTO 0x105AA
105A4  F082     NOP
105A6  EF08     GOTO 0x10610
105A8  F083     NOP
105AA  0E71     MOVLW 0x71
105AC  6E57     MOVWF fmt, ACCESS
105AE  0EFE     MOVLW 0xFE
105B0  6E58     MOVWF 0x58, ACCESS
105B2  C05D     MOVFF data, 0x59
105B4  F059     NOP
105B6  C05E     MOVFF 0x5E, 0x5A
105B8  F05A     NOP
105BA  0E00     MOVLW 0x0
105BC  6E13     MOVWF a, ACCESS
105BE  0E00     MOVLW 0x0
105C0  6E14     MOVWF 0x14, ACCESS
105C2  0EA0     MOVLW 0xA0
105C4  6E15     MOVWF n, ACCESS
105C6  0E3D     MOVLW 0x3D
105C8  6E16     MOVWF 0x16, ACCESS
105CA  C05D     MOVFF data, __pcstackCOMRAM
105CC  F001     NOP
105CE  C05E     MOVFF 0x5E, t
105D0  F002     NOP
105D2  6A03     CLRF a, ACCESS
105D4  6A04     CLRF 0x4, ACCESS
105D6  0E00     MOVLW 0x0
105D8  EC12     CALL 0x11E24, 0
105DA  F08F     NOP
105DC  C001     MOVFF __pcstackCOMRAM, b
105DE  F00F     NOP
105E0  C002     MOVFF t, c
105E2  F010     NOP
105E4  C003     MOVFF a, i
105E6  F011     NOP
105E8  C004     MOVFF 0x4, sign
105EA  F012     NOP
105EC  EC3F     CALL 0x10E7E, 0
105EE  F087     NOP
105F0  C00F     MOVFF b, x
105F2  F028     NOP
105F4  C010     MOVFF c, 0x29
105F6  F029     NOP
105F8  C011     MOVFF i, 0x2A
105FA  F02A     NOP
105FC  C012     MOVFF sign, 0x2B
105FE  F02B     NOP
10600  EC34     CALL 0x12468, 0
10602  F092     NOP
10604  C028     MOVFF x, 0x5B
10606  F05B     NOP
10608  C029     MOVFF 0x29, 0x5C
1060A  F05C     NOP
1060C  ECC8     CALL 0x12B90, 0
1060E  F095     NOP
310:               if(!MAX17320_read_word(0x0d5,&data)){printf("CELL4     =%04x  %5d[mV]\n",data,(int)(data*0.078125));}
10610  0E00     MOVLW 0x0
10612  6E08     MOVWF s, ACCESS
10614  0ED5     MOVLW 0xD5
10616  6E07     MOVWF c, ACCESS
10618  0E5D     MOVLW 0x5D
1061A  6E09     MOVWF divisor, ACCESS
1061C  0E00     MOVLW 0x0
1061E  6E0A     MOVWF exp, ACCESS
10620  EC5F     CALL 0x128BE, 0
10622  F094     NOP
10624  0900     IORLW 0x0
10626  A4D8     BTFSS STATUS, 2, ACCESS
10628  EF18     GOTO 0x10630
1062A  F083     NOP
1062C  EF1A     GOTO 0x10634
1062E  F083     NOP
10630  EF4D     GOTO 0x1069A
10632  F083     NOP
10634  0E8B     MOVLW 0x8B
10636  6E57     MOVWF fmt, ACCESS
10638  0EFE     MOVLW 0xFE
1063A  6E58     MOVWF 0x58, ACCESS
1063C  C05D     MOVFF data, 0x59
1063E  F059     NOP
10640  C05E     MOVFF 0x5E, 0x5A
10642  F05A     NOP
10644  0E00     MOVLW 0x0
10646  6E13     MOVWF a, ACCESS
10648  0E00     MOVLW 0x0
1064A  6E14     MOVWF 0x14, ACCESS
1064C  0EA0     MOVLW 0xA0
1064E  6E15     MOVWF n, ACCESS
10650  0E3D     MOVLW 0x3D
10652  6E16     MOVWF 0x16, ACCESS
10654  C05D     MOVFF data, __pcstackCOMRAM
10656  F001     NOP
10658  C05E     MOVFF 0x5E, t
1065A  F002     NOP
1065C  6A03     CLRF a, ACCESS
1065E  6A04     CLRF 0x4, ACCESS
10660  0E00     MOVLW 0x0
10662  EC12     CALL 0x11E24, 0
10664  F08F     NOP
10666  C001     MOVFF __pcstackCOMRAM, b
10668  F00F     NOP
1066A  C002     MOVFF t, c
1066C  F010     NOP
1066E  C003     MOVFF a, i
10670  F011     NOP
10672  C004     MOVFF 0x4, sign
10674  F012     NOP
10676  EC3F     CALL 0x10E7E, 0
10678  F087     NOP
1067A  C00F     MOVFF b, x
1067C  F028     NOP
1067E  C010     MOVFF c, 0x29
10680  F029     NOP
10682  C011     MOVFF i, 0x2A
10684  F02A     NOP
10686  C012     MOVFF sign, 0x2B
10688  F02B     NOP
1068A  EC34     CALL 0x12468, 0
1068C  F092     NOP
1068E  C028     MOVFF x, 0x5B
10690  F05B     NOP
10692  C029     MOVFF 0x29, 0x5C
10694  F05C     NOP
10696  ECC8     CALL 0x12B90, 0
10698  F095     NOP
311:               if(!MAX17320_read_word(0x0da,&data)){printf("Batt      =%04x  %5d[mV]\n",data,(int)(data*0.3125));}
1069A  0E00     MOVLW 0x0
1069C  6E08     MOVWF s, ACCESS
1069E  0EDA     MOVLW 0xDA
106A0  6E07     MOVWF c, ACCESS
106A2  0E5D     MOVLW 0x5D
106A4  6E09     MOVWF divisor, ACCESS
106A6  0E00     MOVLW 0x0
106A8  6E0A     MOVWF exp, ACCESS
106AA  EC5F     CALL 0x128BE, 0
106AC  F094     NOP
106AE  0900     IORLW 0x0
106B0  A4D8     BTFSS STATUS, 2, ACCESS
106B2  EF5D     GOTO 0x106BA
106B4  F083     NOP
106B6  EF5F     GOTO 0x106BE
106B8  F083     NOP
106BA  EF92     GOTO 0x10724
106BC  F083     NOP
106BE  0E23     MOVLW 0x23
106C0  6E57     MOVWF fmt, ACCESS
106C2  0EFE     MOVLW 0xFE
106C4  6E58     MOVWF 0x58, ACCESS
106C6  C05D     MOVFF data, 0x59
106C8  F059     NOP
106CA  C05E     MOVFF 0x5E, 0x5A
106CC  F05A     NOP
106CE  0E00     MOVLW 0x0
106D0  6E13     MOVWF a, ACCESS
106D2  0E00     MOVLW 0x0
106D4  6E14     MOVWF 0x14, ACCESS
106D6  0EA0     MOVLW 0xA0
106D8  6E15     MOVWF n, ACCESS
106DA  0E3E     MOVLW 0x3E
106DC  6E16     MOVWF 0x16, ACCESS
106DE  C05D     MOVFF data, __pcstackCOMRAM
106E0  F001     NOP
106E2  C05E     MOVFF 0x5E, t
106E4  F002     NOP
106E6  6A03     CLRF a, ACCESS
106E8  6A04     CLRF 0x4, ACCESS
106EA  0E00     MOVLW 0x0
106EC  EC12     CALL 0x11E24, 0
106EE  F08F     NOP
106F0  C001     MOVFF __pcstackCOMRAM, b
106F2  F00F     NOP
106F4  C002     MOVFF t, c
106F6  F010     NOP
106F8  C003     MOVFF a, i
106FA  F011     NOP
106FC  C004     MOVFF 0x4, sign
106FE  F012     NOP
10700  EC3F     CALL 0x10E7E, 0
10702  F087     NOP
10704  C00F     MOVFF b, x
10706  F028     NOP
10708  C010     MOVFF c, 0x29
1070A  F029     NOP
1070C  C011     MOVFF i, 0x2A
1070E  F02A     NOP
10710  C012     MOVFF sign, 0x2B
10712  F02B     NOP
10714  EC34     CALL 0x12468, 0
10716  F092     NOP
10718  C028     MOVFF x, 0x5B
1071A  F05B     NOP
1071C  C029     MOVFF 0x29, 0x5C
1071E  F05C     NOP
10720  ECC8     CALL 0x12B90, 0
10722  F095     NOP
312:               if(!MAX17320_read_word(0x0db,&data)){printf("PCKP      =%04x  %5d[mV]\n",data,(int)(data*0.3125));}
10724  0E00     MOVLW 0x0
10726  6E08     MOVWF s, ACCESS
10728  0EDB     MOVLW 0xDB
1072A  6E07     MOVWF c, ACCESS
1072C  0E5D     MOVLW 0x5D
1072E  6E09     MOVWF divisor, ACCESS
10730  0E00     MOVLW 0x0
10732  6E0A     MOVWF exp, ACCESS
10734  EC5F     CALL 0x128BE, 0
10736  F094     NOP
10738  0900     IORLW 0x0
1073A  A4D8     BTFSS STATUS, 2, ACCESS
1073C  EFA2     GOTO 0x10744
1073E  F083     NOP
10740  EFA4     GOTO 0x10748
10742  F083     NOP
10744  EFD7     GOTO 0x107AE
10746  F083     NOP
10748  0E09     MOVLW 0x9
1074A  6E57     MOVWF fmt, ACCESS
1074C  0EFE     MOVLW 0xFE
1074E  6E58     MOVWF 0x58, ACCESS
10750  C05D     MOVFF data, 0x59
10752  F059     NOP
10754  C05E     MOVFF 0x5E, 0x5A
10756  F05A     NOP
10758  0E00     MOVLW 0x0
1075A  6E13     MOVWF a, ACCESS
1075C  0E00     MOVLW 0x0
1075E  6E14     MOVWF 0x14, ACCESS
10760  0EA0     MOVLW 0xA0
10762  6E15     MOVWF n, ACCESS
10764  0E3E     MOVLW 0x3E
10766  6E16     MOVWF 0x16, ACCESS
10768  C05D     MOVFF data, __pcstackCOMRAM
1076A  F001     NOP
1076C  C05E     MOVFF 0x5E, t
1076E  F002     NOP
10770  6A03     CLRF a, ACCESS
10772  6A04     CLRF 0x4, ACCESS
10774  0E00     MOVLW 0x0
10776  EC12     CALL 0x11E24, 0
10778  F08F     NOP
1077A  C001     MOVFF __pcstackCOMRAM, b
1077C  F00F     NOP
1077E  C002     MOVFF t, c
10780  F010     NOP
10782  C003     MOVFF a, i
10784  F011     NOP
10786  C004     MOVFF 0x4, sign
10788  F012     NOP
1078A  EC3F     CALL 0x10E7E, 0
1078C  F087     NOP
1078E  C00F     MOVFF b, x
10790  F028     NOP
10792  C010     MOVFF c, 0x29
10794  F029     NOP
10796  C011     MOVFF i, 0x2A
10798  F02A     NOP
1079A  C012     MOVFF sign, 0x2B
1079C  F02B     NOP
1079E  EC34     CALL 0x12468, 0
107A0  F092     NOP
107A2  C028     MOVFF x, 0x5B
107A4  F05B     NOP
107A6  C029     MOVFF 0x29, 0x5C
107A8  F05C     NOP
107AA  ECC8     CALL 0x12B90, 0
107AC  F095     NOP
313:               if(!MAX17320_read_word(0x01b,&data)){printf("Temp      =%04x  %3d[degC]\n",data,data>>8);}
107AE  0E00     MOVLW 0x0
107B0  6E08     MOVWF s, ACCESS
107B2  0E1B     MOVLW 0x1B
107B4  6E07     MOVWF c, ACCESS
107B6  0E5D     MOVLW 0x5D
107B8  6E09     MOVWF divisor, ACCESS
107BA  0E00     MOVLW 0x0
107BC  6E0A     MOVWF exp, ACCESS
107BE  EC5F     CALL 0x128BE, 0
107C0  F094     NOP
107C2  0900     IORLW 0x0
107C4  A4D8     BTFSS STATUS, 2, ACCESS
107C6  EFE7     GOTO 0x107CE
107C8  F083     NOP
107CA  EFE9     GOTO 0x107D2
107CC  F083     NOP
107CE  EFF6     GOTO 0x107EC
107D0  F083     NOP
107D2  0E4F     MOVLW 0x4F
107D4  6E57     MOVWF fmt, ACCESS
107D6  0EFD     MOVLW 0xFD
107D8  6E58     MOVWF 0x58, ACCESS
107DA  C05D     MOVFF data, 0x59
107DC  F059     NOP
107DE  C05E     MOVFF 0x5E, 0x5A
107E0  F05A     NOP
107E2  505E     MOVF 0x5E, W, ACCESS
107E4  6E5B     MOVWF 0x5B, ACCESS
107E6  6A5C     CLRF 0x5C, ACCESS
107E8  ECC8     CALL 0x12B90, 0
107EA  F095     NOP
314:               if(!MAX17320_read_word(0x01c,&data)){printf("Current   =%04x  %5d[mA]\n",data,(signed int)((signed int)data*0.3125));}
107EC  0E00     MOVLW 0x0
107EE  6E08     MOVWF s, ACCESS
107F0  0E1C     MOVLW 0x1C
107F2  6E07     MOVWF c, ACCESS
107F4  0E5D     MOVLW 0x5D
107F6  6E09     MOVWF divisor, ACCESS
107F8  0E00     MOVLW 0x0
107FA  6E0A     MOVWF exp, ACCESS
107FC  EC5F     CALL 0x128BE, 0
107FE  F094     NOP
10800  0900     IORLW 0x0
10802  A4D8     BTFSS STATUS, 2, ACCESS
10804  EF06     GOTO 0x1080C
10806  F084     NOP
10808  EF08     GOTO 0x10810
1080A  F084     NOP
1080C  EF3E     GOTO 0x1087C
1080E  F084     NOP
10810  0ED5     MOVLW 0xD5
10812  6E57     MOVWF fmt, ACCESS
10814  0EFD     MOVLW 0xFD
10816  6E58     MOVWF 0x58, ACCESS
10818  C05D     MOVFF data, 0x59
1081A  F059     NOP
1081C  C05E     MOVFF 0x5E, 0x5A
1081E  F05A     NOP
10820  0E00     MOVLW 0x0
10822  6E13     MOVWF a, ACCESS
10824  0E00     MOVLW 0x0
10826  6E14     MOVWF 0x14, ACCESS
10828  0EA0     MOVLW 0xA0
1082A  6E15     MOVWF n, ACCESS
1082C  0E3E     MOVLW 0x3E
1082E  6E16     MOVWF 0x16, ACCESS
10830  C05D     MOVFF data, __pcstackCOMRAM
10832  F001     NOP
10834  C05E     MOVFF 0x5E, t
10836  F002     NOP
10838  0E00     MOVLW 0x0
1083A  BE02     BTFSC t, 7, ACCESS
1083C  0EFF     MOVLW 0xFF
1083E  6E03     MOVWF a, ACCESS
10840  6E04     MOVWF 0x4, ACCESS
10842  0E01     MOVLW 0x1
10844  EC12     CALL 0x11E24, 0
10846  F08F     NOP
10848  C001     MOVFF __pcstackCOMRAM, b
1084A  F00F     NOP
1084C  C002     MOVFF t, c
1084E  F010     NOP
10850  C003     MOVFF a, i
10852  F011     NOP
10854  C004     MOVFF 0x4, sign
10856  F012     NOP
10858  EC3F     CALL 0x10E7E, 0
1085A  F087     NOP
1085C  C00F     MOVFF b, x
1085E  F028     NOP
10860  C010     MOVFF c, 0x29
10862  F029     NOP
10864  C011     MOVFF i, 0x2A
10866  F02A     NOP
10868  C012     MOVFF sign, 0x2B
1086A  F02B     NOP
1086C  EC34     CALL 0x12468, 0
1086E  F092     NOP
10870  C028     MOVFF x, 0x5B
10872  F05B     NOP
10874  C029     MOVFF 0x29, 0x5C
10876  F05C     NOP
10878  ECC8     CALL 0x12B90, 0
1087A  F095     NOP
315:               if(!MAX17320_read_word(0x028,&data)){printf("ChgingCurr=%04x  %5d[mA]\n",data,(int)(data*0.3125));}
1087C  0E00     MOVLW 0x0
1087E  6E08     MOVWF s, ACCESS
10880  0E28     MOVLW 0x28
10882  6E07     MOVWF c, ACCESS
10884  0E5D     MOVLW 0x5D
10886  6E09     MOVWF divisor, ACCESS
10888  0E00     MOVLW 0x0
1088A  6E0A     MOVWF exp, ACCESS
1088C  EC5F     CALL 0x128BE, 0
1088E  F094     NOP
10890  0900     IORLW 0x0
10892  A4D8     BTFSS STATUS, 2, ACCESS
10894  EF4E     GOTO 0x1089C
10896  F084     NOP
10898  EF50     GOTO 0x108A0
1089A  F084     NOP
1089C  EF83     GOTO 0x10906
1089E  F084     NOP
108A0  0EEF     MOVLW 0xEF
108A2  6E57     MOVWF fmt, ACCESS
108A4  0EFD     MOVLW 0xFD
108A6  6E58     MOVWF 0x58, ACCESS
108A8  C05D     MOVFF data, 0x59
108AA  F059     NOP
108AC  C05E     MOVFF 0x5E, 0x5A
108AE  F05A     NOP
108B0  0E00     MOVLW 0x0
108B2  6E13     MOVWF a, ACCESS
108B4  0E00     MOVLW 0x0
108B6  6E14     MOVWF 0x14, ACCESS
108B8  0EA0     MOVLW 0xA0
108BA  6E15     MOVWF n, ACCESS
108BC  0E3E     MOVLW 0x3E
108BE  6E16     MOVWF 0x16, ACCESS
108C0  C05D     MOVFF data, __pcstackCOMRAM
108C2  F001     NOP
108C4  C05E     MOVFF 0x5E, t
108C6  F002     NOP
108C8  6A03     CLRF a, ACCESS
108CA  6A04     CLRF 0x4, ACCESS
108CC  0E00     MOVLW 0x0
108CE  EC12     CALL 0x11E24, 0
108D0  F08F     NOP
108D2  C001     MOVFF __pcstackCOMRAM, b
108D4  F00F     NOP
108D6  C002     MOVFF t, c
108D8  F010     NOP
108DA  C003     MOVFF a, i
108DC  F011     NOP
108DE  C004     MOVFF 0x4, sign
108E0  F012     NOP
108E2  EC3F     CALL 0x10E7E, 0
108E4  F087     NOP
108E6  C00F     MOVFF b, x
108E8  F028     NOP
108EA  C010     MOVFF c, 0x29
108EC  F029     NOP
108EE  C011     MOVFF i, 0x2A
108F0  F02A     NOP
108F2  C012     MOVFF sign, 0x2B
108F4  F02B     NOP
108F6  EC34     CALL 0x12468, 0
108F8  F092     NOP
108FA  C028     MOVFF x, 0x5B
108FC  F05B     NOP
108FE  C029     MOVFF 0x29, 0x5C
10900  F05C     NOP
10902  ECC8     CALL 0x12B90, 0
10904  F095     NOP
316:               if(!MAX17320_read_word(0x02a,&data)){printf("ChgingVolt=%04x  %5d[mV]\n",data,(int)(data*0.078125));}
10906  0E00     MOVLW 0x0
10908  6E08     MOVWF s, ACCESS
1090A  0E2A     MOVLW 0x2A
1090C  6E07     MOVWF c, ACCESS
1090E  0E5D     MOVLW 0x5D
10910  6E09     MOVWF divisor, ACCESS
10912  0E00     MOVLW 0x0
10914  6E0A     MOVWF exp, ACCESS
10916  EC5F     CALL 0x128BE, 0
10918  F094     NOP
1091A  0900     IORLW 0x0
1091C  A4D8     BTFSS STATUS, 2, ACCESS
1091E  EF93     GOTO 0x10926
10920  F084     NOP
10922  EF95     GOTO 0x1092A
10924  F084     NOP
10926  EFC8     GOTO 0x10990
10928  F084     NOP
1092A  0EA5     MOVLW 0xA5
1092C  6E57     MOVWF fmt, ACCESS
1092E  0EFE     MOVLW 0xFE
10930  6E58     MOVWF 0x58, ACCESS
10932  C05D     MOVFF data, 0x59
10934  F059     NOP
10936  C05E     MOVFF 0x5E, 0x5A
10938  F05A     NOP
1093A  0E00     MOVLW 0x0
1093C  6E13     MOVWF a, ACCESS
1093E  0E00     MOVLW 0x0
10940  6E14     MOVWF 0x14, ACCESS
10942  0EA0     MOVLW 0xA0
10944  6E15     MOVWF n, ACCESS
10946  0E3D     MOVLW 0x3D
10948  6E16     MOVWF 0x16, ACCESS
1094A  C05D     MOVFF data, __pcstackCOMRAM
1094C  F001     NOP
1094E  C05E     MOVFF 0x5E, t
10950  F002     NOP
10952  6A03     CLRF a, ACCESS
10954  6A04     CLRF 0x4, ACCESS
10956  0E00     MOVLW 0x0
10958  EC12     CALL 0x11E24, 0
1095A  F08F     NOP
1095C  C001     MOVFF __pcstackCOMRAM, b
1095E  F00F     NOP
10960  C002     MOVFF t, c
10962  F010     NOP
10964  C003     MOVFF a, i
10966  F011     NOP
10968  C004     MOVFF 0x4, sign
1096A  F012     NOP
1096C  EC3F     CALL 0x10E7E, 0
1096E  F087     NOP
10970  C00F     MOVFF b, x
10972  F028     NOP
10974  C010     MOVFF c, 0x29
10976  F029     NOP
10978  C011     MOVFF i, 0x2A
1097A  F02A     NOP
1097C  C012     MOVFF sign, 0x2B
1097E  F02B     NOP
10980  EC34     CALL 0x12468, 0
10982  F092     NOP
10984  C028     MOVFF x, 0x5B
10986  F05B     NOP
10988  C029     MOVFF 0x29, 0x5C
1098A  F05C     NOP
1098C  ECC8     CALL 0x12B90, 0
1098E  F095     NOP
317:               if(!MAX17320_read_word(0x1f1,&data)){printf("HProtCfg2 =%04x\n",data);}
10990  0E01     MOVLW 0x1
10992  6E08     MOVWF s, ACCESS
10994  0EF1     MOVLW 0xF1
10996  6E07     MOVWF c, ACCESS
10998  0E5D     MOVLW 0x5D
1099A  6E09     MOVWF divisor, ACCESS
1099C  0E00     MOVLW 0x0
1099E  6E0A     MOVWF exp, ACCESS
109A0  EC5F     CALL 0x128BE, 0
109A2  F094     NOP
109A4  0900     IORLW 0x0
109A6  A4D8     BTFSS STATUS, 2, ACCESS
109A8  EFD8     GOTO 0x109B0
109AA  F084     NOP
109AC  EFDA     GOTO 0x109B4
109AE  F084     NOP
109B0  EFE4     GOTO 0x109C8
109B2  F084     NOP
109B4  0E67     MOVLW 0x67
109B6  6E57     MOVWF fmt, ACCESS
109B8  0EFF     MOVLW 0xFF
109BA  6E58     MOVWF 0x58, ACCESS
109BC  C05D     MOVFF data, 0x59
109BE  F059     NOP
109C0  C05E     MOVFF 0x5E, 0x5A
109C2  F05A     NOP
109C4  ECC8     CALL 0x12B90, 0
109C6  F095     NOP
318:               if(!MAX17320_read_word(0x061,&data)){printf("CommStat  =%04x\n",data);}
109C8  0E00     MOVLW 0x0
109CA  6E08     MOVWF s, ACCESS
109CC  0E61     MOVLW 0x61
109CE  6E07     MOVWF c, ACCESS
109D0  0E5D     MOVLW 0x5D
109D2  6E09     MOVWF divisor, ACCESS
109D4  0E00     MOVLW 0x0
109D6  6E0A     MOVWF exp, ACCESS
109D8  EC5F     CALL 0x128BE, 0
109DA  F094     NOP
109DC  0900     IORLW 0x0
109DE  A4D8     BTFSS STATUS, 2, ACCESS
109E0  EFF4     GOTO 0x109E8
109E2  F084     NOP
109E4  EFF6     GOTO 0x109EC
109E6  F084     NOP
109E8  EF00     GOTO 0x10A00
109EA  F085     NOP
109EC  0E56     MOVLW 0x56
109EE  6E57     MOVWF fmt, ACCESS
109F0  0EFF     MOVLW 0xFF
109F2  6E58     MOVWF 0x58, ACCESS
109F4  C05D     MOVFF data, 0x59
109F6  F059     NOP
109F8  C05E     MOVFF 0x5E, 0x5A
109FA  F05A     NOP
109FC  ECC8     CALL 0x12B90, 0
109FE  F095     NOP
319:           //
320:           //    printf("\nNVM\n");
321:           //    if(!MAX17320_read_word(0x19f,&data)){printf("nLearnCfg  =%04x\n",data);}
322:           //    if(!MAX17320_read_word(0x1a9,&data)){printf("nFullCapRep=%04x  %5d[mAh]\n",data,data);}
323:           //    if(!MAX17320_read_word(0x1a5,&data)){printf("nFullCapNom=%04x  %5d[mAh]\n",data,data);}
324:           //    if(!MAX17320_read_word(0x1b3,&data)){printf("nDesignCap =%04x  %5d[mAh]\n",data,data);}
325:           //    if(!MAX17320_read_word(0x1a8,&data)){printf("nBattStatus=%04x\n",data);}
326:           //    if(!MAX17320_read_word(0x1b0,&data)){printf("nConfig    =%04x\n",data);}
327:           //    if(!MAX17320_read_word(0x1b6,&data)){printf("nRelaxCfg  =%04x\n",data);}
328:           //    if(!MAX17320_read_word(0x1b5,&data)){printf("nPackCfg   =%04x\n",data);}
329:           //    if(!MAX17320_read_word(0x1c2,&data)){printf("nChgCfg    =%04x\n",data);}
330:           //    if(!MAX17320_read_word(0x1c3,&data)){printf("nChgCtrl   =%04x\n",data);}
331:           //    if(!MAX17320_read_word(0x1b7,&data)){printf("nConvgCfg  =%04x\n",data);}
332:           //    if(!MAX17320_read_word(0x1bb,&data)){printf("nHibCfg    =%04x\n",data);}
333:           //    if(!MAX17320_read_word(0x1ca,&data)){printf("nThermCfg  =%04x\n",data);}
334:           //    if(!MAX17320_read_word(0x1d7,&data)){printf("nProtCfg   =%04x\n",data);}
335:           //    if(!MAX17320_read_word(0x1df,&data)){printf("nProtCfg2  =%04x\n",data);}
336:           //    if(!MAX17320_read_word(0x1d8,&data)){printf("nJEITAC    =%04x\n",data);}
337:           //    if(!MAX17320_read_word(0x1d9,&data)){printf("nJEITAV    =%04x\n",data);}
338:           //    if(!MAX17320_read_word(0x1b8,&data)){printf("nNVCfg0    =%04x\n",data);}
339:           //    if(!MAX17320_read_word(0x1fd,&data)){printf("NVM_USED   =%04x\n",data);}
340:           }
10A00  0012     RETURN 0
---  C:/Users/imada/AppData/Local/Temp/sc0o.s  ----------------------------------------------------------
12B5E  0EDE     MOVLW 0xDE
12B60  6EF6     MOVWF TBLPTR, ACCESS
12B62  0E2B     MOVLW 0x2B
12B64  6EF7     MOVWF TBLPTRH, ACCESS
12B66  0E01     MOVLW 0x1
12B68  6EF8     MOVWF TBLPTRU, ACCESS
12B6A  EE00     LFSR 0, 0xA6
12B6E  EE10     LFSR 1, 0xB
12B72  0009     TBLRD*+
12B74  CFF5     MOVFF TABLAT, POSTINC0
12B78  50E5     MOVF POSTDEC1, W, ACCESS
12B7A  50E1     MOVF FSR1, W, ACCESS
12B7C  E1FA     BNZ 0x2B72
12B7E  EE00     LFSR 0, 0x60
12B82  0E28     MOVLW 0x28
12B84  6AEE     CLRF POSTINC0, ACCESS
12B86  06E8     DECF WREG, F, ACCESS
12B88  E1FD     BNZ 0x2B84
12B8A  0100     MOVLB 0x0
12B8C  EF65     GOTO 0x126CA
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/xxtofl.c  ------------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
11E24  6E09     MOVWF divisor, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
11E26  5009     MOVF divisor, W, ACCESS
11E28  B4D8     BTFSC STATUS, 2, ACCESS
11E2A  EF19     GOTO 0x11E32
11E2C  F08F     NOP
11E2E  EF1B     GOTO 0x11E36
11E30  F08F     NOP
11E32  EF3D     GOTO 0x11E7A
11E34  F08F     NOP
11E36  BE04     BTFSC 0x4, 7, ACCESS
11E38  EF22     GOTO 0x11E44
11E3A  F08F     NOP
11E3C  EF20     GOTO 0x11E40
11E3E  F08F     NOP
11E40  EF3D     GOTO 0x11E7A
11E42  F08F     NOP
16:            		arg = (unsigned long) -val;
11E44  C001     MOVFF __pcstackCOMRAM, product
11E46  F005     NOP
11E48  C002     MOVFF t, L
11E4A  F006     NOP
11E4C  C003     MOVFF a, c
11E4E  F007     NOP
11E50  C004     MOVFF 0x4, s
11E52  F008     NOP
11E54  1E05     COMF product, F, ACCESS
11E56  1E06     COMF L, F, ACCESS
11E58  1E07     COMF c, F, ACCESS
11E5A  1E08     COMF s, F, ACCESS
11E5C  2A05     INCF product, F, ACCESS
11E5E  0E00     MOVLW 0x0
11E60  2206     ADDWFC L, F, ACCESS
11E62  2207     ADDWFC c, F, ACCESS
11E64  2208     ADDWFC s, F, ACCESS
11E66  C005     MOVFF product, arg
11E68  F00B     NOP
11E6A  C006     MOVFF L, s
11E6C  F00C     NOP
11E6E  C007     MOVFF c, 0xD
11E70  F00D     NOP
11E72  C008     MOVFF s, neg
11E74  F00E     NOP
17:            	}
11E76  EF45     GOTO 0x11E8A
11E78  F08F     NOP
18:            	else {
19:            		arg = (unsigned long) val;
11E7A  C001     MOVFF __pcstackCOMRAM, arg
11E7C  F00B     NOP
11E7E  C002     MOVFF t, s
11E80  F00C     NOP
11E82  C003     MOVFF a, 0xD
11E84  F00D     NOP
11E86  C004     MOVFF 0x4, neg
11E88  F00E     NOP
20:            	}
21:            	if(val == 0)
11E8A  5001     MOVF __pcstackCOMRAM, W, ACCESS
11E8C  1002     IORWF t, W, ACCESS
11E8E  1003     IORWF a, W, ACCESS
11E90  1004     IORWF 0x4, W, ACCESS
11E92  A4D8     BTFSS STATUS, 2, ACCESS
11E94  EF4E     GOTO 0x11E9C
11E96  F08F     NOP
11E98  EF50     GOTO 0x11EA0
11E9A  F08F     NOP
11E9C  EF5A     GOTO 0x11EB4
11E9E  F08F     NOP
22:            		return 0.0;
11EA0  0E00     MOVLW 0x0
11EA2  6E01     MOVWF __pcstackCOMRAM, ACCESS
11EA4  0E00     MOVLW 0x0
11EA6  6E02     MOVWF t, ACCESS
11EA8  0E00     MOVLW 0x0
11EAA  6E03     MOVWF a, ACCESS
11EAC  0E00     MOVLW 0x0
11EAE  6E04     MOVWF 0x4, ACCESS
11EB0  EFEB     GOTO 0x11FD6
11EB2  F08F     NOP
23:            	exp = (127 + 23);
11EB4  0E96     MOVLW 0x96
11EB6  6E0A     MOVWF exp, ACCESS
24:            	while(arg & ~0x1FFFFFFUL) {
11EB8  EF64     GOTO 0x11EC8
11EBA  F08F     NOP
11EC8  0E00     MOVLW 0x0
11ECA  140B     ANDWF arg, W, ACCESS
11ECC  6E05     MOVWF product, ACCESS
11ECE  0E00     MOVLW 0x0
11ED0  140C     ANDWF s, W, ACCESS
11ED2  6E06     MOVWF L, ACCESS
11ED4  0E00     MOVLW 0x0
11ED6  140D     ANDWF 0xD, W, ACCESS
11ED8  6E07     MOVWF c, ACCESS
11EDA  0EFE     MOVLW 0xFE
11EDC  140E     ANDWF neg, W, ACCESS
11EDE  6E08     MOVWF s, ACCESS
11EE0  5005     MOVF product, W, ACCESS
11EE2  1006     IORWF L, W, ACCESS
11EE4  1007     IORWF c, W, ACCESS
11EE6  1008     IORWF s, W, ACCESS
11EE8  A4D8     BTFSS STATUS, 2, ACCESS
11EEA  EF79     GOTO 0x11EF2
11EEC  F08F     NOP
11EEE  EF7B     GOTO 0x11EF6
11EF0  F08F     NOP
11EF2  EF5E     GOTO 0x11EBC
11EF4  F08F     NOP
11EF6  EF89     GOTO 0x11F12
11EF8  F08F     NOP
25:            		++exp;
11EBC  2A0A     INCF exp, F, ACCESS
26:            		arg >>= 1;
11EBE  90D8     BCF STATUS, 0, ACCESS
11EC0  320E     RRCF neg, F, ACCESS
11EC2  320D     RRCF 0xD, F, ACCESS
11EC4  320C     RRCF s, F, ACCESS
11EC6  320B     RRCF arg, F, ACCESS
27:            	}
28:            	while(arg & ~0xFFFFFFUL) {
29:            		++exp;
11EFA  2A0A     INCF exp, F, ACCESS
30:            		++arg;
11EFC  0E01     MOVLW 0x1
11EFE  260B     ADDWF arg, F, ACCESS
11F00  0E00     MOVLW 0x0
11F02  220C     ADDWFC s, F, ACCESS
11F04  220D     ADDWFC 0xD, F, ACCESS
11F06  220E     ADDWFC neg, F, ACCESS
31:            		arg >>= 1;
11F08  90D8     BCF STATUS, 0, ACCESS
11F0A  320E     RRCF neg, F, ACCESS
11F0C  320D     RRCF 0xD, F, ACCESS
11F0E  320C     RRCF s, F, ACCESS
11F10  320B     RRCF arg, F, ACCESS
32:            	}
11F12  0E00     MOVLW 0x0
11F14  140B     ANDWF arg, W, ACCESS
11F16  6E05     MOVWF product, ACCESS
11F18  0E00     MOVLW 0x0
11F1A  140C     ANDWF s, W, ACCESS
11F1C  6E06     MOVWF L, ACCESS
11F1E  0E00     MOVLW 0x0
11F20  140D     ANDWF 0xD, W, ACCESS
11F22  6E07     MOVWF c, ACCESS
11F24  0EFF     MOVLW 0xFF
11F26  140E     ANDWF neg, W, ACCESS
11F28  6E08     MOVWF s, ACCESS
11F2A  5005     MOVF product, W, ACCESS
11F2C  1006     IORWF L, W, ACCESS
11F2E  1007     IORWF c, W, ACCESS
11F30  1008     IORWF s, W, ACCESS
11F32  A4D8     BTFSS STATUS, 2, ACCESS
11F34  EF9E     GOTO 0x11F3C
11F36  F08F     NOP
11F38  EFA0     GOTO 0x11F40
11F3A  F08F     NOP
11F3C  EF7D     GOTO 0x11EFA
11F3E  F08F     NOP
11F40  EFA8     GOTO 0x11F50
11F42  F08F     NOP
33:            	while(!(arg & 0x800000UL) && exp > 1) {
11F50  BE0D     BTFSC 0xD, 7, ACCESS
11F52  EFAD     GOTO 0x11F5A
11F54  F08F     NOP
11F56  EFAF     GOTO 0x11F5E
11F58  F08F     NOP
11F5A  EFB7     GOTO 0x11F6E
11F5C  F08F     NOP
11F5E  0E02     MOVLW 0x2
11F60  600A     CPFSLT exp, ACCESS
11F62  EFB5     GOTO 0x11F6A
11F64  F08F     NOP
11F66  EFB7     GOTO 0x11F6E
11F68  F08F     NOP
11F6A  EFA2     GOTO 0x11F44
11F6C  F08F     NOP
34:            		--exp;
11F44  060A     DECF exp, F, ACCESS
35:            		arg <<= 1;
11F46  90D8     BCF STATUS, 0, ACCESS
11F48  360B     RLCF arg, F, ACCESS
11F4A  360C     RLCF s, F, ACCESS
11F4C  360D     RLCF 0xD, F, ACCESS
11F4E  360E     RLCF neg, F, ACCESS
36:            	}
37:            	if(!(exp & 1))
11F6E  B00A     BTFSC exp, 0, ACCESS
11F70  EFBC     GOTO 0x11F78
11F72  F08F     NOP
11F74  EFBE     GOTO 0x11F7C
11F76  F08F     NOP
11F78  EFBF     GOTO 0x11F7E
11F7A  F08F     NOP
38:            		arg &= ~0x800000UL;
11F7C  9E0D     BCF 0xD, 7, ACCESS
39:            	exp >>= 1;
11F7E  90D8     BCF STATUS, 0, ACCESS
11F80  320A     RRCF exp, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
11F82  C00A     MOVFF exp, product
11F84  F005     NOP
11F86  6A06     CLRF L, ACCESS
11F88  6A07     CLRF c, ACCESS
11F8A  6A08     CLRF s, ACCESS
11F8C  C005     MOVFF product, s
11F8E  F008     NOP
11F90  6A07     CLRF c, ACCESS
11F92  6A06     CLRF L, ACCESS
11F94  6A05     CLRF product, ACCESS
11F96  5005     MOVF product, W, ACCESS
11F98  120B     IORWF arg, F, ACCESS
11F9A  5006     MOVF L, W, ACCESS
11F9C  120C     IORWF s, F, ACCESS
11F9E  5007     MOVF c, W, ACCESS
11FA0  120D     IORWF 0xD, F, ACCESS
11FA2  5008     MOVF s, W, ACCESS
11FA4  120E     IORWF neg, F, ACCESS
41:            	if(sign && val < 0)
11FA6  5009     MOVF divisor, W, ACCESS
11FA8  B4D8     BTFSC STATUS, 2, ACCESS
11FAA  EFD9     GOTO 0x11FB2
11FAC  F08F     NOP
11FAE  EFDB     GOTO 0x11FB6
11FB0  F08F     NOP
11FB2  EFE3     GOTO 0x11FC6
11FB4  F08F     NOP
11FB6  BE04     BTFSC 0x4, 7, ACCESS
11FB8  EFE2     GOTO 0x11FC4
11FBA  F08F     NOP
11FBC  EFE0     GOTO 0x11FC0
11FBE  F08F     NOP
11FC0  EFE3     GOTO 0x11FC6
11FC2  F08F     NOP
42:            		arg |= 0x80000000UL;
11FC4  8E0E     BSF neg, 7, ACCESS
43:            	return *(double *)&arg;
11FC6  C00B     MOVFF arg, __pcstackCOMRAM
11FC8  F001     NOP
11FCA  C00C     MOVFF s, t
11FCC  F002     NOP
11FCE  C00D     MOVFF 0xD, a
11FD0  F003     NOP
11FD2  C00E     MOVFF neg, 0x4
11FD4  F004     NOP
44:            }
11FD6  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/toupper.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int toupper(int c)
5:             {
6:             	if (islower(c)) return c & 0x5f;
127B4  0E9F     MOVLW 0x9F
127B6  6E09     MOVWF divisor, ACCESS
127B8  0EFF     MOVLW 0xFF
127BA  6E0A     MOVWF exp, ACCESS
127BC  C007     MOVFF c, arg
127BE  F00B     NOP
127C0  C008     MOVFF s, s
127C2  F00C     NOP
127C4  5009     MOVF divisor, W, ACCESS
127C6  260B     ADDWF arg, F, ACCESS
127C8  500A     MOVF exp, W, ACCESS
127CA  220C     ADDWFC s, F, ACCESS
127CC  500C     MOVF s, W, ACCESS
127CE  E10A     BNZ 0x27E4
127D0  0E1A     MOVLW 0x1A
127D2  5C0B     SUBWF arg, W, ACCESS
127D4  A0D8     BTFSS STATUS, 0, ACCESS
127D6  EFEF     GOTO 0x127DE
127D8  F093     NOP
127DA  EFF2     GOTO 0x127E4
127DC  F093     NOP
127DE  0E01     MOVLW 0x1
127E0  EFF3     GOTO 0x127E6
127E2  F093     NOP
127E4  0E00     MOVLW 0x0
127E6  6E0D     MOVWF 0xD, ACCESS
127E8  6A0E     CLRF neg, ACCESS
127EA  500D     MOVF 0xD, W, ACCESS
127EC  100E     IORWF neg, W, ACCESS
127EE  B4D8     BTFSC STATUS, 2, ACCESS
127F0  EFFC     GOTO 0x127F8
127F2  F093     NOP
127F4  EFFE     GOTO 0x127FC
127F6  F093     NOP
127F8  EF04     GOTO 0x12808
127FA  F094     NOP
127FC  0E5F     MOVLW 0x5F
127FE  1407     ANDWF c, W, ACCESS
12800  6E07     MOVWF c, ACCESS
12802  6A08     CLRF s, ACCESS
12804  EF08     GOTO 0x12810
12806  F094     NOP
7:             	return c;
12808  C007     MOVFF c, c
1280A  F007     NOP
1280C  C008     MOVFF s, s
1280E  F008     NOP
8:             }
12810  0012     RETURN 0
9:             
10:            int __toupper_l(int c, locale_t l)
11:            {
12:            	return toupper(c);
13:            }
14:            
15:            weak_alias(__toupper_l, toupper_l);
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/strlen.c  ------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
12AF4  C001     MOVFF __pcstackCOMRAM, a
12AF6  F003     NOP
12AF8  C002     MOVFF t, 0x4
12AFA  F004     NOP
8:             	while(*s) {
12AFC  EF82     GOTO 0x12B04
12AFE  F095     NOP
12B04  C001     MOVFF __pcstackCOMRAM, FSR2
12B06  FFD9     NOP
12B08  C002     MOVFF t, FSR2H
12B0A  FFDA     NOP
12B0C  50DF     MOVF INDF2, W, ACCESS
12B0E  A4D8     BTFSS STATUS, 2, ACCESS
12B10  EF8C     GOTO 0x12B18
12B12  F095     NOP
12B14  EF8E     GOTO 0x12B1C
12B16  F095     NOP
12B18  EF80     GOTO 0x12B00
12B1A  F095     NOP
9:             		s++;
12B00  4A01     INFSNZ __pcstackCOMRAM, F, ACCESS
12B02  2A02     INCF t, F, ACCESS
10:            	}
11:            	return (size_t)(s-a);
12B1C  5003     MOVF a, W, ACCESS
12B1E  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
12B20  6E01     MOVWF __pcstackCOMRAM, ACCESS
12B22  5004     MOVF 0x4, W, ACCESS
12B24  5802     SUBWFB t, W, ACCESS
12B26  6E02     MOVWF t, ACCESS
12:            }
12B28  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/sprcmul.c  -----------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
10E7E  5012     MOVF sign, W, ACCESS
10E80  0B80     ANDLW 0x80
10E82  6E1B     MOVWF sign, ACCESS
18:            	bexp = (unsigned char)(((*(SFP *) & b).fAsBytes.d) << 1);
10E84  5012     MOVF sign, W, ACCESS
10E86  2412     ADDWF sign, W, ACCESS
10E88  6E21     MOVWF bexp, ACCESS
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
10E8A  AE11     BTFSS i, 7, ACCESS
10E8C  EF4A     GOTO 0x10E94
10E8E  F087     NOP
10E90  EF4C     GOTO 0x10E98
10E92  F087     NOP
10E94  EF4D     GOTO 0x10E9A
10E96  F087     NOP
20:            		bexp |= 0x1;
10E98  8021     BSF bexp, 0, ACCESS
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
10E9A  5021     MOVF bexp, W, ACCESS
10E9C  B4D8     BTFSC STATUS, 2, ACCESS
10E9E  EF53     GOTO 0x10EA6
10EA0  F087     NOP
10EA2  EF55     GOTO 0x10EAA
10EA4  F087     NOP
10EA6  EF68     GOTO 0x10ED0
10EA8  F087     NOP
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
10EAA  2821     INCF bexp, W, ACCESS
10EAC  A4D8     BTFSS STATUS, 2, ACCESS
10EAE  EF5B     GOTO 0x10EB6
10EB0  F087     NOP
10EB2  EF5D     GOTO 0x10EBA
10EB4  F087     NOP
10EB6  EF65     GOTO 0x10ECA
10EB8  F087     NOP
27:            			/* Make it inf */
28:            			b = 0;
10EBA  0E00     MOVLW 0x0
10EBC  6E0F     MOVWF b, ACCESS
10EBE  0E00     MOVLW 0x0
10EC0  6E10     MOVWF c, ACCESS
10EC2  0E00     MOVLW 0x0
10EC4  6E11     MOVWF i, ACCESS
10EC6  0E00     MOVLW 0x0
10EC8  6E12     MOVWF sign, ACCESS
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
10ECA  8E11     BSF i, 7, ACCESS
32:            
33:            	}
10ECC  EF70     GOTO 0x10EE0
10ECE  F087     NOP
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
10ED0  0E00     MOVLW 0x0
10ED2  6E0F     MOVWF b, ACCESS
10ED4  0E00     MOVLW 0x0
10ED6  6E10     MOVWF c, ACCESS
10ED8  0E00     MOVLW 0x0
10EDA  6E11     MOVWF i, ACCESS
10EDC  0E00     MOVLW 0x0
10EDE  6E12     MOVWF sign, ACCESS
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
10EE0  5016     MOVF 0x16, W, ACCESS
10EE2  0B80     ANDLW 0x80
10EE4  1A1B     XORWF sign, F, ACCESS
40:            	aexp = (unsigned char)(((*(SFP *) & a).fAsBytes.d) << 1);
10EE6  5016     MOVF 0x16, W, ACCESS
10EE8  2416     ADDWF 0x16, W, ACCESS
10EEA  6E20     MOVWF d, ACCESS
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
10EEC  AE15     BTFSS n, 7, ACCESS
10EEE  EF7B     GOTO 0x10EF6
10EF0  F087     NOP
10EF2  EF7D     GOTO 0x10EFA
10EF4  F087     NOP
10EF6  EF7E     GOTO 0x10EFC
10EF8  F087     NOP
42:            		aexp |= 0x1;
10EFA  8020     BSF d, 0, ACCESS
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
10EFC  5020     MOVF d, W, ACCESS
10EFE  B4D8     BTFSC STATUS, 2, ACCESS
10F00  EF84     GOTO 0x10F08
10F02  F087     NOP
10F04  EF86     GOTO 0x10F0C
10F06  F087     NOP
10F08  EF99     GOTO 0x10F32
10F0A  F087     NOP
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
10F0C  2820     INCF d, W, ACCESS
10F0E  A4D8     BTFSS STATUS, 2, ACCESS
10F10  EF8C     GOTO 0x10F18
10F12  F087     NOP
10F14  EF8E     GOTO 0x10F1C
10F16  F087     NOP
10F18  EF96     GOTO 0x10F2C
10F1A  F087     NOP
49:            			/* Make it inf */
50:            			a = 0;
10F1C  0E00     MOVLW 0x0
10F1E  6E13     MOVWF a, ACCESS
10F20  0E00     MOVLW 0x0
10F22  6E14     MOVWF 0x14, ACCESS
10F24  0E00     MOVLW 0x0
10F26  6E15     MOVWF n, ACCESS
10F28  0E00     MOVLW 0x0
10F2A  6E16     MOVWF 0x16, ACCESS
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
10F2C  8E15     BSF n, 7, ACCESS
54:            	}
10F2E  EFA1     GOTO 0x10F42
10F30  F087     NOP
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
10F32  0E00     MOVLW 0x0
10F34  6E13     MOVWF a, ACCESS
10F36  0E00     MOVLW 0x0
10F38  6E14     MOVWF 0x14, ACCESS
10F3A  0E00     MOVLW 0x0
10F3C  6E15     MOVWF n, ACCESS
10F3E  0E00     MOVLW 0x0
10F40  6E16     MOVWF 0x16, ACCESS
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
10F42  5020     MOVF d, W, ACCESS
10F44  B4D8     BTFSC STATUS, 2, ACCESS
10F46  EFA7     GOTO 0x10F4E
10F48  F087     NOP
10F4A  EFA9     GOTO 0x10F52
10F4C  F087     NOP
10F4E  EFB1     GOTO 0x10F62
10F50  F087     NOP
10F52  5021     MOVF bexp, W, ACCESS
10F54  A4D8     BTFSS STATUS, 2, ACCESS
10F56  EFAF     GOTO 0x10F5E
10F58  F087     NOP
10F5A  EFB1     GOTO 0x10F62
10F5C  F087     NOP
10F5E  EFBB     GOTO 0x10F76
10F60  F087     NOP
66:            		return 0.0;
10F62  0E00     MOVLW 0x0
10F64  6E0F     MOVWF b, ACCESS
10F66  0E00     MOVLW 0x0
10F68  6E10     MOVWF c, ACCESS
10F6A  0E00     MOVLW 0x0
10F6C  6E11     MOVWF i, ACCESS
10F6E  0E00     MOVLW 0x0
10F70  6E12     MOVWF sign, ACCESS
10F72  EF53     GOTO 0x112A6
10F74  F089     NOP
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
10F76  5015     MOVF n, W, ACCESS
10F78  020F     MULWF b, ACCESS
10F7A  CFF3     MOVFF PROD, temp
10F7C  F026     NOP
10F7E  CFF4     MOVFF PRODH, 0x27
10F80  F027     NOP
96:            	grs = temp.nAsBytes.a;
10F82  5026     MOVF temp, W, ACCESS
10F84  6E1C     MOVWF w, ACCESS
10F86  6A1D     CLRF 0x1D, ACCESS
10F88  6A1E     CLRF fp, ACCESS
10F8A  6A1F     CLRF 0x1F, ACCESS
97:            	prod.i = temp.nAsBytes.b;
10F8C  5027     MOVF 0x27, W, ACCESS
10F8E  6E22     MOVWF prod, ACCESS
10F90  6A23     CLRF 0x23, ACCESS
10F92  6A24     CLRF 0x24, ACCESS
10F94  6A25     CLRF 0x25, ACCESS
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
10F96  5014     MOVF 0x14, W, ACCESS
10F98  0210     MULWF c, ACCESS
10F9A  CFF3     MOVFF PROD, temp
10F9C  F026     NOP
10F9E  CFF4     MOVFF PRODH, 0x27
10FA0  F027     NOP
99:            	grs += temp.nAsBytes.a;
10FA2  5026     MOVF temp, W, ACCESS
10FA4  261C     ADDWF w, F, ACCESS
10FA6  0E00     MOVLW 0x0
10FA8  221D     ADDWFC 0x1D, F, ACCESS
10FAA  221E     ADDWFC fp, F, ACCESS
10FAC  221F     ADDWFC 0x1F, F, ACCESS
100:           	prod.i += temp.nAsBytes.b;
10FAE  5027     MOVF 0x27, W, ACCESS
10FB0  2622     ADDWF prod, F, ACCESS
10FB2  0E00     MOVLW 0x0
10FB4  2223     ADDWFC 0x23, F, ACCESS
10FB6  2224     ADDWFC 0x24, F, ACCESS
10FB8  2225     ADDWFC 0x25, F, ACCESS
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
10FBA  5013     MOVF a, W, ACCESS
10FBC  0211     MULWF i, ACCESS
10FBE  CFF3     MOVFF PROD, temp
10FC0  F026     NOP
10FC2  CFF4     MOVFF PRODH, 0x27
10FC4  F027     NOP
102:           	grs += temp.nAsBytes.a;
10FC6  5026     MOVF temp, W, ACCESS
10FC8  261C     ADDWF w, F, ACCESS
10FCA  0E00     MOVLW 0x0
10FCC  221D     ADDWFC 0x1D, F, ACCESS
10FCE  221E     ADDWFC fp, F, ACCESS
10FD0  221F     ADDWFC 0x1F, F, ACCESS
103:           	prod.i += temp.nAsBytes.b;
10FD2  5027     MOVF 0x27, W, ACCESS
10FD4  2622     ADDWF prod, F, ACCESS
10FD6  0E00     MOVLW 0x0
10FD8  2223     ADDWFC 0x23, F, ACCESS
10FDA  2224     ADDWFC 0x24, F, ACCESS
10FDC  2225     ADDWFC 0x25, F, ACCESS
104:           	grs <<= 8;
10FDE  C01E     MOVFF fp, 0x1F
10FE0  F01F     NOP
10FE2  C01D     MOVFF 0x1D, fp
10FE4  F01E     NOP
10FE6  C01C     MOVFF w, 0x1D
10FE8  F01D     NOP
10FEA  6A1C     CLRF w, ACCESS
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
10FEC  5013     MOVF a, W, ACCESS
10FEE  0210     MULWF c, ACCESS
10FF0  CFF3     MOVFF PROD, temp
10FF2  F026     NOP
10FF4  CFF4     MOVFF PRODH, 0x27
10FF6  F027     NOP
106:           	grs += (unsigned long)temp.n;
10FF8  5026     MOVF temp, W, ACCESS
10FFA  261C     ADDWF w, F, ACCESS
10FFC  5027     MOVF 0x27, W, ACCESS
10FFE  221D     ADDWFC 0x1D, F, ACCESS
11000  0E00     MOVLW 0x0
11002  221E     ADDWFC fp, F, ACCESS
11004  0E00     MOVLW 0x0
11006  221F     ADDWFC 0x1F, F, ACCESS
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
11008  5014     MOVF 0x14, W, ACCESS
1100A  020F     MULWF b, ACCESS
1100C  CFF3     MOVFF PROD, temp
1100E  F026     NOP
11010  CFF4     MOVFF PRODH, 0x27
11012  F027     NOP
108:           	grs += (unsigned long)temp.n;
11014  5026     MOVF temp, W, ACCESS
11016  261C     ADDWF w, F, ACCESS
11018  5027     MOVF 0x27, W, ACCESS
1101A  221D     ADDWFC 0x1D, F, ACCESS
1101C  0E00     MOVLW 0x0
1101E  221E     ADDWFC fp, F, ACCESS
11020  0E00     MOVLW 0x0
11022  221F     ADDWFC 0x1F, F, ACCESS
109:           	grs <<= 8;
11024  C01E     MOVFF fp, 0x1F
11026  F01F     NOP
11028  C01D     MOVFF 0x1D, fp
1102A  F01E     NOP
1102C  C01C     MOVFF w, 0x1D
1102E  F01D     NOP
11030  6A1C     CLRF w, ACCESS
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
11032  5013     MOVF a, W, ACCESS
11034  020F     MULWF b, ACCESS
11036  CFF3     MOVFF PROD, temp
11038  F026     NOP
1103A  CFF4     MOVFF PRODH, 0x27
1103C  F027     NOP
111:           	grs += (unsigned long)temp.n;
1103E  5026     MOVF temp, W, ACCESS
11040  261C     ADDWF w, F, ACCESS
11042  5027     MOVF 0x27, W, ACCESS
11044  221D     ADDWFC 0x1D, F, ACCESS
11046  0E00     MOVLW 0x0
11048  221E     ADDWFC fp, F, ACCESS
1104A  0E00     MOVLW 0x0
1104C  221F     ADDWFC 0x1F, F, ACCESS
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
1104E  5015     MOVF n, W, ACCESS
11050  0210     MULWF c, ACCESS
11052  CFF3     MOVFF PROD, temp
11054  F026     NOP
11056  CFF4     MOVFF PRODH, 0x27
11058  F027     NOP
113:           	prod.i += (unsigned long)temp.n;
1105A  5026     MOVF temp, W, ACCESS
1105C  2622     ADDWF prod, F, ACCESS
1105E  5027     MOVF 0x27, W, ACCESS
11060  2223     ADDWFC 0x23, F, ACCESS
11062  0E00     MOVLW 0x0
11064  2224     ADDWFC 0x24, F, ACCESS
11066  0E00     MOVLW 0x0
11068  2225     ADDWFC 0x25, F, ACCESS
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
1106A  5014     MOVF 0x14, W, ACCESS
1106C  0211     MULWF i, ACCESS
1106E  CFF3     MOVFF PROD, temp
11070  F026     NOP
11072  CFF4     MOVFF PRODH, 0x27
11074  F027     NOP
115:           	prod.i += (unsigned long)temp.n;
11076  5026     MOVF temp, W, ACCESS
11078  2622     ADDWF prod, F, ACCESS
1107A  5027     MOVF 0x27, W, ACCESS
1107C  2223     ADDWFC 0x23, F, ACCESS
1107E  0E00     MOVLW 0x0
11080  2224     ADDWFC 0x24, F, ACCESS
11082  0E00     MOVLW 0x0
11084  2225     ADDWFC 0x25, F, ACCESS
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
11086  5015     MOVF n, W, ACCESS
11088  0211     MULWF i, ACCESS
1108A  CFF3     MOVFF PROD, temp
1108C  F026     NOP
1108E  CFF4     MOVFF PRODH, 0x27
11090  F027     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
11092  5026     MOVF temp, W, ACCESS
11094  6E17     MOVWF p, ACCESS
11096  5027     MOVF 0x27, W, ACCESS
11098  6E18     MOVWF 0x18, ACCESS
1109A  6A19     CLRF 0x19, ACCESS
1109C  6A1A     CLRF i, ACCESS
1109E  C019     MOVFF 0x19, i
110A0  F01A     NOP
110A2  C018     MOVFF 0x18, 0x19
110A4  F019     NOP
110A6  C017     MOVFF p, 0x18
110A8  F018     NOP
110AA  6A17     CLRF p, ACCESS
110AC  5017     MOVF p, W, ACCESS
110AE  2622     ADDWF prod, F, ACCESS
110B0  5018     MOVF 0x18, W, ACCESS
110B2  2223     ADDWFC 0x23, F, ACCESS
110B4  5019     MOVF 0x19, W, ACCESS
110B6  2224     ADDWFC 0x24, F, ACCESS
110B8  501A     MOVF i, W, ACCESS
110BA  2225     ADDWFC 0x25, F, ACCESS
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
110BC  C01C     MOVFF w, p
110BE  F017     NOP
110C0  C01D     MOVFF 0x1D, 0x18
110C2  F018     NOP
110C4  C01E     MOVFF fp, 0x19
110C6  F019     NOP
110C8  C01F     MOVFF 0x1F, i
110CA  F01A     NOP
110CC  0E19     MOVLW 0x19
110CE  EF6E     GOTO 0x110DC
110D0  F088     NOP
110D2  90D8     BCF STATUS, 0, ACCESS
110D4  321A     RRCF i, F, ACCESS
110D6  3219     RRCF 0x19, F, ACCESS
110D8  3218     RRCF 0x18, F, ACCESS
110DA  3217     RRCF p, F, ACCESS
110DC  2EE8     DECFSZ WREG, F, ACCESS
110DE  EF69     GOTO 0x110D2
110E0  F088     NOP
110E2  5017     MOVF p, W, ACCESS
110E4  2622     ADDWF prod, F, ACCESS
110E6  5018     MOVF 0x18, W, ACCESS
110E8  2223     ADDWFC 0x23, F, ACCESS
110EA  5019     MOVF 0x19, W, ACCESS
110EC  2224     ADDWFC 0x24, F, ACCESS
110EE  501A     MOVF i, W, ACCESS
110F0  2225     ADDWFC 0x25, F, ACCESS
146:           	grs <<= 8;
110F2  C01E     MOVFF fp, 0x1F
110F4  F01F     NOP
110F6  C01D     MOVFF 0x1D, fp
110F8  F01E     NOP
110FA  C01C     MOVFF w, 0x1D
110FC  F01D     NOP
110FE  6A1C     CLRF w, ACCESS
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
11100  5020     MOVF d, W, ACCESS
11102  C021     MOVFF bexp, p
11104  F017     NOP
11106  6A18     CLRF 0x18, ACCESS
11108  2617     ADDWF p, F, ACCESS
1110A  0E00     MOVLW 0x0
1110C  2218     ADDWFC 0x18, F, ACCESS
1110E  0E82     MOVLW 0x82
11110  2417     ADDWF p, W, ACCESS
11112  6E26     MOVWF temp, ACCESS
11114  0EFF     MOVLW 0xFF
11116  2018     ADDWFC 0x18, W, ACCESS
11118  6E27     MOVWF 0x27, ACCESS
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
1111A  EFA4     GOTO 0x11148
1111C  F088     NOP
11148  AE24     BTFSS 0x24, 7, ACCESS
1114A  EFA9     GOTO 0x11152
1114C  F088     NOP
1114E  EFAB     GOTO 0x11156
11150  F088     NOP
11152  EF8F     GOTO 0x1111E
11154  F088     NOP
153:           		prod.i <<= 1;
1111E  90D8     BCF STATUS, 0, ACCESS
11120  3622     RLCF prod, F, ACCESS
11122  3623     RLCF 0x23, F, ACCESS
11124  3624     RLCF 0x24, F, ACCESS
11126  3625     RLCF 0x25, F, ACCESS
154:           		if (grs & 0x80000000) {
11128  AE1F     BTFSS 0x1F, 7, ACCESS
1112A  EF99     GOTO 0x11132
1112C  F088     NOP
1112E  EF9B     GOTO 0x11136
11130  F088     NOP
11132  EF9C     GOTO 0x11138
11134  F088     NOP
155:           			prod.i |= 0x1;
11136  8022     BSF prod, 0, ACCESS
156:           		}
157:           		grs <<= 1;
11138  90D8     BCF STATUS, 0, ACCESS
1113A  361C     RLCF w, F, ACCESS
1113C  361D     RLCF 0x1D, F, ACCESS
1113E  361E     RLCF fp, F, ACCESS
11140  361F     RLCF 0x1F, F, ACCESS
158:           		--temp.i;
11142  0626     DECF temp, F, ACCESS
11144  A0D8     BTFSS STATUS, 0, ACCESS
11146  0627     DECF 0x27, F, ACCESS
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
11156  0E00     MOVLW 0x0
11158  6E20     MOVWF d, ACCESS
164:           	if (grs & 0x80000000) {
1115A  AE1F     BTFSS 0x1F, 7, ACCESS
1115C  EFB2     GOTO 0x11164
1115E  F088     NOP
11160  EFB4     GOTO 0x11168
11162  F088     NOP
11164  EFD8     GOTO 0x111B0
11166  F088     NOP
165:           		if (grs & 0x7FFFFFFF) {
11168  0EFF     MOVLW 0xFF
1116A  141C     ANDWF w, W, ACCESS
1116C  6E17     MOVWF p, ACCESS
1116E  0EFF     MOVLW 0xFF
11170  141D     ANDWF 0x1D, W, ACCESS
11172  6E18     MOVWF 0x18, ACCESS
11174  0EFF     MOVLW 0xFF
11176  141E     ANDWF fp, W, ACCESS
11178  6E19     MOVWF 0x19, ACCESS
1117A  0E7F     MOVLW 0x7F
1117C  141F     ANDWF 0x1F, W, ACCESS
1117E  6E1A     MOVWF i, ACCESS
11180  5017     MOVF p, W, ACCESS
11182  1018     IORWF 0x18, W, ACCESS
11184  1019     IORWF 0x19, W, ACCESS
11186  101A     IORWF i, W, ACCESS
11188  B4D8     BTFSC STATUS, 2, ACCESS
1118A  EFC9     GOTO 0x11192
1118C  F088     NOP
1118E  EFCB     GOTO 0x11196
11190  F088     NOP
11192  EFCF     GOTO 0x1119E
11194  F088     NOP
166:           			aexp = 1;
11196  0E01     MOVLW 0x1
11198  6E20     MOVWF d, ACCESS
167:           		}
1119A  EFD8     GOTO 0x111B0
1119C  F088     NOP
168:           		else {
169:           			if (prod.i & 1) {
1119E  A022     BTFSS prod, 0, ACCESS
111A0  EFD4     GOTO 0x111A8
111A2  F088     NOP
111A4  EFD6     GOTO 0x111AC
111A6  F088     NOP
111A8  EFD8     GOTO 0x111B0
111AA  F088     NOP
111AC  EFCB     GOTO 0x11196
111AE  F088     NOP
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
111B0  5020     MOVF d, W, ACCESS
111B2  B4D8     BTFSC STATUS, 2, ACCESS
111B4  EFDE     GOTO 0x111BC
111B6  F088     NOP
111B8  EFE0     GOTO 0x111C0
111BA  F088     NOP
111BC  EF04     GOTO 0x11208
111BE  F089     NOP
175:           		++prod.i;
111C0  0E01     MOVLW 0x1
111C2  2622     ADDWF prod, F, ACCESS
111C4  0E00     MOVLW 0x0
111C6  2223     ADDWFC 0x23, F, ACCESS
111C8  2224     ADDWFC 0x24, F, ACCESS
111CA  2225     ADDWFC 0x25, F, ACCESS
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
111CC  A025     BTFSS 0x25, 0, ACCESS
111CE  EFEB     GOTO 0x111D6
111D0  F088     NOP
111D2  EFED     GOTO 0x111DA
111D4  F088     NOP
111D6  EF04     GOTO 0x11208
111D8  F089     NOP
177:           			prod.i = prod.i >> 1;
111DA  C022     MOVFF prod, p
111DC  F017     NOP
111DE  C023     MOVFF 0x23, 0x18
111E0  F018     NOP
111E2  C024     MOVFF 0x24, 0x19
111E4  F019     NOP
111E6  C025     MOVFF 0x25, i
111E8  F01A     NOP
111EA  341A     RLCF i, W, ACCESS
111EC  321A     RRCF i, F, ACCESS
111EE  3219     RRCF 0x19, F, ACCESS
111F0  3218     RRCF 0x18, F, ACCESS
111F2  3217     RRCF p, F, ACCESS
111F4  C017     MOVFF p, prod
111F6  F022     NOP
111F8  C018     MOVFF 0x18, 0x23
111FA  F023     NOP
111FC  C019     MOVFF 0x19, 0x24
111FE  F024     NOP
11200  C01A     MOVFF i, 0x25
11202  F025     NOP
178:           			++temp.i;
11204  4A26     INFSNZ temp, F, ACCESS
11206  2A27     INCF 0x27, F, ACCESS
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
11208  BE27     BTFSC 0x27, 7, ACCESS
1120A  EF0F     GOTO 0x1121E
1120C  F089     NOP
1120E  5027     MOVF 0x27, W, ACCESS
11210  E108     BNZ 0x1222
11212  2826     INCF temp, W, ACCESS
11214  A0D8     BTFSS STATUS, 0, ACCESS
11216  EF0F     GOTO 0x1121E
11218  F089     NOP
1121A  EF11     GOTO 0x11222
1121C  F089     NOP
1121E  EF1B     GOTO 0x11236
11220  F089     NOP
184:           		prod.i = 0x7F800000;
11222  0E00     MOVLW 0x0
11224  6E22     MOVWF prod, ACCESS
11226  0E00     MOVLW 0x0
11228  6E23     MOVWF 0x23, ACCESS
1122A  0E80     MOVLW 0x80
1122C  6E24     MOVWF 0x24, ACCESS
1122E  0E7F     MOVLW 0x7F
11230  6E25     MOVWF 0x25, ACCESS
185:           	}
11232  EF49     GOTO 0x11292
11234  F089     NOP
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
11236  BE27     BTFSC 0x27, 7, ACCESS
11238  EF28     GOTO 0x11250
1123A  F089     NOP
1123C  5027     MOVF 0x27, W, ACCESS
1123E  E106     BNZ 0x124C
11240  0426     DECF temp, W, ACCESS
11242  B0D8     BTFSC STATUS, 0, ACCESS
11244  EF26     GOTO 0x1124C
11246  F089     NOP
11248  EF28     GOTO 0x11250
1124A  F089     NOP
1124C  EF34     GOTO 0x11268
1124E  F089     NOP
188:           		prod.i = 0;
11250  0E00     MOVLW 0x0
11252  6E22     MOVWF prod, ACCESS
11254  0E00     MOVLW 0x0
11256  6E23     MOVWF 0x23, ACCESS
11258  0E00     MOVLW 0x0
1125A  6E24     MOVWF 0x24, ACCESS
1125C  0E00     MOVLW 0x0
1125E  6E25     MOVWF 0x25, ACCESS
189:                           // no negative 0 for now
190:                           sign=0;
11260  0E00     MOVLW 0x0
11262  6E1B     MOVWF sign, ACCESS
191:           	}
11264  EF49     GOTO 0x11292
11266  F089     NOP
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = (unsigned char)temp.i;	// it fits in 8 bits !
11268  C026     MOVFF temp, bexp
1126A  F021     NOP
195:           		prod.i &= SPFRCM;	// trim away the leading 1
1126C  0EFF     MOVLW 0xFF
1126E  1622     ANDWF prod, F, ACCESS
11270  0EFF     MOVLW 0xFF
11272  1623     ANDWF 0x23, F, ACCESS
11274  0E7F     MOVLW 0x7F
11276  1624     ANDWF 0x24, F, ACCESS
11278  0E00     MOVLW 0x0
1127A  1625     ANDWF 0x25, F, ACCESS
196:           		if (bexp & 0x1) {
1127C  A021     BTFSS bexp, 0, ACCESS
1127E  EF43     GOTO 0x11286
11280  F089     NOP
11282  EF45     GOTO 0x1128A
11284  F089     NOP
11286  EF46     GOTO 0x1128C
11288  F089     NOP
197:           			prod.fAsBytes.c |= 0x80;
1128A  8E24     BSF 0x24, 7, ACCESS
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
1128C  90D8     BCF STATUS, 0, ACCESS
1128E  3021     RRCF bexp, W, ACCESS
11290  6E25     MOVWF 0x25, ACCESS
200:           	}
201:           	prod.fAsBytes.d |= sign;
11292  501B     MOVF sign, W, ACCESS
11294  1225     IORWF 0x25, F, ACCESS
202:           
203:           	return prod.f;
11296  C022     MOVFF prod, b
11298  F00F     NOP
1129A  C023     MOVFF 0x23, c
1129C  F010     NOP
1129E  C024     MOVFF 0x24, i
112A0  F011     NOP
112A2  C025     MOVFF 0x25, sign
112A4  F012     NOP
204:           
205:           }
112A6  0012     RETURN 0
206:           
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/printf.c  ------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
12B90  0E59     MOVLW 0x59
12B92  0100     MOVLB 0x0
12B94  6F9F     MOVWF ap, BANKED
12B96  0E00     MOVLW 0x0
12B98  6FA0     MOVWF 0xA0, BANKED
10:            	ret = vfprintf(stdout, fmt, ap);
12B9A  0E00     MOVLW 0x0
12B9C  6E4F     MOVWF fp, ACCESS
12B9E  0E00     MOVLW 0x0
12BA0  6E50     MOVWF 0x50, ACCESS
12BA2  C057     MOVFF fmt, fmt
12BA4  F051     NOP
12BA6  C058     MOVFF 0x58, 0x52
12BA8  F052     NOP
12BAA  0E9F     MOVLW 0x9F
12BAC  6E53     MOVWF ap, ACCESS
12BAE  0E00     MOVLW 0x0
12BB0  6E54     MOVWF 0x54, ACCESS
12BB2  ECA7     CALL 0x1274E, 0
12BB4  F093     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
12BB6  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/nf_fputs.c  ----------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
12908  0E00     MOVLW 0x0
1290A  6E12     MOVWF sign, ACCESS
1290C  0E00     MOVLW 0x0
1290E  6E11     MOVWF i, ACCESS
14:                while ((c = *(s + i))) {
12910  EF95     GOTO 0x1292A
12912  F094     NOP
1292A  5011     MOVF i, W, ACCESS
1292C  240C     ADDWF s, W, ACCESS
1292E  6ED9     MOVWF FSR2, ACCESS
12930  5012     MOVF sign, W, ACCESS
12932  200D     ADDWFC 0xD, W, ACCESS
12934  6EDA     MOVWF FSR2H, ACCESS
12936  50DF     MOVF INDF2, W, ACCESS
12938  6E10     MOVWF c, ACCESS
1293A  5010     MOVF c, W, ACCESS
1293C  A4D8     BTFSS STATUS, 2, ACCESS
1293E  EFA3     GOTO 0x12946
12940  F094     NOP
12942  EFA5     GOTO 0x1294A
12944  F094     NOP
12946  EF8A     GOTO 0x12914
12948  F094     NOP
15:            	fputc(c,fp);
12914  C010     MOVFF c, a
12916  F003     NOP
12918  6A04     CLRF 0x4, ACCESS
1291A  C00E     MOVFF neg, product
1291C  F005     NOP
1291E  C00F     MOVFF b, L
12920  F006     NOP
12922  EC1A     CALL 0x12634, 0
12924  F093     NOP
16:                    ++i;
12926  4A11     INFSNZ i, F, ACCESS
12928  2A12     INCF sign, F, ACCESS
17:                }
18:                return i;
19:            }
1294A  0012     RETURN 0
20:            
21:            #endif
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/nf_fputc.c  ----------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
12634  5005     MOVF product, W, ACCESS
12636  1006     IORWF L, W, ACCESS
12638  B4D8     BTFSC STATUS, 2, ACCESS
1263A  EF21     GOTO 0x12642
1263C  F093     NOP
1263E  EF23     GOTO 0x12646
12640  F093     NOP
12642  EF2C     GOTO 0x12658
12644  F093     NOP
12646  5005     MOVF product, W, ACCESS
12648  1006     IORWF L, W, ACCESS
1264A  A4D8     BTFSS STATUS, 2, ACCESS
1264C  EF2A     GOTO 0x12654
1264E  F093     NOP
12650  EF2C     GOTO 0x12658
12652  F093     NOP
12654  EF31     GOTO 0x12662
12656  F093     NOP
13:                    putch((char)c);
12658  5003     MOVF a, W, ACCESS
1265A  ECF5     CALL 0x12BEA, 0
1265C  F095     NOP
14:                } else {
1265E  EF64     GOTO 0x126C8
12660  F093     NOP
15:            		if((fp->limit == 0) || (fp->count < fp->limit)) {
12662  EE20     LFSR 2, 0x4
12664  F004     NOP
12666  5005     MOVF product, W, ACCESS
12668  26D9     ADDWF FSR2, F, ACCESS
1266A  5006     MOVF L, W, ACCESS
1266C  22DA     ADDWFC FSR2H, F, ACCESS
1266E  50DE     MOVF POSTINC2, W, ACCESS
12670  10DE     IORWF POSTINC2, W, ACCESS
12672  B4D8     BTFSC STATUS, 2, ACCESS
12674  EF3E     GOTO 0x1267C
12676  F093     NOP
12678  EF40     GOTO 0x12680
1267A  F093     NOP
1267C  EF5B     GOTO 0x126B6
1267E  F093     NOP
12680  EE20     LFSR 2, 0x4
12682  F004     NOP
12684  5005     MOVF product, W, ACCESS
12686  26D9     ADDWF FSR2, F, ACCESS
12688  5006     MOVF L, W, ACCESS
1268A  22DA     ADDWFC FSR2H, F, ACCESS
1268C  EE10     LFSR 1, 0x2
1268E  F002     NOP
12690  5005     MOVF product, W, ACCESS
12692  26E1     ADDWF FSR1, F, ACCESS
12694  5006     MOVF L, W, ACCESS
12696  22E2     ADDWFC FSR1H, F, ACCESS
12698  50DE     MOVF POSTINC2, W, ACCESS
1269A  5CE6     SUBWF POSTINC1, W, ACCESS
1269C  50E6     MOVF POSTINC1, W, ACCESS
1269E  0A80     XORLW 0x80
126A0  6E0B     MOVWF arg, ACCESS
126A2  50DE     MOVF POSTINC2, W, ACCESS
126A4  0A80     XORLW 0x80
126A6  580B     SUBWFB arg, W, ACCESS
126A8  B0D8     BTFSC STATUS, 0, ACCESS
126AA  EF59     GOTO 0x126B2
126AC  F093     NOP
126AE  EF5B     GOTO 0x126B6
126B0  F093     NOP
126B2  EF64     GOTO 0x126C8
126B4  F093     NOP
16:            #pragma warning push
17:            #pragma warning disable 1498
18:            			fp->buffer[fp->count] = (char)c;
19:            #pragma warning pop
20:            			++fp->count;
126B6  EE20     LFSR 2, 0x2
126B8  F002     NOP
126BA  5005     MOVF product, W, ACCESS
126BC  26D9     ADDWF FSR2, F, ACCESS
126BE  5006     MOVF L, W, ACCESS
126C0  22DA     ADDWFC FSR2H, F, ACCESS
126C2  2ADE     INCF POSTINC2, F, ACCESS
126C4  0E00     MOVLW 0x0
126C6  22DD     ADDWFC POSTDEC2, F, ACCESS
21:            		}
22:                }
23:                return (unsigned char)c;
24:            }
126C8  0012     RETURN 0
25:            
26:            #endif
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/isupper.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
6:             {
7:             	return (unsigned)c-'A' < 26;
12A84  0EBF     MOVLW 0xBF
12A86  6E03     MOVWF a, ACCESS
12A88  0EFF     MOVLW 0xFF
12A8A  6E04     MOVWF 0x4, ACCESS
12A8C  C001     MOVFF __pcstackCOMRAM, product
12A8E  F005     NOP
12A90  C002     MOVFF t, L
12A92  F006     NOP
12A94  5003     MOVF a, W, ACCESS
12A96  2605     ADDWF product, F, ACCESS
12A98  5004     MOVF 0x4, W, ACCESS
12A9A  2206     ADDWFC L, F, ACCESS
12A9C  5006     MOVF L, W, ACCESS
12A9E  E10A     BNZ 0x2AB4
12AA0  0E1A     MOVLW 0x1A
12AA2  5C05     SUBWF product, W, ACCESS
12AA4  A0D8     BTFSS STATUS, 0, ACCESS
12AA6  EF57     GOTO 0x12AAE
12AA8  F095     NOP
12AAA  EF5A     GOTO 0x12AB4
12AAC  F095     NOP
12AAE  0E01     MOVLW 0x1
12AB0  EF5B     GOTO 0x12AB6
12AB2  F095     NOP
12AB4  0E00     MOVLW 0x0
12AB6  6E01     MOVWF __pcstackCOMRAM, ACCESS
12AB8  6A02     CLRF t, ACCESS
8:             }
12ABA  0012     RETURN 0
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/isspace.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
1286C  0E01     MOVLW 0x1
1286E  6E07     MOVWF c, ACCESS
12870  0E20     MOVLW 0x20
12872  1801     XORWF __pcstackCOMRAM, W, ACCESS
12874  1002     IORWF t, W, ACCESS
12876  B4D8     BTFSC STATUS, 2, ACCESS
12878  EF40     GOTO 0x12880
1287A  F094     NOP
1287C  EF42     GOTO 0x12884
1287E  F094     NOP
12880  EF5B     GOTO 0x128B6
12882  F094     NOP
12884  0EF7     MOVLW 0xF7
12886  6E03     MOVWF a, ACCESS
12888  0EFF     MOVLW 0xFF
1288A  6E04     MOVWF 0x4, ACCESS
1288C  C001     MOVFF __pcstackCOMRAM, product
1288E  F005     NOP
12890  C002     MOVFF t, L
12892  F006     NOP
12894  5003     MOVF a, W, ACCESS
12896  2605     ADDWF product, F, ACCESS
12898  5004     MOVF 0x4, W, ACCESS
1289A  2206     ADDWFC L, F, ACCESS
1289C  5006     MOVF L, W, ACCESS
1289E  E109     BNZ 0x28B2
128A0  0E05     MOVLW 0x5
128A2  5C05     SUBWF product, W, ACCESS
128A4  A0D8     BTFSS STATUS, 0, ACCESS
128A6  EF57     GOTO 0x128AE
128A8  F094     NOP
128AA  EF59     GOTO 0x128B2
128AC  F094     NOP
128AE  EF5B     GOTO 0x128B6
128B0  F094     NOP
128B2  0E00     MOVLW 0x0
128B4  6E07     MOVWF c, ACCESS
128B6  C007     MOVFF c, __pcstackCOMRAM
128B8  F001     NOP
128BA  6A02     CLRF t, ACCESS
8:             }
128BC  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/islower.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef islower
4:             
5:             int islower(int c)
6:             {
7:             	return (unsigned)c-'a' < 26;
12A4C  0E9F     MOVLW 0x9F
12A4E  6E03     MOVWF a, ACCESS
12A50  0EFF     MOVLW 0xFF
12A52  6E04     MOVWF 0x4, ACCESS
12A54  C001     MOVFF __pcstackCOMRAM, product
12A56  F005     NOP
12A58  C002     MOVFF t, L
12A5A  F006     NOP
12A5C  5003     MOVF a, W, ACCESS
12A5E  2605     ADDWF product, F, ACCESS
12A60  5004     MOVF 0x4, W, ACCESS
12A62  2206     ADDWFC L, F, ACCESS
12A64  5006     MOVF L, W, ACCESS
12A66  E10A     BNZ 0x2A7C
12A68  0E1A     MOVLW 0x1A
12A6A  5C05     SUBWF product, W, ACCESS
12A6C  A0D8     BTFSS STATUS, 0, ACCESS
12A6E  EF3B     GOTO 0x12A76
12A70  F095     NOP
12A72  EF3E     GOTO 0x12A7C
12A74  F095     NOP
12A76  0E01     MOVLW 0x1
12A78  EF3F     GOTO 0x12A7E
12A7A  F095     NOP
12A7C  0E00     MOVLW 0x0
12A7E  6E01     MOVWF __pcstackCOMRAM, ACCESS
12A80  6A02     CLRF t, ACCESS
8:             }
12A82  0012     RETURN 0
9:             
10:            int __islower_l(int c, locale_t l)
11:            {
12:            	return islower(c);
13:            }
14:            
15:            weak_alias(__islower_l, islower_l);
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/isdigit.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
12ABC  0ED0     MOVLW 0xD0
12ABE  6E03     MOVWF a, ACCESS
12AC0  0EFF     MOVLW 0xFF
12AC2  6E04     MOVWF 0x4, ACCESS
12AC4  C001     MOVFF __pcstackCOMRAM, product
12AC6  F005     NOP
12AC8  C002     MOVFF t, L
12ACA  F006     NOP
12ACC  5003     MOVF a, W, ACCESS
12ACE  2605     ADDWF product, F, ACCESS
12AD0  5004     MOVF 0x4, W, ACCESS
12AD2  2206     ADDWFC L, F, ACCESS
12AD4  5006     MOVF L, W, ACCESS
12AD6  E10A     BNZ 0x2AEC
12AD8  0E0A     MOVLW 0xA
12ADA  5C05     SUBWF product, W, ACCESS
12ADC  A0D8     BTFSS STATUS, 0, ACCESS
12ADE  EF73     GOTO 0x12AE6
12AE0  F095     NOP
12AE2  EF76     GOTO 0x12AEC
12AE4  F095     NOP
12AE6  0E01     MOVLW 0x1
12AE8  EF77     GOTO 0x12AEE
12AEA  F095     NOP
12AEC  0E00     MOVLW 0x0
12AEE  6E01     MOVWF __pcstackCOMRAM, ACCESS
12AF0  6A02     CLRF t, ACCESS
8:             }
12AF2  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/isalpha.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isalpha
4:             
5:             int isalpha(int c)
6:             {
7:             	return ((unsigned)c|32)-'a' < 26;
12A10  0E9F     MOVLW 0x9F
12A12  6E03     MOVWF a, ACCESS
12A14  0EFF     MOVLW 0xFF
12A16  6E04     MOVWF 0x4, ACCESS
12A18  0E20     MOVLW 0x20
12A1A  1001     IORWF __pcstackCOMRAM, W, ACCESS
12A1C  6E05     MOVWF product, ACCESS
12A1E  0E00     MOVLW 0x0
12A20  1002     IORWF t, W, ACCESS
12A22  6E06     MOVWF L, ACCESS
12A24  5003     MOVF a, W, ACCESS
12A26  2605     ADDWF product, F, ACCESS
12A28  5004     MOVF 0x4, W, ACCESS
12A2A  2206     ADDWFC L, F, ACCESS
12A2C  5006     MOVF L, W, ACCESS
12A2E  E10A     BNZ 0x2A44
12A30  0E1A     MOVLW 0x1A
12A32  5C05     SUBWF product, W, ACCESS
12A34  A0D8     BTFSS STATUS, 0, ACCESS
12A36  EF1F     GOTO 0x12A3E
12A38  F095     NOP
12A3A  EF22     GOTO 0x12A44
12A3C  F095     NOP
12A3E  0E01     MOVLW 0x1
12A40  EF23     GOTO 0x12A46
12A42  F095     NOP
12A44  0E00     MOVLW 0x0
12A46  6E01     MOVWF __pcstackCOMRAM, ACCESS
12A48  6A02     CLRF t, ACCESS
8:             }
12A4A  0012     RETURN 0
9:             
10:            int __isalpha_l(int c, locale_t l)
11:            {
12:            	return isalpha(c);
13:            }
14:            
15:            weak_alias(__isalpha_l, isalpha_l);
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/fltol.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = (unsigned char)(f1_as_mant1 >> 23)) == 0)
12468  342A     RLCF 0x2A, W, ACCESS
1246A  342B     RLCF 0x2B, W, ACCESS
1246C  6E31     MOVWF exp1, ACCESS
1246E  5031     MOVF exp1, W, ACCESS
12470  A4D8     BTFSS STATUS, 2, ACCESS
12472  EF3D     GOTO 0x1247A
12474  F092     NOP
12476  EF3F     GOTO 0x1247E
12478  F092     NOP
1247A  EF49     GOTO 0x12492
1247C  F092     NOP
48:            		return 0;
1247E  0E00     MOVLW 0x0
12480  6E28     MOVWF x, ACCESS
12482  0E00     MOVLW 0x0
12484  6E29     MOVWF 0x29, ACCESS
12486  0E00     MOVLW 0x0
12488  6E2A     MOVWF 0x2A, ACCESS
1248A  0E00     MOVLW 0x0
1248C  6E2B     MOVWF 0x2B, ACCESS
1248E  EFB6     GOTO 0x1256C
12490  F092     NOP
49:            	sign1 = f1_as_mant1 >> 31;
12492  C028     MOVFF x, 0x2C
12494  F02C     NOP
12496  C029     MOVFF 0x29, 0x2D
12498  F02D     NOP
1249A  C02A     MOVFF 0x2A, 0x2E
1249C  F02E     NOP
1249E  C02B     MOVFF 0x2B, 0x2F
124A0  F02F     NOP
124A2  0E20     MOVLW 0x20
124A4  EF59     GOTO 0x124B2
124A6  F092     NOP
124A8  90D8     BCF STATUS, 0, ACCESS
124AA  322F     RRCF 0x2F, F, ACCESS
124AC  322E     RRCF 0x2E, F, ACCESS
124AE  322D     RRCF 0x2D, F, ACCESS
124B0  322C     RRCF 0x2C, F, ACCESS
124B2  2EE8     DECFSZ WREG, F, ACCESS
124B4  EF54     GOTO 0x124A8
124B6  F092     NOP
124B8  502C     MOVF 0x2C, W, ACCESS
124BA  6E30     MOVWF sign1, ACCESS
50:            	f1_as_mant1 |= 0x800000UL;
124BC  8E2A     BSF 0x2A, 7, ACCESS
51:            	f1_as_mant1 &= 0xFFFFFFUL;
124BE  0EFF     MOVLW 0xFF
124C0  1628     ANDWF x, F, ACCESS
124C2  0EFF     MOVLW 0xFF
124C4  1629     ANDWF 0x29, F, ACCESS
124C6  0EFF     MOVLW 0xFF
124C8  162A     ANDWF 0x2A, F, ACCESS
124CA  0E00     MOVLW 0x0
124CC  162B     ANDWF 0x2B, F, ACCESS
52:            	exp1 -= 127+23;
124CE  0E96     MOVLW 0x96
124D0  5E31     SUBWF exp1, F, ACCESS
53:            	if((signed char)exp1 < 0) {
124D2  BE31     BTFSC exp1, 7, ACCESS
124D4  EF70     GOTO 0x124E0
124D6  F092     NOP
124D8  EF6E     GOTO 0x124DC
124DA  F092     NOP
124DC  EF86     GOTO 0x1250C
124DE  F092     NOP
54:            		if((signed char)exp1 < -23)
124E0  5031     MOVF exp1, W, ACCESS
124E2  0A80     XORLW 0x80
124E4  0F97     ADDLW 0x97
124E6  B0D8     BTFSC STATUS, 0, ACCESS
124E8  EF78     GOTO 0x124F0
124EA  F092     NOP
124EC  EF7A     GOTO 0x124F4
124EE  F092     NOP
124F0  EF7C     GOTO 0x124F8
124F2  F092     NOP
124F4  EF3F     GOTO 0x1247E
124F6  F092     NOP
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
124F8  90D8     BCF STATUS, 0, ACCESS
124FA  322B     RRCF 0x2B, F, ACCESS
124FC  322A     RRCF 0x2A, F, ACCESS
124FE  3229     RRCF 0x29, F, ACCESS
12500  3228     RRCF x, F, ACCESS
12502  3E31     INCFSZ exp1, F, ACCESS
12504  EF7C     GOTO 0x124F8
12506  F092     NOP
12508  EF9E     GOTO 0x1253C
1250A  F092     NOP
58:            		while(++exp1 != 0);
59:            	} else {
60:            		if(exp1 >= 32)
1250C  0E1F     MOVLW 0x1F
1250E  6431     CPFSGT exp1, ACCESS
12510  EF8C     GOTO 0x12518
12512  F092     NOP
12514  EF8E     GOTO 0x1251C
12516  F092     NOP
12518  EF96     GOTO 0x1252C
1251A  F092     NOP
1251C  EF3F     GOTO 0x1247E
1251E  F092     NOP
61:            			return 00;
62:            		while(exp1 != 0) {
1252C  5031     MOVF exp1, W, ACCESS
1252E  A4D8     BTFSS STATUS, 2, ACCESS
12530  EF9C     GOTO 0x12538
12532  F092     NOP
12534  EF9E     GOTO 0x1253C
12536  F092     NOP
12538  EF90     GOTO 0x12520
1253A  F092     NOP
63:            			f1_as_mant1 <<= 1;
12520  90D8     BCF STATUS, 0, ACCESS
12522  3628     RLCF x, F, ACCESS
12524  3629     RLCF 0x29, F, ACCESS
12526  362A     RLCF 0x2A, F, ACCESS
12528  362B     RLCF 0x2B, F, ACCESS
64:            			exp1--;
1252A  0631     DECF exp1, F, ACCESS
65:            		}
66:            	}
67:            	if(sign1)
1253C  5030     MOVF sign1, W, ACCESS
1253E  B4D8     BTFSC STATUS, 2, ACCESS
12540  EFA4     GOTO 0x12548
12542  F092     NOP
12544  EFA6     GOTO 0x1254C
12546  F092     NOP
12548  EFAE     GOTO 0x1255C
1254A  F092     NOP
68:            		f1_as_mant1 = -f1_as_mant1;
1254C  1E2B     COMF 0x2B, F, ACCESS
1254E  1E2A     COMF 0x2A, F, ACCESS
12550  1E29     COMF 0x29, F, ACCESS
12552  6C28     NEGF x, ACCESS
12554  0E00     MOVLW 0x0
12556  2229     ADDWFC 0x29, F, ACCESS
12558  222A     ADDWFC 0x2A, F, ACCESS
1255A  222B     ADDWFC 0x2B, F, ACCESS
69:            	return (long) f1_as_mant1;
1255C  C028     MOVFF x, x
1255E  F028     NOP
12560  C029     MOVFF 0x29, 0x29
12562  F029     NOP
12564  C02A     MOVFF 0x2A, 0x2A
12566  F02A     NOP
12568  C02B     MOVFF 0x2B, 0x2B
1256A  F02B     NOP
70:            }
1256C  0012     RETURN 0
71:            #endif
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/doprnt.c  ------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
1256E  0100     MOVLB 0x0
12570  A166     BTFSS flags, 0, BANKED
12572  EFBD     GOTO 0x1257A
12574  F092     NOP
12576  EFBF     GOTO 0x1257E
12578  F092     NOP
1257A  EFC9     GOTO 0x12592
1257C  F092     NOP
78:                    fputs((const char *)buf, fp);
1257E  C015     MOVFF n, s
12580  F00C     NOP
12582  C016     MOVFF 0x16, 0xD
12584  F00D     NOP
12586  C013     MOVFF a, neg
12588  F00E     NOP
1258A  C014     MOVFF 0x14, b
1258C  F00F     NOP
1258E  EC84     CALL 0x12908, 0
12590  F094     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
12592  BE18     BTFSC 0x18, 7, ACCESS
12594  EFCE     GOTO 0x1259C
12596  F092     NOP
12598  EFD0     GOTO 0x125A0
1259A  F092     NOP
1259C  EFD6     GOTO 0x125AC
1259E  F092     NOP
125A0  C017     MOVFF p, w
125A2  F01C     NOP
125A4  C018     MOVFF 0x18, 0x1D
125A6  F01D     NOP
125A8  EFDA     GOTO 0x125B4
125AA  F092     NOP
125AC  0E00     MOVLW 0x0
125AE  6E1D     MOVWF 0x1D, ACCESS
125B0  0E00     MOVLW 0x0
125B2  6E1C     MOVWF w, ACCESS
83:                i = 0;
125B4  0E00     MOVLW 0x0
125B6  6E1B     MOVWF sign, ACCESS
125B8  0E00     MOVLW 0x0
125BA  6E1A     MOVWF i, ACCESS
84:                while (i < w) {
125BC  EFEC     GOTO 0x125D8
125BE  F092     NOP
125D8  501C     MOVF w, W, ACCESS
125DA  5C1A     SUBWF i, W, ACCESS
125DC  501B     MOVF sign, W, ACCESS
125DE  0A80     XORLW 0x80
125E0  6E19     MOVWF 0x19, ACCESS
125E2  501D     MOVF 0x1D, W, ACCESS
125E4  0A80     XORLW 0x80
125E6  5819     SUBWFB 0x19, W, ACCESS
125E8  A0D8     BTFSS STATUS, 0, ACCESS
125EA  EFF9     GOTO 0x125F2
125EC  F092     NOP
125EE  EFFB     GOTO 0x125F6
125F0  F092     NOP
125F2  EFE0     GOTO 0x125C0
125F4  F092     NOP
85:                    fputc(' ', fp);
125C0  0E00     MOVLW 0x0
125C2  6E04     MOVWF 0x4, ACCESS
125C4  0E20     MOVLW 0x20
125C6  6E03     MOVWF a, ACCESS
125C8  C013     MOVFF a, product
125CA  F005     NOP
125CC  C014     MOVFF 0x14, L
125CE  F006     NOP
125D0  EC1A     CALL 0x12634, 0
125D2  F093     NOP
86:                    ++i;
125D4  4A1A     INFSNZ i, F, ACCESS
125D6  2A1B     INCF sign, F, ACCESS
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
125F6  0100     MOVLB 0x0
125F8  B166     BTFSC flags, 0, BANKED
125FA  EF01     GOTO 0x12602
125FC  F093     NOP
125FE  EF03     GOTO 0x12606
12600  F093     NOP
12602  EF0D     GOTO 0x1261A
12604  F093     NOP
91:                    fputs((const char *)buf, fp);
12606  C015     MOVFF n, s
12608  F00C     NOP
1260A  C016     MOVFF 0x16, 0xD
1260C  F00D     NOP
1260E  C013     MOVFF a, neg
12610  F00E     NOP
12612  C014     MOVFF 0x14, b
12614  F00F     NOP
12616  EC84     CALL 0x12908, 0
12618  F094     NOP
92:                }
93:            
94:                return (int)(strlen(buf) + (size_t)w);
1261A  C015     MOVFF n, __pcstackCOMRAM
1261C  F001     NOP
1261E  C016     MOVFF 0x16, t
12620  F002     NOP
12622  EC7A     CALL 0x12AF4, 0
12624  F095     NOP
12626  501C     MOVF w, W, ACCESS
12628  2401     ADDWF __pcstackCOMRAM, W, ACCESS
1262A  6E13     MOVWF a, ACCESS
1262C  501D     MOVF 0x1D, W, ACCESS
1262E  2002     ADDWFC t, W, ACCESS
12630  6E14     MOVWF 0x14, ACCESS
95:            }
12632  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? (int)'0' + d : (int)'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = (char)d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Left justify ? Put out character */
267:               if (flags & MINUS_FLAG) {
268:                   fputc(c, fp);
269:               }
270:               /* Put out padding */
271:               w = (w < 0) ? 0 : w;
272:               l = 0;
273:               while (l < w) {
274:                   fputc(' ', fp);
275:                   ++l;
276:               }
277:               /* Right justify ? Put out string */
278:               if (!(flags & MINUS_FLAG)) {
279:                   fputc(c, fp);
280:               }
281:           
282:               return l+1;
283:           }
284:           #endif
285:           
286:           #ifdef _VFPF_D
287:           static _INLINE int dtoa(FILE *fp, long long d)
288:           {
289:               int i, p, s, w;
290:               long long n;
291:           
292:               /* Record sign, get absolute value */
293:               n = d;
112A8  C020     MOVFF d, n
112AA  F038     NOP
112AC  C021     MOVFF bexp, n
112AE  F039     NOP
112B0  C022     MOVFF prod, 0x3A
112B2  F03A     NOP
112B4  C023     MOVFF 0x23, 0x3B
112B6  F03B     NOP
112B8  C024     MOVFF 0x24, 0x3C
112BA  F03C     NOP
112BC  C025     MOVFF 0x25, 0x3D
112BE  F03D     NOP
112C0  C026     MOVFF temp, 0x3E
112C2  F03E     NOP
112C4  C027     MOVFF 0x27, 0x3F
112C6  F03F     NOP
294:               s = n < 0 ? 1 : 0;
112C8  BE3F     BTFSC 0x3F, 7, ACCESS
112CA  EF69     GOTO 0x112D2
112CC  F089     NOP
112CE  EF6C     GOTO 0x112D8
112D0  F089     NOP
112D2  0E01     MOVLW 0x1
112D4  EF6D     GOTO 0x112DA
112D6  F089     NOP
112D8  0E00     MOVLW 0x0
112DA  6E36     MOVWF s, ACCESS
112DC  6A37     CLRF w, ACCESS
295:               if (s) {
112DE  5036     MOVF s, W, ACCESS
112E0  1037     IORWF w, W, ACCESS
112E2  B4D8     BTFSC STATUS, 2, ACCESS
112E4  EF76     GOTO 0x112EC
112E6  F089     NOP
112E8  EF78     GOTO 0x112F0
112EA  F089     NOP
112EC  EF88     GOTO 0x11310
112EE  F089     NOP
296:                   n = -n;
112F0  1E3F     COMF 0x3F, F, ACCESS
112F2  1E3E     COMF 0x3E, F, ACCESS
112F4  1E3D     COMF 0x3D, F, ACCESS
112F6  1E3C     COMF 0x3C, F, ACCESS
112F8  1E3B     COMF 0x3B, F, ACCESS
112FA  1E3A     COMF 0x3A, F, ACCESS
112FC  1E39     COMF n, F, ACCESS
112FE  6C38     NEGF n, ACCESS
11300  0E00     MOVLW 0x0
11302  2239     ADDWFC n, F, ACCESS
11304  223A     ADDWFC 0x3A, F, ACCESS
11306  223B     ADDWFC 0x3B, F, ACCESS
11308  223C     ADDWFC 0x3C, F, ACCESS
1130A  223D     ADDWFC 0x3D, F, ACCESS
1130C  223E     ADDWFC 0x3E, F, ACCESS
1130E  223F     ADDWFC 0x3F, F, ACCESS
297:               }
298:           
299:               /* Adjust flags, precision, width */
300:               if (!(prec < 0)) {
11310  0100     MOVLB 0x0
11312  BF65     BTFSC 0x65, 7, BANKED
11314  EF8E     GOTO 0x1131C
11316  F089     NOP
11318  EF90     GOTO 0x11320
1131A  F089     NOP
1131C  EF91     GOTO 0x11322
1131E  F089     NOP
301:                   flags &= ~ZERO_FLAG;
11320  9366     BCF flags, 1, BANKED
302:               }
303:               p = (0 < prec) ? prec : 1;
11322  BF65     BTFSC 0x65, 7, BANKED
11324  EF9E     GOTO 0x1133C
11326  F089     NOP
11328  5165     MOVF 0x65, W, BANKED
1132A  E106     BNZ 0x1338
1132C  0564     DECF prec, W, BANKED
1132E  B0D8     BTFSC STATUS, 0, ACCESS
11330  EF9C     GOTO 0x11338
11332  F089     NOP
11334  EF9E     GOTO 0x1133C
11336  F089     NOP
11338  EFA4     GOTO 0x11348
1133A  F089     NOP
1133C  0E00     MOVLW 0x0
1133E  6E33     MOVWF 0x33, ACCESS
11340  0E01     MOVLW 0x1
11342  6E32     MOVWF p, ACCESS
11344  EFA8     GOTO 0x11350
11346  F089     NOP
11348  C064     MOVFF prec, p
1134A  F032     NOP
1134C  C065     MOVFF 0x65, 0x33
1134E  F033     NOP
304:               w = width;
11350  C062     MOVFF width, w
11352  F034     NOP
11354  C063     MOVFF 0x63, p
11356  F035     NOP
305:               if (s || (flags & PLUS_FLAG)) {
11358  5036     MOVF s, W, ACCESS
1135A  1037     IORWF w, W, ACCESS
1135C  A4D8     BTFSS STATUS, 2, ACCESS
1135E  EFB3     GOTO 0x11366
11360  F089     NOP
11362  EFB5     GOTO 0x1136A
11364  F089     NOP
11366  EFBC     GOTO 0x11378
11368  F089     NOP
1136A  A566     BTFSS flags, 2, BANKED
1136C  EFBA     GOTO 0x11374
1136E  F089     NOP
11370  EFBC     GOTO 0x11378
11372  F089     NOP
11374  EFBF     GOTO 0x1137E
11376  F089     NOP
306:                   --w;
11378  0634     DECF w, F, ACCESS
1137A  A0D8     BTFSS STATUS, 0, ACCESS
1137C  0635     DECF p, F, ACCESS
307:               }
308:           
309:               /* Convert to decimal, possibly filling on the left with zeroes */
310:               i = sizeof(dbuf) - 1;
1137E  0E00     MOVLW 0x0
11380  6E41     MOVWF i, ACCESS
11382  0E1F     MOVLW 0x1F
11384  6E40     MOVWF i, ACCESS
311:               dbuf[i] = '\0';
11386  0E00     MOVLW 0x0
11388  6F87     MOVWF 0x87, BANKED
312:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1138A  EF43     GOTO 0x11486
1138C  F08A     NOP
11486  BE41     BTFSC i, 7, ACCESS
11488  EF4E     GOTO 0x1149C
1148A  F08A     NOP
1148C  5041     MOVF i, W, ACCESS
1148E  E108     BNZ 0x14A0
11490  0440     DECF i, W, ACCESS
11492  A0D8     BTFSS STATUS, 0, ACCESS
11494  EF4E     GOTO 0x1149C
11496  F08A     NOP
11498  EF50     GOTO 0x114A0
1149A  F08A     NOP
1149C  EF81     GOTO 0x11502
1149E  F08A     NOP
114A0  5038     MOVF n, W, ACCESS
114A2  1039     IORWF n, W, ACCESS
114A4  103A     IORWF 0x3A, W, ACCESS
114A6  103B     IORWF 0x3B, W, ACCESS
114A8  103C     IORWF 0x3C, W, ACCESS
114AA  103D     IORWF 0x3D, W, ACCESS
114AC  103E     IORWF 0x3E, W, ACCESS
114AE  103F     IORWF 0x3F, W, ACCESS
114B0  A4D8     BTFSS STATUS, 2, ACCESS
114B2  EF5D     GOTO 0x114BA
114B4  F08A     NOP
114B6  EF5F     GOTO 0x114BE
114B8  F08A     NOP
114BA  EFC7     GOTO 0x1138E
114BC  F089     NOP
114BE  BE33     BTFSC 0x33, 7, ACCESS
114C0  EF6C     GOTO 0x114D8
114C2  F08A     NOP
114C4  5033     MOVF 0x33, W, ACCESS
114C6  E106     BNZ 0x14D4
114C8  0432     DECF p, W, ACCESS
114CA  B0D8     BTFSC STATUS, 0, ACCESS
114CC  EF6A     GOTO 0x114D4
114CE  F08A     NOP
114D0  EF6C     GOTO 0x114D8
114D2  F08A     NOP
114D4  EFC7     GOTO 0x1138E
114D6  F089     NOP
114D8  BE35     BTFSC p, 7, ACCESS
114DA  EF77     GOTO 0x114EE
114DC  F08A     NOP
114DE  5035     MOVF p, W, ACCESS
114E0  E108     BNZ 0x14F2
114E2  0434     DECF w, W, ACCESS
114E4  A0D8     BTFSS STATUS, 0, ACCESS
114E6  EF77     GOTO 0x114EE
114E8  F08A     NOP
114EA  EF79     GOTO 0x114F2
114EC  F08A     NOP
114EE  EF81     GOTO 0x11502
114F0  F08A     NOP
114F2  0100     MOVLB 0x0
114F4  B366     BTFSC flags, 1, BANKED
114F6  EF7F     GOTO 0x114FE
114F8  F08A     NOP
114FA  EF81     GOTO 0x11502
114FC  F08A     NOP
114FE  EFC7     GOTO 0x1138E
11500  F089     NOP
313:                   --i;
1138E  0640     DECF i, F, ACCESS
11390  A0D8     BTFSS STATUS, 0, ACCESS
11392  0641     DECF i, F, ACCESS
314:                   dbuf[i] = (char)((int)'0' + abs(n % 10));
11394  0E68     MOVLW 0x68
11396  2440     ADDWF i, W, ACCESS
11398  6ED9     MOVWF FSR2, ACCESS
1139A  0E00     MOVLW 0x0
1139C  2041     ADDWFC i, W, ACCESS
1139E  6EDA     MOVWF FSR2H, ACCESS
113A0  C038     MOVFF n, __pcstackCOMRAM
113A2  F001     NOP
113A4  C039     MOVFF n, t
113A6  F002     NOP
113A8  C03A     MOVFF 0x3A, a
113AA  F003     NOP
113AC  C03B     MOVFF 0x3B, 0x4
113AE  F004     NOP
113B0  C03C     MOVFF 0x3C, product
113B2  F005     NOP
113B4  C03D     MOVFF 0x3D, L
113B6  F006     NOP
113B8  C03E     MOVFF 0x3E, c
113BA  F007     NOP
113BC  C03F     MOVFF 0x3F, s
113BE  F008     NOP
113C0  0E0A     MOVLW 0xA
113C2  6E09     MOVWF divisor, ACCESS
113C4  0E00     MOVLW 0x0
113C6  6E0A     MOVWF exp, ACCESS
113C8  0E00     MOVLW 0x0
113CA  6E0B     MOVWF arg, ACCESS
113CC  0E00     MOVLW 0x0
113CE  6E0C     MOVWF s, ACCESS
113D0  0E00     MOVLW 0x0
113D2  6E0D     MOVWF 0xD, ACCESS
113D4  0E00     MOVLW 0x0
113D6  6E0E     MOVWF neg, ACCESS
113D8  0E00     MOVLW 0x0
113DA  6E0F     MOVWF b, ACCESS
113DC  0E00     MOVLW 0x0
113DE  6E10     MOVWF c, ACCESS
113E0  EC82     CALL 0x12304, 0
113E2  F091     NOP
113E4  C001     MOVFF __pcstackCOMRAM, x
113E6  F028     NOP
113E8  C002     MOVFF t, 0x29
113EA  F029     NOP
113EC  C003     MOVFF a, 0x2A
113EE  F02A     NOP
113F0  C004     MOVFF 0x4, 0x2B
113F2  F02B     NOP
113F4  C005     MOVFF product, 0x2C
113F6  F02C     NOP
113F8  C006     MOVFF L, 0x2D
113FA  F02D     NOP
113FC  C007     MOVFF c, 0x2E
113FE  F02E     NOP
11400  C008     MOVFF s, 0x2F
11402  F02F     NOP
11404  C028     MOVFF x, a
11406  F013     NOP
11408  C02A     MOVFF 0x2A, 0x14
1140A  F014     NOP
1140C  ECE8     CALL 0x129D0, 0
1140E  F094     NOP
11410  5013     MOVF a, W, ACCESS
11412  0F30     ADDLW 0x30
11414  6EDF     MOVWF INDF2, ACCESS
315:                   --p;
11416  0632     DECF p, F, ACCESS
11418  A0D8     BTFSS STATUS, 0, ACCESS
1141A  0633     DECF 0x33, F, ACCESS
316:                   --w;
1141C  0634     DECF w, F, ACCESS
1141E  A0D8     BTFSS STATUS, 0, ACCESS
11420  0635     DECF p, F, ACCESS
317:                   n = n / 10;
11422  C038     MOVFF n, __pcstackCOMRAM
11424  F001     NOP
11426  C039     MOVFF n, t
11428  F002     NOP
1142A  C03A     MOVFF 0x3A, a
1142C  F003     NOP
1142E  C03B     MOVFF 0x3B, 0x4
11430  F004     NOP
11432  C03C     MOVFF 0x3C, product
11434  F005     NOP
11436  C03D     MOVFF 0x3D, L
11438  F006     NOP
1143A  C03E     MOVFF 0x3E, c
1143C  F007     NOP
1143E  C03F     MOVFF 0x3F, s
11440  F008     NOP
11442  0E0A     MOVLW 0xA
11444  6E09     MOVWF divisor, ACCESS
11446  0E00     MOVLW 0x0
11448  6E0A     MOVWF exp, ACCESS
1144A  0E00     MOVLW 0x0
1144C  6E0B     MOVWF arg, ACCESS
1144E  0E00     MOVLW 0x0
11450  6E0C     MOVWF s, ACCESS
11452  0E00     MOVLW 0x0
11454  6E0D     MOVWF 0xD, ACCESS
11456  0E00     MOVLW 0x0
11458  6E0E     MOVWF neg, ACCESS
1145A  0E00     MOVLW 0x0
1145C  6E0F     MOVWF b, ACCESS
1145E  0E00     MOVLW 0x0
11460  6E10     MOVWF c, ACCESS
11462  ECBE     CALL 0x1217C, 0
11464  F090     NOP
11466  C001     MOVFF __pcstackCOMRAM, n
11468  F038     NOP
1146A  C002     MOVFF t, n
1146C  F039     NOP
1146E  C003     MOVFF a, 0x3A
11470  F03A     NOP
11472  C004     MOVFF 0x4, 0x3B
11474  F03B     NOP
11476  C005     MOVFF product, 0x3C
11478  F03C     NOP
1147A  C006     MOVFF L, 0x3D
1147C  F03D     NOP
1147E  C007     MOVFF c, 0x3E
11480  F03E     NOP
11482  C008     MOVFF s, 0x3F
11484  F03F     NOP
318:               }
319:           
320:               /* Display sign if required */
321:               if (s || (flags & PLUS_FLAG)) {
11502  5036     MOVF s, W, ACCESS
11504  1037     IORWF w, W, ACCESS
11506  A4D8     BTFSS STATUS, 2, ACCESS
11508  EF88     GOTO 0x11510
1150A  F08A     NOP
1150C  EF8A     GOTO 0x11514
1150E  F08A     NOP
11510  EF92     GOTO 0x11524
11512  F08A     NOP
11514  0100     MOVLB 0x0
11516  A566     BTFSS flags, 2, BANKED
11518  EF90     GOTO 0x11520
1151A  F08A     NOP
1151C  EF92     GOTO 0x11524
1151E  F08A     NOP
11520  EFB0     GOTO 0x11560
11522  F08A     NOP
322:                   --i;
11524  0640     DECF i, F, ACCESS
11526  A0D8     BTFSS STATUS, 0, ACCESS
11528  0641     DECF i, F, ACCESS
323:                   dbuf[i] = s ? '-' : '+';
1152A  5036     MOVF s, W, ACCESS
1152C  1037     IORWF w, W, ACCESS
1152E  A4D8     BTFSS STATUS, 2, ACCESS
11530  EF9C     GOTO 0x11538
11532  F08A     NOP
11534  EF9E     GOTO 0x1153C
11536  F08A     NOP
11538  EFA4     GOTO 0x11548
1153A  F08A     NOP
1153C  0E00     MOVLW 0x0
1153E  6E31     MOVWF exp1, ACCESS
11540  0E2B     MOVLW 0x2B
11542  6E30     MOVWF sign1, ACCESS
11544  EFA8     GOTO 0x11550
11546  F08A     NOP
11548  0E00     MOVLW 0x0
1154A  6E31     MOVWF exp1, ACCESS
1154C  0E2D     MOVLW 0x2D
1154E  6E30     MOVWF sign1, ACCESS
11550  0E68     MOVLW 0x68
11552  2440     ADDWF i, W, ACCESS
11554  6ED9     MOVWF FSR2, ACCESS
11556  0E00     MOVLW 0x0
11558  2041     ADDWFC i, W, ACCESS
1155A  6EDA     MOVWF FSR2H, ACCESS
1155C  C030     MOVFF sign1, INDF2
1155E  FFDF     NOP
324:               }
325:           
326:               /* Put out padded string */
327:               return pad(fp, &dbuf[i], w);
11560  C01E     MOVFF fp, a
11562  F013     NOP
11564  C01F     MOVFF 0x1F, 0x14
11566  F014     NOP
11568  0E68     MOVLW 0x68
1156A  2440     ADDWF i, W, ACCESS
1156C  6E15     MOVWF n, ACCESS
1156E  0E00     MOVLW 0x0
11570  2041     ADDWFC i, W, ACCESS
11572  6E16     MOVWF 0x16, ACCESS
11574  C034     MOVFF w, p
11576  F017     NOP
11578  C035     MOVFF p, 0x18
1157A  F018     NOP
1157C  ECB7     CALL 0x1256E, 0
1157E  F092     NOP
11580  C013     MOVFF a, fp
11582  F01E     NOP
11584  C014     MOVFF 0x14, 0x1F
11586  F01F     NOP
328:           }
11588  0012     RETURN 0
329:           #endif
330:           
331:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
332:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
333:           {
334:               char mode, nmode;
335:               int d, e, i, m, n, ne, p, pp, sign, t, w;
336:               long double g, h, l, ou, u;
337:           
338:               /* Record sign, get absolute value */
339:               sign = 0;
340:               g = f;
341:               if (g < 0.0) {
342:                   sign = 1;
343:                   g = -g;
344:               }
345:           
346:               /* Print sign */
347:               n = 0;
348:               w = width;
349:               if (sign || (flags & PLUS_FLAG)) {
350:                   dbuf[n] = sign ? '-' : '+';
351:                   ++n;
352:                   --w;
353:               }
354:           
355:               /* Catch infinities, NaNs here */
356:               if (isinf(g)) {
357:                   if (isupper((int)c)) {
358:                       strcpy(&dbuf[n], "INF");
359:                   } else {
360:                       strcpy(&dbuf[n], "inf");
361:                   }
362:                   w -= CSTRLEN("inf");
363:                   return pad(fp, &dbuf[0], w);
364:               }
365:               if (isnan(g)) {
366:                   if (isupper((int)c)) {
367:                       strcpy(&dbuf[n], "NAN");
368:                   } else {
369:                       strcpy(&dbuf[n], "nan");
370:                   }
371:                   w -= CSTRLEN("inf");
372:                   return pad(fp, &dbuf[0], w);
373:               }
374:           
375:               /* First find the largest power of 10 not larger than number to print */
376:               u = 1.0;
377:               e = 0;
378:               if (!(g == 0.0)) {
379:                   while (!(g < (u*10.0))) {
380:                       u = u*10.0;
381:                       ++e;
382:                   }
383:                   while (g < u) {
384:                       u = u/10.0;
385:                       --e;
386:                   }
387:               }
388:           
389:               /* Get mode, precision */
390:               mode = (char)tolower((int)c);
391:               nmode = mode;
392:               if (mode == 'g') {
393:           		if (prec == 0) {
394:           			prec = 1;
395:           		}
396:                   p = (0 < prec) ? prec : 6;
397:               } else {
398:                   p = (prec < 0) ? 6 : prec;
399:               }
400:           
401:               /* Choose e or f mode from g mode */
402:               if (mode == 'g') {
403:                   if (!(e < -4) && !((p - 1) < e)) {
404:                       nmode = 'f';
405:                   } else {
406:                       nmode = 'e';
407:                   }
408:               }
409:           
410:               /* Decimal places or significant digits */
411:               m = p;
412:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
413:                   ++m;
414:               }
415:           
416:               /* Adjust starting exponent, string length for 'f' conversions */
417:               if (nmode == 'f') {
418:                   if (e < 0) {
419:                       u = 1.0;
420:                       e = 0;
421:                   }
422:                   if (!(mode == 'g')) {
423:                       m += e;
424:                   }
425:               }
426:           
427:               /* Go through the conversion once to get to the rounding step */
428:               i = 0;
429:               h = g;
430:               ou = u;
431:               while (i < m) {
432:                   l = floor(h/u);
433:                   d = (int)l;
434:                   h -= l*u;
435:                   u = u/10.0;
436:                   ++i;
437:               }
438:               
439:               /* Remainder >= halfway ? */
440:               l = u*5.0;
441:               if (h < l) {
442:                   l = 0.0;
443:               } else {
444:                   /* On tie choose even number */
445:                   if ((h == l) && !(d % 2)) {
446:                       l = 0.0;
447:                   }
448:               }
449:           
450:               /* Round */
451:               h = g + l;
452:               /* Has rounding increased the power above 10^0? */
453:           	if (h >= (ou*10.0)) {
454:           		e++;
455:           		ou *= 10.0;
456:           		if (nmode == 'f') {
457:           			// the increase in power will only affect the number of digits in 'f' mode
458:           			m++;
459:           		}
460:           	}
461:               
462:               /* Convert again, after rounding */
463:               u = ou;
464:               ne = (nmode == 'e') ? 0 : e;
465:               pp = 0;
466:               t = 0;
467:               i = 0;
468:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
469:                   l = floor(h/u);
470:                   d = (int)l;
471:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
472:                       ++t;
473:                   } else {
474:                       if (!pp && (ne < 0)) {
475:                           dbuf[n++] = '.';
476:                           --w;
477:                           pp = 1;
478:                       }
479:                       while (t) {
480:                           dbuf[n++] = '0';
481:                           --w;
482:                           --t;
483:                       }
484:                       dbuf[n++] = (char)((int)'0' + d);
485:                       --w;
486:                   }
487:                   h -= l*u;
488:                   u = u/10.0;
489:                   --ne;
490:                   ++i;
491:               }
492:               if (!pp && (flags & POUND_FLAG)) {
493:                   dbuf[n++] = '.';
494:               }
495:               dbuf[n] = '\0';
496:           
497:               /* Convert exponent */
498:               if (nmode == 'e') {
499:                   i = sizeof(dbuf) - 1;
500:                   dbuf[i] = '\0';
501:                   sign = 0;
502:                   if (e < 0) {
503:                       sign = 1;
504:                       e = -e;
505:                   }
506:                   p = 2;
507:                   while (e || (0 < p)) {
508:                       --i;
509:                       dbuf[i] = '0' + (e % 10);
510:                       e = e / 10;
511:                       --p;
512:                       --w;
513:                   }
514:                   --i;
515:                   dbuf[i] = sign ? '-' : '+';
516:                   --w;
517:                   --i;
518:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
519:                   --w;
520:                   strcpy(&dbuf[n], &dbuf[i]);
521:               }
522:           
523:               /* Put out padded string */
524:               return pad(fp, &dbuf[0], w);
525:           }
526:           #endif
527:           
528:           #ifdef _VFPF_O
529:           static _INLINE int otoa(FILE *fp, unsigned long long d)
530:           {
531:               int i, p, t, w;
532:               unsigned long long n;
533:           
534:               /* Adjust flags, precision, width */
535:               if (!(prec < 0)) {
536:                   flags &= ~ZERO_FLAG;
537:               }
538:               p = (0 < prec) ? prec : 1;
539:               w = width;
540:           
541:               /* Convert to octal, possibly filling on the left with zeroes */
542:               n = d;
543:               i = sizeof(dbuf) - 1;
544:               dbuf[i] = '\0';
545:               t = 0;
546:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
547:                   --i;
548:                   t = n & 07;
549:                   dbuf[i] = (char)((int)'0' + t);
550:                   --p;
551:                   --w;
552:                   n = n >> 3;
553:               }
554:           
555:               /* Display prefix if required */
556:               if ((flags & POUND_FLAG) && t) {
557:                   --i;
558:                   dbuf[i] = '0';
559:                   --w;
560:               }
561:           
562:               /* Put out padded string */
563:               return pad(fp, &dbuf[i], w);
564:           }
565:           #endif
566:           
567:           #ifdef _VFPF_S
568:           static _INLINE int stoa(FILE *fp, char *s)
569:           {
570:               char *cp, nuls[] = "(null)";
571:               int i, l, p, w;
572:           
573:               /* Check for null string */
574:               cp = s;
575:               if (!cp) {
576:                   cp = nuls;
577:               }
578:           
579:               /* Get length, precision, width */
580:               l = (int)strlen(cp);
581:               p = prec;
582:               l = (!(p < 0) && (p < l)) ? p : l;
583:               p = l;
584:               w = width;
585:           
586:               /* Right justify, pad on left ? */
587:               if (!(flags & MINUS_FLAG)) {
588:                   while (l < w) {
589:                       fputc(' ', fp);
590:                       ++l;
591:                   }
592:               }
593:           
594:               /* Put out string */
595:               i = 0;
596:               while (i < p) {
597:                   fputc(*cp, fp);
598:                   ++cp;
599:                   ++i;
600:               }
601:           
602:               /* Left justify, pad on right ? */
603:               if (flags & MINUS_FLAG) {
604:                   while (l < w) {
605:                       fputc(' ', fp);
606:                       ++l;
607:                   }
608:               }
609:           
610:               return l;
611:           }
612:           #endif
613:           
614:           #ifdef _VFPF_U
615:           static _INLINE int utoa(FILE *fp, unsigned long long d)
616:           {
617:               int i, p, w;
618:               unsigned long long n;
619:           
620:               /* Adjust flags, precision, width */
621:               if (!(prec < 0)) {
622:                   flags &= ~ZERO_FLAG;
623:               }
624:               p = (0 < prec) ? prec : 1;
625:               w = width;
626:           
627:               /* Convert to decimal, possibly filling on the left with zeroes */
628:               n = d;
629:               i = sizeof(dbuf) - 1;
630:               dbuf[i] = '\0';
631:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
632:                   --i;
633:                   dbuf[i] = '0' + (n % 10);
634:                   --p;
635:                   --w;
636:                   n = n / 10;
637:               }
638:           
639:               /* Put out padded string */
640:               return pad(fp, &dbuf[i], w);
641:           }
642:           #endif
643:           
644:           #if defined(_VFPF_X) || defined(_VFPF_P)
645:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
646:           {
647:               int c, i, p, w;
648:               unsigned long long n;
649:           
650:               /* Adjust, flags, precision, width */
651:               if (!(prec < 0)) {
1158A  0100     MOVLB 0x0
1158C  BF65     BTFSC 0x65, 7, BANKED
1158E  EFCB     GOTO 0x11596
11590  F08A     NOP
11592  EFCD     GOTO 0x1159A
11594  F08A     NOP
11596  EFCE     GOTO 0x1159C
11598  F08A     NOP
652:                   flags &= ~ZERO_FLAG;
1159A  9366     BCF flags, 1, BANKED
653:               }
654:               p = (0 < prec) ? prec : 1;
1159C  BF65     BTFSC 0x65, 7, BANKED
1159E  EFDB     GOTO 0x115B6
115A0  F08A     NOP
115A2  5165     MOVF 0x65, W, BANKED
115A4  E106     BNZ 0x15B2
115A6  0564     DECF prec, W, BANKED
115A8  B0D8     BTFSC STATUS, 0, ACCESS
115AA  EFD9     GOTO 0x115B2
115AC  F08A     NOP
115AE  EFDB     GOTO 0x115B6
115B0  F08A     NOP
115B2  EFE1     GOTO 0x115C2
115B4  F08A     NOP
115B6  0E00     MOVLW 0x0
115B8  6E36     MOVWF s, ACCESS
115BA  0E01     MOVLW 0x1
115BC  6E35     MOVWF p, ACCESS
115BE  EFE5     GOTO 0x115CA
115C0  F08A     NOP
115C2  C064     MOVFF prec, p
115C4  F035     NOP
115C6  C065     MOVFF 0x65, s
115C8  F036     NOP
655:               w = width;
115CA  C062     MOVFF width, w
115CC  F037     NOP
115CE  C063     MOVFF 0x63, n
115D0  F038     NOP
656:               if (flags & POUND_FLAG) {
115D2  A966     BTFSS flags, 4, BANKED
115D4  EFEE     GOTO 0x115DC
115D6  F08A     NOP
115D8  EFF0     GOTO 0x115E0
115DA  F08A     NOP
115DC  EFF4     GOTO 0x115E8
115DE  F08A     NOP
657:                   w -= 2;
115E0  0EFE     MOVLW 0xFE
115E2  2637     ADDWF w, F, ACCESS
115E4  0EFF     MOVLW 0xFF
115E6  2238     ADDWFC n, F, ACCESS
658:               }
659:           
660:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
661:               n = d;
115E8  C020     MOVFF d, n
115EA  F039     NOP
115EC  C021     MOVFF bexp, 0x3A
115EE  F03A     NOP
115F0  C022     MOVFF prod, 0x3B
115F2  F03B     NOP
115F4  C023     MOVFF 0x23, 0x3C
115F6  F03C     NOP
115F8  C024     MOVFF 0x24, 0x3D
115FA  F03D     NOP
115FC  C025     MOVFF 0x25, 0x3E
115FE  F03E     NOP
11600  C026     MOVFF temp, 0x3F
11602  F03F     NOP
11604  C027     MOVFF 0x27, i
11606  F040     NOP
662:               i = sizeof(dbuf) - 1;
11608  0E00     MOVLW 0x0
1160A  6E42     MOVWF 0x42, ACCESS
1160C  0E1F     MOVLW 0x1F
1160E  6E41     MOVWF i, ACCESS
663:               dbuf[i] = '\0';
11610  0E00     MOVLW 0x0
11612  6F87     MOVWF 0x87, BANKED
664:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
11614  EFBF     GOTO 0x1177E
11616  F08B     NOP
1177E  BE42     BTFSC 0x42, 7, ACCESS
11780  EFCB     GOTO 0x11796
11782  F08B     NOP
11784  5042     MOVF 0x42, W, ACCESS
11786  E109     BNZ 0x179A
11788  0E02     MOVLW 0x2
1178A  5C41     SUBWF i, W, ACCESS
1178C  A0D8     BTFSS STATUS, 0, ACCESS
1178E  EFCB     GOTO 0x11796
11790  F08B     NOP
11792  EFCD     GOTO 0x1179A
11794  F08B     NOP
11796  EFFE     GOTO 0x117FC
11798  F08B     NOP
1179A  5039     MOVF n, W, ACCESS
1179C  103A     IORWF 0x3A, W, ACCESS
1179E  103B     IORWF 0x3B, W, ACCESS
117A0  103C     IORWF 0x3C, W, ACCESS
117A2  103D     IORWF 0x3D, W, ACCESS
117A4  103E     IORWF 0x3E, W, ACCESS
117A6  103F     IORWF 0x3F, W, ACCESS
117A8  1040     IORWF i, W, ACCESS
117AA  A4D8     BTFSS STATUS, 2, ACCESS
117AC  EFDA     GOTO 0x117B4
117AE  F08B     NOP
117B0  EFDC     GOTO 0x117B8
117B2  F08B     NOP
117B4  EF0C     GOTO 0x11618
117B6  F08B     NOP
117B8  BE36     BTFSC s, 7, ACCESS
117BA  EFE9     GOTO 0x117D2
117BC  F08B     NOP
117BE  5036     MOVF s, W, ACCESS
117C0  E106     BNZ 0x17CE
117C2  0435     DECF p, W, ACCESS
117C4  B0D8     BTFSC STATUS, 0, ACCESS
117C6  EFE7     GOTO 0x117CE
117C8  F08B     NOP
117CA  EFE9     GOTO 0x117D2
117CC  F08B     NOP
117CE  EF0C     GOTO 0x11618
117D0  F08B     NOP
117D2  BE38     BTFSC n, 7, ACCESS
117D4  EFF4     GOTO 0x117E8
117D6  F08B     NOP
117D8  5038     MOVF n, W, ACCESS
117DA  E108     BNZ 0x17EC
117DC  0437     DECF w, W, ACCESS
117DE  A0D8     BTFSS STATUS, 0, ACCESS
117E0  EFF4     GOTO 0x117E8
117E2  F08B     NOP
117E4  EFF6     GOTO 0x117EC
117E6  F08B     NOP
117E8  EFFE     GOTO 0x117FC
117EA  F08B     NOP
117EC  0100     MOVLB 0x0
117EE  B366     BTFSC flags, 1, BANKED
117F0  EFFC     GOTO 0x117F8
117F2  F08B     NOP
117F4  EFFE     GOTO 0x117FC
117F6  F08B     NOP
117F8  EF0C     GOTO 0x11618
117FA  F08B     NOP
665:                   --i;
11618  0641     DECF i, F, ACCESS
1161A  A0D8     BTFSS STATUS, 0, ACCESS
1161C  0642     DECF 0x42, F, ACCESS
666:                   c = n & 0x0f;
1161E  0E0F     MOVLW 0xF
11620  1439     ANDWF n, W, ACCESS
11622  6E43     MOVWF c, ACCESS
11624  6A44     CLRF 0x44, ACCESS
667:                   c = (c < 10) ? (int)'0' + c : (int)'a' + (c - 10);
11626  BE44     BTFSC 0x44, 7, ACCESS
11628  EF1F     GOTO 0x1163E
1162A  F08B     NOP
1162C  5044     MOVF 0x44, W, ACCESS
1162E  E109     BNZ 0x1642
11630  0E0A     MOVLW 0xA
11632  5C43     SUBWF c, W, ACCESS
11634  A0D8     BTFSS STATUS, 0, ACCESS
11636  EF1F     GOTO 0x1163E
11638  F08B     NOP
1163A  EF21     GOTO 0x11642
1163C  F08B     NOP
1163E  EF29     GOTO 0x11652
11640  F08B     NOP
11642  0E57     MOVLW 0x57
11644  2443     ADDWF c, W, ACCESS
11646  6E43     MOVWF c, ACCESS
11648  0E00     MOVLW 0x0
1164A  2044     ADDWFC 0x44, W, ACCESS
1164C  6E44     MOVWF 0x44, ACCESS
1164E  EF2F     GOTO 0x1165E
11650  F08B     NOP
11652  0E30     MOVLW 0x30
11654  2443     ADDWF c, W, ACCESS
11656  6E43     MOVWF c, ACCESS
11658  0E00     MOVLW 0x0
1165A  2044     ADDWFC 0x44, W, ACCESS
1165C  6E44     MOVWF 0x44, ACCESS
668:                   if (isupper((int)x) && isalpha(c)) {
1165E  0EBF     MOVLW 0xBF
11660  6E29     MOVWF 0x29, ACCESS
11662  0EFF     MOVLW 0xFF
11664  6E2A     MOVWF 0x2A, ACCESS
11666  5028     MOVF x, W, ACCESS
11668  6E2B     MOVWF 0x2B, ACCESS
1166A  6A2C     CLRF 0x2C, ACCESS
1166C  5029     MOVF 0x29, W, ACCESS
1166E  262B     ADDWF 0x2B, F, ACCESS
11670  502A     MOVF 0x2A, W, ACCESS
11672  222C     ADDWFC 0x2C, F, ACCESS
11674  502C     MOVF 0x2C, W, ACCESS
11676  E10A     BNZ 0x168C
11678  0E1A     MOVLW 0x1A
1167A  5C2B     SUBWF 0x2B, W, ACCESS
1167C  A0D8     BTFSS STATUS, 0, ACCESS
1167E  EF43     GOTO 0x11686
11680  F08B     NOP
11682  EF46     GOTO 0x1168C
11684  F08B     NOP
11686  0E01     MOVLW 0x1
11688  EF47     GOTO 0x1168E
1168A  F08B     NOP
1168C  0E00     MOVLW 0x0
1168E  6E31     MOVWF exp1, ACCESS
11690  6A32     CLRF p, ACCESS
11692  5031     MOVF exp1, W, ACCESS
11694  1032     IORWF p, W, ACCESS
11696  B4D8     BTFSC STATUS, 2, ACCESS
11698  EF50     GOTO 0x116A0
1169A  F08B     NOP
1169C  EF52     GOTO 0x116A4
1169E  F08B     NOP
116A0  EF82     GOTO 0x11704
116A2  F08B     NOP
116A4  0E9F     MOVLW 0x9F
116A6  6E29     MOVWF 0x29, ACCESS
116A8  0EFF     MOVLW 0xFF
116AA  6E2A     MOVWF 0x2A, ACCESS
116AC  0E20     MOVLW 0x20
116AE  1043     IORWF c, W, ACCESS
116B0  6E2B     MOVWF 0x2B, ACCESS
116B2  0E00     MOVLW 0x0
116B4  1044     IORWF 0x44, W, ACCESS
116B6  6E2C     MOVWF 0x2C, ACCESS
116B8  5029     MOVF 0x29, W, ACCESS
116BA  262B     ADDWF 0x2B, F, ACCESS
116BC  502A     MOVF 0x2A, W, ACCESS
116BE  222C     ADDWFC 0x2C, F, ACCESS
116C0  502C     MOVF 0x2C, W, ACCESS
116C2  E10A     BNZ 0x16D8
116C4  0E1A     MOVLW 0x1A
116C6  5C2B     SUBWF 0x2B, W, ACCESS
116C8  A0D8     BTFSS STATUS, 0, ACCESS
116CA  EF69     GOTO 0x116D2
116CC  F08B     NOP
116CE  EF6C     GOTO 0x116D8
116D0  F08B     NOP
116D2  0E01     MOVLW 0x1
116D4  EF6D     GOTO 0x116DA
116D6  F08B     NOP
116D8  0E00     MOVLW 0x0
116DA  6E33     MOVWF 0x33, ACCESS
116DC  6A34     CLRF w, ACCESS
116DE  5033     MOVF 0x33, W, ACCESS
116E0  1034     IORWF w, W, ACCESS
116E2  B4D8     BTFSC STATUS, 2, ACCESS
116E4  EF76     GOTO 0x116EC
116E6  F08B     NOP
116E8  EF78     GOTO 0x116F0
116EA  F08B     NOP
116EC  EF82     GOTO 0x11704
116EE  F08B     NOP
669:                       c = toupper(c);
116F0  C043     MOVFF c, c
116F2  F007     NOP
116F4  C044     MOVFF 0x44, s
116F6  F008     NOP
116F8  ECDA     CALL 0x127B4, 0
116FA  F093     NOP
116FC  C007     MOVFF c, c
116FE  F043     NOP
11700  C008     MOVFF s, 0x44
11702  F044     NOP
670:                   }
671:                   dbuf[i] = (char)c;
11704  0E68     MOVLW 0x68
11706  2441     ADDWF i, W, ACCESS
11708  6ED9     MOVWF FSR2, ACCESS
1170A  0E00     MOVLW 0x0
1170C  2042     ADDWFC 0x42, W, ACCESS
1170E  6EDA     MOVWF FSR2H, ACCESS
11710  C043     MOVFF c, INDF2
11712  FFDF     NOP
672:                   --p;
11714  0635     DECF p, F, ACCESS
11716  A0D8     BTFSS STATUS, 0, ACCESS
11718  0636     DECF s, F, ACCESS
673:                   --w;
1171A  0637     DECF w, F, ACCESS
1171C  A0D8     BTFSS STATUS, 0, ACCESS
1171E  0638     DECF n, F, ACCESS
674:                   n = n >> 4;
11720  C039     MOVFF n, 0x29
11722  F029     NOP
11724  C03A     MOVFF 0x3A, 0x2A
11726  F02A     NOP
11728  C03B     MOVFF 0x3B, 0x2B
1172A  F02B     NOP
1172C  C03C     MOVFF 0x3C, 0x2C
1172E  F02C     NOP
11730  C03D     MOVFF 0x3D, 0x2D
11732  F02D     NOP
11734  C03E     MOVFF 0x3E, 0x2E
11736  F02E     NOP
11738  C03F     MOVFF 0x3F, 0x2F
1173A  F02F     NOP
1173C  C040     MOVFF i, sign1
1173E  F030     NOP
11740  0E05     MOVLW 0x5
11742  EFAC     GOTO 0x11758
11744  F08B     NOP
11746  90D8     BCF STATUS, 0, ACCESS
11748  3230     RRCF sign1, F, ACCESS
1174A  322F     RRCF 0x2F, F, ACCESS
1174C  322E     RRCF 0x2E, F, ACCESS
1174E  322D     RRCF 0x2D, F, ACCESS
11750  322C     RRCF 0x2C, F, ACCESS
11752  322B     RRCF 0x2B, F, ACCESS
11754  322A     RRCF 0x2A, F, ACCESS
11756  3229     RRCF 0x29, F, ACCESS
11758  2EE8     DECFSZ WREG, F, ACCESS
1175A  EFA3     GOTO 0x11746
1175C  F08B     NOP
1175E  C029     MOVFF 0x29, n
11760  F039     NOP
11762  C02A     MOVFF 0x2A, 0x3A
11764  F03A     NOP
11766  C02B     MOVFF 0x2B, 0x3B
11768  F03B     NOP
1176A  C02C     MOVFF 0x2C, 0x3C
1176C  F03C     NOP
1176E  C02D     MOVFF 0x2D, 0x3D
11770  F03D     NOP
11772  C02E     MOVFF 0x2E, 0x3E
11774  F03E     NOP
11776  C02F     MOVFF 0x2F, 0x3F
11778  F03F     NOP
1177A  C030     MOVFF sign1, i
1177C  F040     NOP
675:               }
676:           
677:               /* Display prefix if required */
678:               if (flags & POUND_FLAG) {
117FC  0100     MOVLB 0x0
117FE  A966     BTFSS flags, 4, BANKED
11800  EF04     GOTO 0x11808
11802  F08C     NOP
11804  EF06     GOTO 0x1180C
11806  F08C     NOP
11808  EF1C     GOTO 0x11838
1180A  F08C     NOP
679:                   --i;
1180C  0641     DECF i, F, ACCESS
1180E  A0D8     BTFSS STATUS, 0, ACCESS
11810  0642     DECF 0x42, F, ACCESS
680:                   dbuf[i] = x;
11812  0E68     MOVLW 0x68
11814  2441     ADDWF i, W, ACCESS
11816  6ED9     MOVWF FSR2, ACCESS
11818  0E00     MOVLW 0x0
1181A  2042     ADDWFC 0x42, W, ACCESS
1181C  6EDA     MOVWF FSR2H, ACCESS
1181E  C028     MOVFF x, INDF2
11820  FFDF     NOP
681:                   --i;
11822  0641     DECF i, F, ACCESS
11824  A0D8     BTFSS STATUS, 0, ACCESS
11826  0642     DECF 0x42, F, ACCESS
682:                   dbuf[i] = '0';
11828  0E68     MOVLW 0x68
1182A  2441     ADDWF i, W, ACCESS
1182C  6ED9     MOVWF FSR2, ACCESS
1182E  0E00     MOVLW 0x0
11830  2042     ADDWFC 0x42, W, ACCESS
11832  6EDA     MOVWF FSR2H, ACCESS
11834  0E30     MOVLW 0x30
11836  6EDF     MOVWF INDF2, ACCESS
683:               }
684:           
685:               /* Put out padded string */
686:               return pad(fp, &dbuf[i], w);
11838  C01E     MOVFF fp, a
1183A  F013     NOP
1183C  C01F     MOVFF 0x1F, 0x14
1183E  F014     NOP
11840  0E68     MOVLW 0x68
11842  2441     ADDWF i, W, ACCESS
11844  6E15     MOVWF n, ACCESS
11846  0E00     MOVLW 0x0
11848  2042     ADDWFC 0x42, W, ACCESS
1184A  6E16     MOVWF 0x16, ACCESS
1184C  C037     MOVFF w, p
1184E  F017     NOP
11850  C038     MOVFF n, 0x18
11852  F018     NOP
11854  ECB7     CALL 0x1256E, 0
11856  F092     NOP
11858  C013     MOVFF a, fp
1185A  F01E     NOP
1185C  C014     MOVFF 0x14, 0x1F
1185E  F01F     NOP
687:           }
11860  0012     RETURN 0
688:           #endif
689:           
690:           /* Consume and convert the next part of the format string */
691:           #ifdef _VFPF_CONVERT
692:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
693:           {
694:               char c, *cp, ct[3];
695:               int done, i;
696:               long long ll;
697:               unsigned long long llu;
698:               long double f;
699:               void *vp;
700:           
701:               /* Conversion ? */
702:               if ((*fmt)[0] == '%') {
10A02  C047     MOVFF fmt, FSR2
10A04  FFD9     NOP
10A06  C048     MOVFF 0x48, FSR2H
10A08  FFDA     NOP
10A0A  CFDE     MOVFF POSTINC2, TBLPTR
10A0C  FFF6     NOP
10A0E  CFDD     MOVFF POSTDEC2, TBLPTRH
10A10  FFF7     NOP
10A12  0E00     MOVLW 0x0
10A14  6EF8     MOVWF TBLPTRU, ACCESS
10A16  0008     TBLRD*
10A18  50F5     MOVF TABLAT, W, ACCESS
10A1A  0A25     XORLW 0x25
10A1C  A4D8     BTFSS STATUS, 2, ACCESS
10A1E  EF13     GOTO 0x10A26
10A20  F085     NOP
10A22  EF15     GOTO 0x10A2A
10A24  F085     NOP
10A26  EF21     GOTO 0x10E42
10A28  F087     NOP
703:                   ++*fmt;
10A2A  C047     MOVFF fmt, FSR2
10A2C  FFD9     NOP
10A2E  C048     MOVFF 0x48, FSR2H
10A30  FFDA     NOP
10A32  2ADE     INCF POSTINC2, F, ACCESS
10A34  0E00     MOVLW 0x0
10A36  22DD     ADDWFC POSTDEC2, F, ACCESS
704:           
705:                   flags = width = 0;
10A38  0E00     MOVLW 0x0
10A3A  0100     MOVLB 0x0
10A3C  6F63     MOVWF 0x63, BANKED
10A3E  0E00     MOVLW 0x0
10A40  6F62     MOVWF width, BANKED
10A42  C062     MOVFF width, flags
10A44  F066     NOP
10A46  C063     MOVFF 0x63, 0x67
10A48  F067     NOP
706:                   prec = -1;
10A4A  6964     SETF prec, BANKED
10A4C  6965     SETF 0x65, BANKED
707:           
708:           #ifdef _VFPF_FLAGS
709:                   /* Get flags */
710:                   done = 0;
10A4E  0E00     MOVLW 0x0
10A50  6F99     MOVWF 0x99, BANKED
10A52  0E00     MOVLW 0x0
10A54  6F98     MOVWF done, BANKED
711:                   while (!done) {
10A56  EF75     GOTO 0x10AEA
10A58  F085     NOP
10AEA  5198     MOVF done, W, BANKED
10AEC  1199     IORWF 0x99, W, BANKED
10AEE  B4D8     BTFSC STATUS, 2, ACCESS
10AF0  EF7C     GOTO 0x10AF8
10AF2  F085     NOP
10AF4  EF7E     GOTO 0x10AFC
10AF6  F085     NOP
10AF8  EF49     GOTO 0x10A92
10AFA  F085     NOP
712:                       switch ((*fmt)[0]) {
713:                           case '-' :
714:                               flags |= MINUS_FLAG;
10A5A  8166     BSF flags, 0, BANKED
715:                               ++*fmt;
10A5C  C047     MOVFF fmt, FSR2
10A5E  FFD9     NOP
10A60  C048     MOVFF 0x48, FSR2H
10A62  FFDA     NOP
10A64  2ADE     INCF POSTINC2, F, ACCESS
10A66  0E00     MOVLW 0x0
10A68  22DD     ADDWFC POSTDEC2, F, ACCESS
716:                               break;
10A6A  EF75     GOTO 0x10AEA
10A6C  F085     NOP
717:                           case '0' :
718:                               flags |= ZERO_FLAG;
10A6E  8366     BSF flags, 1, BANKED
10A70  EF2E     GOTO 0x10A5C
10A72  F085     NOP
719:                               ++*fmt;
720:                               break;
721:                           case '+' :
722:                               flags |= PLUS_FLAG;
10A74  8566     BSF flags, 2, BANKED
10A76  EF2E     GOTO 0x10A5C
10A78  F085     NOP
723:                               ++*fmt;
724:                               break;
725:                           case ' ' :
726:                               flags |= SPACE_FLAG;
10A7A  8766     BSF flags, 3, BANKED
10A7C  EF2E     GOTO 0x10A5C
10A7E  F085     NOP
727:                               ++*fmt;
728:                               break;
729:                           case '#' :
730:                               flags |= POUND_FLAG;
10A80  8966     BSF flags, 4, BANKED
10A82  EF2E     GOTO 0x10A5C
10A84  F085     NOP
731:                               ++*fmt;
732:                               break;
733:                           default:
734:                               done = 1;
10A86  0E00     MOVLW 0x0
10A88  6F99     MOVWF 0x99, BANKED
10A8A  0E01     MOVLW 0x1
10A8C  6F98     MOVWF done, BANKED
735:                               break;
10A8E  EF75     GOTO 0x10AEA
10A90  F085     NOP
736:                       }
10A92  C047     MOVFF fmt, FSR2
10A94  FFD9     NOP
10A96  C048     MOVFF 0x48, FSR2H
10A98  FFDA     NOP
10A9A  CFDE     MOVFF POSTINC2, TBLPTR
10A9C  FFF6     NOP
10A9E  CFDD     MOVFF POSTDEC2, TBLPTRH
10AA0  FFF7     NOP
10AA2  0E00     MOVLW 0x0
10AA4  6EF8     MOVWF TBLPTRU, ACCESS
10AA6  0008     TBLRD*
10AA8  50F5     MOVF TABLAT, W, ACCESS
10AAA  6E4B     MOVWF 0x4B, ACCESS
10AAC  6A4C     CLRF 0x4C, ACCESS
10AAE  504C     MOVF 0x4C, W, ACCESS
10AB0  0A00     XORLW 0x0
10AB2  B4D8     BTFSC STATUS, 2, ACCESS
10AB4  EF5E     GOTO 0x10ABC
10AB6  F085     NOP
10AB8  EF43     GOTO 0x10A86
10ABA  F085     NOP
10ABC  504B     MOVF 0x4B, W, ACCESS
10ABE  0A20     XORLW 0x20
10AC0  B4D8     BTFSC STATUS, 2, ACCESS
10AC2  EF3D     GOTO 0x10A7A
10AC4  F085     NOP
10AC6  0A03     XORLW 0x3
10AC8  B4D8     BTFSC STATUS, 2, ACCESS
10ACA  EF40     GOTO 0x10A80
10ACC  F085     NOP
10ACE  0A08     XORLW 0x8
10AD0  B4D8     BTFSC STATUS, 2, ACCESS
10AD2  EF3A     GOTO 0x10A74
10AD4  F085     NOP
10AD6  0A06     XORLW 0x6
10AD8  B4D8     BTFSC STATUS, 2, ACCESS
10ADA  EF2D     GOTO 0x10A5A
10ADC  F085     NOP
10ADE  0A1D     XORLW 0x1D
10AE0  B4D8     BTFSC STATUS, 2, ACCESS
10AE2  EF37     GOTO 0x10A6E
10AE4  F085     NOP
10AE6  EF43     GOTO 0x10A86
10AE8  F085     NOP
737:                   }
738:                   if (flags & MINUS_FLAG) {
10AFC  A166     BTFSS flags, 0, BANKED
10AFE  EF83     GOTO 0x10B06
10B00  F085     NOP
10B02  EF85     GOTO 0x10B0A
10B04  F085     NOP
10B06  EF86     GOTO 0x10B0C
10B08  F085     NOP
739:                       flags &= ~ZERO_FLAG;
10B0A  9366     BCF flags, 1, BANKED
740:                   }
741:           #endif
742:           
743:           #ifdef _VFPF_WIDTH
744:                   /* Get field width */
745:                   if ((*fmt)[0] == '*') {
10B0C  C047     MOVFF fmt, FSR2
10B0E  FFD9     NOP
10B10  C048     MOVFF 0x48, FSR2H
10B12  FFDA     NOP
10B14  CFDE     MOVFF POSTINC2, TBLPTR
10B16  FFF6     NOP
10B18  CFDD     MOVFF POSTDEC2, TBLPTRH
10B1A  FFF7     NOP
10B1C  0E00     MOVLW 0x0
10B1E  6EF8     MOVWF TBLPTRU, ACCESS
10B20  0008     TBLRD*
10B22  50F5     MOVF TABLAT, W, ACCESS
10B24  0A2A     XORLW 0x2A
10B26  A4D8     BTFSS STATUS, 2, ACCESS
10B28  EF98     GOTO 0x10B30
10B2A  F085     NOP
10B2C  EF9A     GOTO 0x10B34
10B2E  F085     NOP
10B30  EFC3     GOTO 0x10B86
10B32  F085     NOP
746:                       ++*fmt;
10B34  C047     MOVFF fmt, FSR2
10B36  FFD9     NOP
10B38  C048     MOVFF 0x48, FSR2H
10B3A  FFDA     NOP
10B3C  2ADE     INCF POSTINC2, F, ACCESS
10B3E  0E00     MOVLW 0x0
10B40  22DD     ADDWFC POSTDEC2, F, ACCESS
747:                       width = va_arg(ap, int);
10B42  C049     MOVFF ap, FSR2
10B44  FFD9     NOP
10B46  C04A     MOVFF 0x4A, FSR2H
10B48  FFDA     NOP
10B4A  CFDF     MOVFF INDF2, 0x4B
10B4C  F04B     NOP
10B4E  0E02     MOVLW 0x2
10B50  26DE     ADDWF POSTINC2, F, ACCESS
10B52  CFDF     MOVFF INDF2, 0x4C
10B54  F04C     NOP
10B56  0E00     MOVLW 0x0
10B58  22DD     ADDWFC POSTDEC2, F, ACCESS
10B5A  C04B     MOVFF 0x4B, FSR2
10B5C  FFD9     NOP
10B5E  C04C     MOVFF 0x4C, FSR2H
10B60  FFDA     NOP
10B62  CFDE     MOVFF POSTINC2, width
10B64  F062     NOP
10B66  CFDD     MOVFF POSTDEC2, 0x63
10B68  F063     NOP
748:                       if (width < 0) {
10B6A  BF63     BTFSC 0x63, 7, BANKED
10B6C  EFBC     GOTO 0x10B78
10B6E  F085     NOP
10B70  EFBA     GOTO 0x10B74
10B72  F085     NOP
10B74  EF09     GOTO 0x10C12
10B76  F086     NOP
749:                           flags |= MINUS_FLAG;
10B78  8166     BSF flags, 0, BANKED
750:                           width = -width;
10B7A  6D62     NEGF width, BANKED
10B7C  1F63     COMF 0x63, F, BANKED
10B7E  B0D8     BTFSC STATUS, 0, ACCESS
10B80  2B63     INCF 0x63, F, BANKED
10B82  EF09     GOTO 0x10C12
10B84  F086     NOP
751:                       }
752:                   } else {
753:                       width = atoi(*fmt);
10B86  C047     MOVFF fmt, FSR2
10B88  FFD9     NOP
10B8A  C048     MOVFF 0x48, FSR2H
10B8C  FFDA     NOP
10B8E  CFDE     MOVFF POSTINC2, s
10B90  F008     NOP
10B92  CFDD     MOVFF POSTDEC2, divisor
10B94  F009     NOP
10B96  ECEC     CALL 0x11FD8, 0
10B98  F08F     NOP
10B9A  C008     MOVFF s, width
10B9C  F062     NOP
10B9E  C009     MOVFF divisor, 0x63
10BA0  F063     NOP
754:                       while (isdigit((*fmt)[0])) {
10BA2  EFDA     GOTO 0x10BB4
10BA4  F085     NOP
10BB4  0ED0     MOVLW 0xD0
10BB6  6E4B     MOVWF 0x4B, ACCESS
10BB8  0EFF     MOVLW 0xFF
10BBA  6E4C     MOVWF 0x4C, ACCESS
10BBC  C047     MOVFF fmt, FSR2
10BBE  FFD9     NOP
10BC0  C048     MOVFF 0x48, FSR2H
10BC2  FFDA     NOP
10BC4  CFDE     MOVFF POSTINC2, TBLPTR
10BC6  FFF6     NOP
10BC8  CFDD     MOVFF POSTDEC2, TBLPTRH
10BCA  FFF7     NOP
10BCC  0E00     MOVLW 0x0
10BCE  6EF8     MOVWF TBLPTRU, ACCESS
10BD0  0008     TBLRD*
10BD2  50F5     MOVF TABLAT, W, ACCESS
10BD4  6E4D     MOVWF 0x4D, ACCESS
10BD6  6A4E     CLRF 0x4E, ACCESS
10BD8  504B     MOVF 0x4B, W, ACCESS
10BDA  264D     ADDWF 0x4D, F, ACCESS
10BDC  504C     MOVF 0x4C, W, ACCESS
10BDE  224E     ADDWFC 0x4E, F, ACCESS
10BE0  504E     MOVF 0x4E, W, ACCESS
10BE2  E10A     BNZ 0xBF8
10BE4  0E0A     MOVLW 0xA
10BE6  5C4D     SUBWF 0x4D, W, ACCESS
10BE8  A0D8     BTFSS STATUS, 0, ACCESS
10BEA  EFF9     GOTO 0x10BF2
10BEC  F085     NOP
10BEE  EFFC     GOTO 0x10BF8
10BF0  F085     NOP
10BF2  0E01     MOVLW 0x1
10BF4  EFFD     GOTO 0x10BFA
10BF6  F085     NOP
10BF8  0E00     MOVLW 0x0
10BFA  0100     MOVLB 0x0
10BFC  6F9A     MOVWF 0x9A, BANKED
10BFE  6B9B     CLRF 0x9B, BANKED
10C00  519A     MOVF 0x9A, W, BANKED
10C02  119B     IORWF 0x9B, W, BANKED
10C04  A4D8     BTFSS STATUS, 2, ACCESS
10C06  EF07     GOTO 0x10C0E
10C08  F086     NOP
10C0A  EF09     GOTO 0x10C12
10C0C  F086     NOP
10C0E  EFD3     GOTO 0x10BA6
10C10  F085     NOP
755:                           ++*fmt;
10BA6  C047     MOVFF fmt, FSR2
10BA8  FFD9     NOP
10BAA  C048     MOVFF 0x48, FSR2H
10BAC  FFDA     NOP
10BAE  2ADE     INCF POSTINC2, F, ACCESS
10BB0  0E00     MOVLW 0x0
10BB2  22DD     ADDWFC POSTDEC2, F, ACCESS
756:                       }
757:                   }
758:           #endif
759:           
760:           #ifdef _VFPF_PRECISION
761:                   /* Get precision */
762:                   if ((*fmt)[0] == '.') {
763:                       prec = 0;
764:                       ++*fmt;
765:                       if ((*fmt)[0] == '*') {
766:                           ++*fmt;
767:                           prec = va_arg(ap, int);
768:                       } else {
769:                           prec = atoi(*fmt);
770:                           while (isdigit((*fmt)[0])) {
771:                               ++*fmt;
772:                           }
773:                       }
774:                   }
775:           #endif
776:           
777:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
778:                   /* Case-folded conversion types */
779:                   ct[0] = (char)tolower((int)(*fmt)[0]);
780:                   if (ct[0]) {
781:                       ct[1] = (char)tolower((int)(*fmt)[1]);
782:                       if (ct[1]) {
783:                           ct[2] = (char)tolower((int)(*fmt)[2]);
784:                       }
785:                   }
786:           #endif
787:           
788:           #ifdef _VFPF_A
789:                   /* 'a' style (hex) floating point */
790:                   if (ct[0] == 'a') {
791:           
792:                       c = (*fmt)[0];
793:                       ++*fmt;
794:                       f = (long double)va_arg(ap, double);
795:                                   
796:                       return atoa(fp, f, c);
797:                   }
798:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
799:           
800:                       c = (*fmt)[1];
801:                       if (isupper((int)(*fmt)[0])) {
802:                           f = va_arg(ap, long double);
803:                       } else {
804:                           f = (long double)va_arg(ap, double);
805:                       }
806:                       *fmt += CSTRLEN("la");
807:                                   
808:                       return atoa(fp, f, c);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_C
813:                   /* Character */
814:                   if (*fmt[0] == 'c') {
815:                       ++*fmt;
816:                       c = (unsigned char)va_arg(ap, int);
817:                       return ctoa(fp, c);
818:                   }
819:           #endif
820:           
821:           #ifdef _VFPF_D
822:           #ifdef _VFPF_HH
823:                   /* Character decimal integer */
824:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
825:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
826:           
827:                       *fmt += CSTRLEN("hhd");
828:                       ll = (long long)(signed char)va_arg(ap, int);
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           #endif
833:           
834:           #ifdef _VFPF_H
835:                   /* Short decimal integer */
836:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
837:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
838:           
839:                       *fmt += CSTRLEN("hd");
840:                       ll = (long long)(short)va_arg(ap, int);
841:                                   
842:                       return dtoa(fp, ll);
843:                   }
844:           #endif
845:           
846:                   /* Decimal integer */
847:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
10C12  C047     MOVFF fmt, FSR2
10C14  FFD9     NOP
10C16  C048     MOVFF 0x48, FSR2H
10C18  FFDA     NOP
10C1A  CFDE     MOVFF POSTINC2, TBLPTR
10C1C  FFF6     NOP
10C1E  CFDD     MOVFF POSTDEC2, TBLPTRH
10C20  FFF7     NOP
10C22  0E00     MOVLW 0x0
10C24  6EF8     MOVWF TBLPTRU, ACCESS
10C26  0008     TBLRD*
10C28  50F5     MOVF TABLAT, W, ACCESS
10C2A  0A64     XORLW 0x64
10C2C  B4D8     BTFSC STATUS, 2, ACCESS
10C2E  EF1B     GOTO 0x10C36
10C30  F086     NOP
10C32  EF1D     GOTO 0x10C3A
10C34  F086     NOP
10C36  EF31     GOTO 0x10C62
10C38  F086     NOP
10C3A  C047     MOVFF fmt, FSR2
10C3C  FFD9     NOP
10C3E  C048     MOVFF 0x48, FSR2H
10C40  FFDA     NOP
10C42  CFDE     MOVFF POSTINC2, TBLPTR
10C44  FFF6     NOP
10C46  CFDD     MOVFF POSTDEC2, TBLPTRH
10C48  FFF7     NOP
10C4A  0E00     MOVLW 0x0
10C4C  6EF8     MOVWF TBLPTRU, ACCESS
10C4E  0008     TBLRD*
10C50  50F5     MOVF TABLAT, W, ACCESS
10C52  0A69     XORLW 0x69
10C54  A4D8     BTFSS STATUS, 2, ACCESS
10C56  EF2F     GOTO 0x10C5E
10C58  F086     NOP
10C5A  EF31     GOTO 0x10C62
10C5C  F086     NOP
10C5E  EF71     GOTO 0x10CE2
10C60  F086     NOP
848:           
849:                       ++*fmt;
10C62  C047     MOVFF fmt, FSR2
10C64  FFD9     NOP
10C66  C048     MOVFF 0x48, FSR2H
10C68  FFDA     NOP
10C6A  2ADE     INCF POSTINC2, F, ACCESS
10C6C  0E00     MOVLW 0x0
10C6E  22DD     ADDWFC POSTDEC2, F, ACCESS
850:                       ll = (long long)va_arg(ap, int);
10C70  C049     MOVFF ap, FSR2
10C72  FFD9     NOP
10C74  C04A     MOVFF 0x4A, FSR2H
10C76  FFDA     NOP
10C78  CFDF     MOVFF INDF2, 0x4B
10C7A  F04B     NOP
10C7C  0E02     MOVLW 0x2
10C7E  26DE     ADDWF POSTINC2, F, ACCESS
10C80  CFDF     MOVFF INDF2, 0x4C
10C82  F04C     NOP
10C84  0E00     MOVLW 0x0
10C86  22DD     ADDWFC POSTDEC2, F, ACCESS
10C88  C04B     MOVFF 0x4B, FSR2
10C8A  FFD9     NOP
10C8C  C04C     MOVFF 0x4C, FSR2H
10C8E  FFDA     NOP
10C90  CFDE     MOVFF POSTINC2, __pcstackBANK0
10C92  F088     NOP
10C94  CFDD     MOVFF POSTDEC2, 0x89
10C96  F089     NOP
10C98  0E00     MOVLW 0x0
10C9A  BF89     BTFSC 0x89, 7, BANKED
10C9C  0EFF     MOVLW 0xFF
10C9E  6F8A     MOVWF 0x8A, BANKED
10CA0  6F8B     MOVWF 0x8B, BANKED
10CA2  6F8C     MOVWF 0x8C, BANKED
10CA4  6F8D     MOVWF 0x8D, BANKED
10CA6  6F8E     MOVWF 0x8E, BANKED
10CA8  6F8F     MOVWF 0x8F, BANKED
851:                                   
852:                       return dtoa(fp, ll);
10CAA  C045     MOVFF fp, fp
10CAC  F01E     NOP
10CAE  C046     MOVFF 0x46, 0x1F
10CB0  F01F     NOP
10CB2  C088     MOVFF __pcstackBANK0, d
10CB4  F020     NOP
10CB6  C089     MOVFF 0x89, bexp
10CB8  F021     NOP
10CBA  C08A     MOVFF 0x8A, prod
10CBC  F022     NOP
10CBE  C08B     MOVFF 0x8B, 0x23
10CC0  F023     NOP
10CC2  C08C     MOVFF 0x8C, 0x24
10CC4  F024     NOP
10CC6  C08D     MOVFF 0x8D, 0x25
10CC8  F025     NOP
10CCA  C08E     MOVFF 0x8E, temp
10CCC  F026     NOP
10CCE  C08F     MOVFF 0x8F, 0x27
10CD0  F027     NOP
10CD2  EC54     CALL 0x112A8, 0
10CD4  F089     NOP
10CD6  C01E     MOVFF fp, fp
10CD8  F045     NOP
10CDA  C01F     MOVFF 0x1F, 0x46
10CDC  F046     NOP
10CDE  EF3E     GOTO 0x10E7C
10CE0  F087     NOP
853:                   }
854:           
855:           #ifdef _VFPF_L
856:                   /* Long decimal integer */
857:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
858:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
859:           
860:                       *fmt += CSTRLEN("ld");
861:                       ll = (long long)va_arg(ap, long);
862:                                   
863:                       return dtoa(fp, ll);
864:                   }
865:           #endif
866:           
867:           #ifdef _VFPF_LL
868:                   /* Long long decimal integer */
869:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
870:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
871:           
872:                       *fmt += CSTRLEN("lld");
873:                       ll = va_arg(ap, long long);
874:                                   
875:                       return dtoa(fp, ll);
876:                   }
877:           #endif
878:           
879:           #ifdef _VFPF_J
880:                   /* intmax_t decimal integer */
881:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
882:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
883:           
884:                       *fmt += CSTRLEN("jd");
885:                       ll = (long long)va_arg(ap, intmax_t);
886:                                   
887:                       return dtoa(fp, ll);
888:                   }
889:           #endif
890:           
891:           #ifdef _VFPF_T
892:                   /* ptrdiff_t decimal integer */
893:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
894:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
895:           
896:                       *fmt += CSTRLEN("td");
897:                       ll = (long long)va_arg(ap, ptrdiff_t);
898:                                   
899:                       return dtoa(fp, ll);
900:                   }
901:           #endif
902:           
903:           #ifdef _VFPF_Z
904:                   /* size_t decimal integer */
905:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
906:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
907:           
908:                       *fmt += CSTRLEN("zd");
909:                       ll = (long long)va_arg(ap, size_t);
910:                                   
911:                       return dtoa(fp, ll);
912:                   }
913:           #endif
914:           #endif
915:           
916:           #ifdef _VFPF_E
917:                   /* 'e' style floating point */
918:                   if (ct[0] == 'e') {
919:           
920:                       c = (*fmt)[0];
921:                       ++*fmt;
922:                       f = (long double)va_arg(ap, double);
923:                                   
924:                       return efgtoa(fp, f, c);
925:                   }
926:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
927:           
928:                       c = (*fmt)[1];
929:                       if (isupper((int)(*fmt)[0])) {
930:                           f = va_arg(ap, long double);
931:                       } else {
932:                           f = (long double)va_arg(ap, double);
933:                       }
934:                       *fmt += CSTRLEN("lf");
935:                                   
936:                       return efgtoa(fp, f, c);
937:                   }
938:           #endif
939:           
940:           #ifdef _VFPF_F
941:                   /* 'f' style floating point */
942:                   if (ct[0] == 'f') {
943:           
944:                       c = (*fmt)[0];
945:                       ++*fmt;
946:                       f = (long double)va_arg(ap, double);
947:                                   
948:                       return efgtoa(fp, f, c);
949:                   }
950:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
951:           
952:                       c = (*fmt)[1];
953:                       if (isupper((int)(*fmt)[0])) {
954:                           f = va_arg(ap, long double);
955:                       } else {
956:                           f = (long double)va_arg(ap, double);
957:                       }
958:                       *fmt += CSTRLEN("lf");
959:                                   
960:                       return efgtoa(fp, f, c);
961:                   }
962:           #endif
963:           
964:           #ifdef _VFPF_G
965:                   /* 'g' style floating point */
966:                   if (ct[0] == 'g') {
967:           
968:                       c = (*fmt)[0];
969:                       ++*fmt;
970:                       f = (long double)va_arg(ap, double);
971:                                   
972:                       return efgtoa(fp, f, c);
973:                   }
974:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
975:           
976:                       c = (*fmt)[1];
977:                       if (isupper((int)(*fmt)[0])) {
978:                           f = va_arg(ap, long double);
979:                       } else {
980:                           f = (long double)va_arg(ap, double);
981:                       }
982:                       *fmt += CSTRLEN("lg");
983:                                   
984:                       return efgtoa(fp, f, c);
985:                   }
986:           #endif
987:           
988:           #ifdef _VFPF_O
989:           #ifdef _VFPF_HH
990:                   /* Character octal integer */
991:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
992:           
993:                       *fmt += CSTRLEN("hho");
994:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
995:                                   
996:                       return otoa(fp, llu);
997:                   }
998:           #endif
999:           
1000:          #ifdef _VFPF_H
1001:                  /* Short octal integer */
1002:                  if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
1003:          
1004:                      *fmt += CSTRLEN("ho");
1005:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1006:                                  
1007:                      return otoa(fp, llu);
1008:                  }
1009:          #endif
1010:          
1011:                  /* Octal integer */
1012:                  if (*fmt[0] == 'o') {
1013:          
1014:                      ++*fmt;
1015:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1016:                                  
1017:                      return otoa(fp, llu);
1018:                  }
1019:          
1020:          #ifdef _VFPF_L
1021:                  /* Long octal integer */
1022:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1023:          
1024:                      *fmt += CSTRLEN("lo");
1025:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_LL
1032:                  /* Long long octal integer */
1033:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1034:          
1035:                      *fmt += CSTRLEN("llo");
1036:                      llu = va_arg(ap, unsigned long long);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_J
1043:                  /* uintmax_t octal integer */
1044:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1045:          
1046:                      *fmt += CSTRLEN("jo");
1047:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          
1053:          #ifdef _VFPF_T
1054:                  /* ptrdiff_t octal integer */
1055:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1056:          
1057:                      *fmt += CSTRLEN("to");
1058:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1059:                                  
1060:                      return otoa(fp, llu);
1061:                  }
1062:          #endif
1063:          
1064:          #ifdef _VFPF_Z
1065:                  /* size_t octal integer */
1066:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1067:          
1068:                      *fmt += CSTRLEN("zo");
1069:                      llu = (unsigned long long)va_arg(ap, size_t);
1070:                                  
1071:                      return otoa(fp, llu);
1072:                  }
1073:          #endif
1074:          #endif
1075:          
1076:                  /* Character count */
1077:          #ifdef _VFPF_N
1078:          
1079:          #ifdef _VFPF_HH
1080:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1081:          
1082:                      *fmt += CSTRLEN("hhn");
1083:                      vp = (void *)va_arg(ap, char *);
1084:                      *(char *)vp = (char)nout;
1085:                      return 0;
1086:                  }
1087:          #endif
1088:          
1089:          #ifdef _VFPF_H
1090:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1091:          
1092:                      *fmt += CSTRLEN("hn");
1093:                      vp = (void *)va_arg(ap, short *);
1094:                      *(short *)vp = (short)nout;
1095:                      return 0;
1096:                  }
1097:          #endif
1098:          
1099:                  if (*fmt[0] == 'n') {
1100:                      ++*fmt;
1101:                      vp = (void *)va_arg(ap, int *);
1102:                      *(int *)vp = nout;
1103:                      return 0;
1104:                  }
1105:          
1106:          #ifdef _VFPF_L
1107:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1108:          
1109:                      *fmt += CSTRLEN("ln");
1110:                      vp = (void *)va_arg(ap, long *);
1111:                      *(long *)vp = (long)nout;
1112:                      return 0;
1113:                  }
1114:          #endif
1115:          
1116:          #ifdef _VFPF_LL
1117:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1118:          
1119:                      *fmt += CSTRLEN("lln");
1120:                      vp = (void *)va_arg(ap, long long *);
1121:                      *(long long *)vp = (long long)nout;
1122:                      return 0;
1123:                  }
1124:          #endif
1125:          
1126:          #ifdef _VFPF_J
1127:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1128:          
1129:                      *fmt += CSTRLEN("jn");
1130:                      vp = (void *)va_arg(ap, uintmax_t *);
1131:                      *(uintmax_t *)vp = (uintmax_t)nout;
1132:                      return 0;
1133:                  }
1134:          #endif
1135:          
1136:          #ifdef _VFPF_T
1137:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1138:          
1139:                      *fmt += CSTRLEN("tn");
1140:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1141:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1142:                      return 0;
1143:                  }
1144:          #endif
1145:          
1146:          #ifdef _VFPF_Z
1147:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1148:          
1149:                      *fmt += CSTRLEN("zn");
1150:                      vp = (void *)va_arg(ap, size_t *);
1151:                      *(size_t *)vp = (size_t)nout;
1152:                      return 0;
1153:                  }
1154:          #endif
1155:          
1156:          #endif
1157:          
1158:          #ifdef _VFPF_P
1159:                  /* Pointer */
1160:                  if (*fmt[0] == 'p') {
1161:          
1162:                      ++*fmt;
1163:                      llu = (unsigned long long)(uintptr_t)va_arg(ap, void *);
1164:                                  
1165:                      return xtoa(fp, llu, 'x');
1166:                  }
1167:          #endif
1168:          
1169:          #ifdef _VFPF_S
1170:                  /* String */
1171:                  if (*fmt[0] == 's') {
1172:          
1173:                      ++*fmt;
1174:                      cp = va_arg(ap, char *);
1175:          
1176:                      return stoa(fp, cp);
1177:                  }
1178:          #endif
1179:          
1180:          #ifdef _VFPF_U
1181:          #ifdef _VFPF_HH
1182:                  /* Unsigned character decimal integer */
1183:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1184:          
1185:                      *fmt += CSTRLEN("hhu");
1186:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1187:                                  
1188:                      return utoa(fp, llu);
1189:                  }
1190:          #endif
1191:          
1192:          #ifdef _VFPF_H
1193:                  /* Unsigned short decimal integer */
1194:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1195:          
1196:                      *fmt += CSTRLEN("hu");
1197:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1198:                                  
1199:                      return utoa(fp, llu);
1200:                  }
1201:          #endif
1202:          
1203:                  /* Unsigned decimal integer */
1204:                  if (*fmt[0] == 'u') {
1205:          
1206:                      ++*fmt;
1207:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1208:                                  
1209:                      return utoa(fp, llu);
1210:                  }
1211:          
1212:          #ifdef _VFPF_L
1213:                  /* Unsigned long decimal integer */
1214:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1215:          
1216:                      *fmt += CSTRLEN("lu");
1217:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_LL
1224:                  /* Unsigned long long decimal integer */
1225:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1226:          
1227:                      *fmt += CSTRLEN("llu");
1228:                      llu = va_arg(ap, unsigned long long);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_J
1235:                  /* uintmax_t decimal integer */
1236:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1237:          
1238:                      *fmt += CSTRLEN("ju");
1239:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          
1245:          #ifdef _VFPF_T
1246:                  /* ptrdiff_t decimal integer */
1247:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1248:          
1249:                      *fmt += CSTRLEN("tu");
1250:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1251:                                  
1252:                      return utoa(fp, llu);
1253:                  }
1254:          #endif
1255:          
1256:          #ifdef _VFPF_Z
1257:                  /* size_t decimal integer */
1258:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1259:          
1260:                      *fmt += CSTRLEN("zu");
1261:                      llu = (unsigned long long)va_arg(ap, size_t);
1262:                                  
1263:                      return utoa(fp, llu);
1264:                  }
1265:          #endif
1266:          #endif
1267:          
1268:          #ifdef _VFPF_X
1269:          #ifdef _VFPF_HH
1270:                  /* Character hexadecimal integer */
1271:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1272:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1273:          
1274:                      c = (*fmt)[2];
1275:                      *fmt += CSTRLEN("hhx");
1276:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1277:                                  
1278:                      return xtoa(fp, llu, c);
1279:                  }
1280:          #endif
1281:          
1282:          #ifdef _VFPF_H
1283:                  /* Short hexadecimal integer */
1284:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1285:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1286:          
1287:                      c = (*fmt)[1];
1288:                      *fmt += CSTRLEN("hx");
1289:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1290:                                  
1291:                      return xtoa(fp, llu, c);
1292:                  }
1293:          #endif
1294:          
1295:                  /* Hexadecimal integer */
1296:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
10CE2  C047     MOVFF fmt, FSR2
10CE4  FFD9     NOP
10CE6  C048     MOVFF 0x48, FSR2H
10CE8  FFDA     NOP
10CEA  CFDE     MOVFF POSTINC2, TBLPTR
10CEC  FFF6     NOP
10CEE  CFDD     MOVFF POSTDEC2, TBLPTRH
10CF0  FFF7     NOP
10CF2  0E00     MOVLW 0x0
10CF4  6EF8     MOVWF TBLPTRU, ACCESS
10CF6  0008     TBLRD*
10CF8  50F5     MOVF TABLAT, W, ACCESS
10CFA  0A78     XORLW 0x78
10CFC  B4D8     BTFSC STATUS, 2, ACCESS
10CFE  EF83     GOTO 0x10D06
10D00  F086     NOP
10D02  EF85     GOTO 0x10D0A
10D04  F086     NOP
10D06  EF99     GOTO 0x10D32
10D08  F086     NOP
10D0A  C047     MOVFF fmt, FSR2
10D0C  FFD9     NOP
10D0E  C048     MOVFF 0x48, FSR2H
10D10  FFDA     NOP
10D12  CFDE     MOVFF POSTINC2, TBLPTR
10D14  FFF6     NOP
10D16  CFDD     MOVFF POSTDEC2, TBLPTRH
10D18  FFF7     NOP
10D1A  0E00     MOVLW 0x0
10D1C  6EF8     MOVWF TBLPTRU, ACCESS
10D1E  0008     TBLRD*
10D20  50F5     MOVF TABLAT, W, ACCESS
10D22  0A58     XORLW 0x58
10D24  A4D8     BTFSS STATUS, 2, ACCESS
10D26  EF97     GOTO 0x10D2E
10D28  F086     NOP
10D2A  EF99     GOTO 0x10D32
10D2C  F086     NOP
10D2E  EFE9     GOTO 0x10DD2
10D30  F086     NOP
1297:          
1298:                      c = (*fmt)[0];
10D32  C047     MOVFF fmt, FSR2
10D34  FFD9     NOP
10D36  C048     MOVFF 0x48, FSR2H
10D38  FFDA     NOP
10D3A  CFDE     MOVFF POSTINC2, TBLPTR
10D3C  FFF6     NOP
10D3E  CFDD     MOVFF POSTDEC2, TBLPTRH
10D40  FFF7     NOP
10D42  0E00     MOVLW 0x0
10D44  6EF8     MOVWF TBLPTRU, ACCESS
10D46  0008     TBLRD*
10D48  CFF5     MOVFF TABLAT, c
10D4A  F09C     NOP
1299:                      ++*fmt;
10D4C  C047     MOVFF fmt, FSR2
10D4E  FFD9     NOP
10D50  C048     MOVFF 0x48, FSR2H
10D52  FFDA     NOP
10D54  2ADE     INCF POSTINC2, F, ACCESS
10D56  0E00     MOVLW 0x0
10D58  22DD     ADDWFC POSTDEC2, F, ACCESS
1300:                      llu = (unsigned long long)va_arg(ap, unsigned int);
10D5A  C049     MOVFF ap, FSR2
10D5C  FFD9     NOP
10D5E  C04A     MOVFF 0x4A, FSR2H
10D60  FFDA     NOP
10D62  CFDF     MOVFF INDF2, 0x4B
10D64  F04B     NOP
10D66  0E02     MOVLW 0x2
10D68  26DE     ADDWF POSTINC2, F, ACCESS
10D6A  CFDF     MOVFF INDF2, 0x4C
10D6C  F04C     NOP
10D6E  0E00     MOVLW 0x0
10D70  22DD     ADDWFC POSTDEC2, F, ACCESS
10D72  C04B     MOVFF 0x4B, FSR2
10D74  FFD9     NOP
10D76  C04C     MOVFF 0x4C, FSR2H
10D78  FFDA     NOP
10D7A  CFDE     MOVFF POSTINC2, 0x4D
10D7C  F04D     NOP
10D7E  CFDD     MOVFF POSTDEC2, 0x4E
10D80  F04E     NOP
10D82  C04D     MOVFF 0x4D, llu
10D84  F090     NOP
10D86  C04E     MOVFF 0x4E, 0x91
10D88  F091     NOP
10D8A  6B92     CLRF 0x92, BANKED
10D8C  6B93     CLRF 0x93, BANKED
10D8E  6B94     CLRF 0x94, BANKED
10D90  6B95     CLRF 0x95, BANKED
10D92  6B96     CLRF 0x96, BANKED
10D94  6B97     CLRF 0x97, BANKED
1301:                                  
1302:                      return xtoa(fp, llu, c);
10D96  C045     MOVFF fp, fp
10D98  F01E     NOP
10D9A  C046     MOVFF 0x46, 0x1F
10D9C  F01F     NOP
10D9E  C090     MOVFF llu, d
10DA0  F020     NOP
10DA2  C091     MOVFF 0x91, bexp
10DA4  F021     NOP
10DA6  C092     MOVFF 0x92, prod
10DA8  F022     NOP
10DAA  C093     MOVFF 0x93, 0x23
10DAC  F023     NOP
10DAE  C094     MOVFF 0x94, 0x24
10DB0  F024     NOP
10DB2  C095     MOVFF 0x95, 0x25
10DB4  F025     NOP
10DB6  C096     MOVFF 0x96, temp
10DB8  F026     NOP
10DBA  C097     MOVFF 0x97, 0x27
10DBC  F027     NOP
10DBE  C09C     MOVFF c, x
10DC0  F028     NOP
10DC2  ECC5     CALL 0x1158A, 0
10DC4  F08A     NOP
10DC6  C01E     MOVFF fp, fp
10DC8  F045     NOP
10DCA  C01F     MOVFF 0x1F, 0x46
10DCC  F046     NOP
10DCE  EF3E     GOTO 0x10E7C
10DD0  F087     NOP
1303:                  }
1304:          
1305:          #ifdef _VFPF_L
1306:                  /* Long hexadecimal integer */
1307:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1308:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1309:          
1310:                      c = (*fmt)[1];
1311:                      *fmt += CSTRLEN("lx");
1312:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1313:                                  
1314:                      return xtoa(fp, llu, c);
1315:                  }
1316:          #endif
1317:          
1318:          #ifdef _VFPF_LL
1319:                  /* Long long hexadecimal integer */
1320:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1321:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1322:          
1323:                      c = (*fmt)[2];
1324:                      *fmt += CSTRLEN("llx");
1325:                      llu = va_arg(ap, unsigned long long);
1326:                                  
1327:                      return xtoa(fp, llu, c);
1328:                  }
1329:          #endif
1330:          
1331:          #ifdef _VFPF_J
1332:                  /* uintmax_t hexadecimal integer */
1333:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1334:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1335:          
1336:                      c = (*fmt)[1];
1337:                      *fmt += CSTRLEN("jx");
1338:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1339:                                  
1340:                      return xtoa(fp, llu, c);
1341:                  }
1342:          #endif
1343:          
1344:          #ifdef _VFPF_T
1345:                  /* ptrdiff_t hexadecimal integer */
1346:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1347:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1348:          
1349:                      c = (*fmt)[1];
1350:                      *fmt += CSTRLEN("tx");
1351:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1352:                                  
1353:                      return xtoa(fp, llu, c);
1354:                  }
1355:          #endif
1356:          
1357:          #ifdef _VFPF_Z
1358:                  /* size_t hexadecimal integer */
1359:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1360:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1361:          
1362:                      c = (*fmt)[1];
1363:                      *fmt += CSTRLEN("zx");
1364:                      llu = (unsigned long long)va_arg(ap, size_t);
1365:                                  
1366:                      return xtoa(fp, llu, c);
1367:                  }
1368:          #endif
1369:          #endif
1370:          
1371:                  /* 'Escaped' '%' character */
1372:                  if ((*fmt)[0] == '%') {
10DD2  C047     MOVFF fmt, FSR2
10DD4  FFD9     NOP
10DD6  C048     MOVFF 0x48, FSR2H
10DD8  FFDA     NOP
10DDA  CFDE     MOVFF POSTINC2, TBLPTR
10DDC  FFF6     NOP
10DDE  CFDD     MOVFF POSTDEC2, TBLPTRH
10DE0  FFF7     NOP
10DE2  0E00     MOVLW 0x0
10DE4  6EF8     MOVWF TBLPTRU, ACCESS
10DE6  0008     TBLRD*
10DE8  50F5     MOVF TABLAT, W, ACCESS
10DEA  0A25     XORLW 0x25
10DEC  A4D8     BTFSS STATUS, 2, ACCESS
10DEE  EFFB     GOTO 0x10DF6
10DF0  F086     NOP
10DF2  EFFD     GOTO 0x10DFA
10DF4  F086     NOP
10DF6  EF14     GOTO 0x10E28
10DF8  F087     NOP
1373:                      ++*fmt;
10DFA  C047     MOVFF fmt, FSR2
10DFC  FFD9     NOP
10DFE  C048     MOVFF 0x48, FSR2H
10E00  FFDA     NOP
10E02  2ADE     INCF POSTINC2, F, ACCESS
10E04  0E00     MOVLW 0x0
10E06  22DD     ADDWFC POSTDEC2, F, ACCESS
1374:                      fputc((int)'%', fp);
10E08  0E00     MOVLW 0x0
10E0A  6E04     MOVWF 0x4, ACCESS
10E0C  0E25     MOVLW 0x25
10E0E  6E03     MOVWF a, ACCESS
10E10  C045     MOVFF fp, product
10E12  F005     NOP
10E14  C046     MOVFF 0x46, L
10E16  F006     NOP
10E18  EC1A     CALL 0x12634, 0
10E1A  F093     NOP
1375:                      return 1;
10E1C  0E00     MOVLW 0x0
10E1E  6E46     MOVWF 0x46, ACCESS
10E20  0E01     MOVLW 0x1
10E22  6E45     MOVWF fp, ACCESS
10E24  EF3E     GOTO 0x10E7C
10E26  F087     NOP
1376:                  }
1377:          
1378:                  /* Unrecognized conversion */
1379:                  ++*fmt;
10E28  C047     MOVFF fmt, FSR2
10E2A  FFD9     NOP
10E2C  C048     MOVFF 0x48, FSR2H
10E2E  FFDA     NOP
10E30  2ADE     INCF POSTINC2, F, ACCESS
10E32  0E00     MOVLW 0x0
10E34  22DD     ADDWFC POSTDEC2, F, ACCESS
1380:                  return 0;
10E36  0E00     MOVLW 0x0
10E38  6E46     MOVWF 0x46, ACCESS
10E3A  0E00     MOVLW 0x0
10E3C  6E45     MOVWF fp, ACCESS
10E3E  EF3E     GOTO 0x10E7C
10E40  F087     NOP
1381:              }
1382:          
1383:              /* No conversion, just intervening text */
1384:              fputc((int)(*fmt)[0], fp);
10E42  C047     MOVFF fmt, FSR2
10E44  FFD9     NOP
10E46  C048     MOVFF 0x48, FSR2H
10E48  FFDA     NOP
10E4A  CFDE     MOVFF POSTINC2, TBLPTR
10E4C  FFF6     NOP
10E4E  CFDD     MOVFF POSTDEC2, TBLPTRH
10E50  FFF7     NOP
10E52  0E00     MOVLW 0x0
10E54  6EF8     MOVWF TBLPTRU, ACCESS
10E56  0008     TBLRD*
10E58  50F5     MOVF TABLAT, W, ACCESS
10E5A  6E03     MOVWF a, ACCESS
10E5C  6A04     CLRF 0x4, ACCESS
10E5E  C045     MOVFF fp, product
10E60  F005     NOP
10E62  C046     MOVFF 0x46, L
10E64  F006     NOP
10E66  EC1A     CALL 0x12634, 0
10E68  F093     NOP
1385:              ++*fmt;
10E6A  C047     MOVFF fmt, FSR2
10E6C  FFD9     NOP
10E6E  C048     MOVFF 0x48, FSR2H
10E70  FFDA     NOP
10E72  2ADE     INCF POSTINC2, F, ACCESS
10E74  0E00     MOVLW 0x0
10E76  22DD     ADDWFC POSTDEC2, F, ACCESS
10E78  EF0E     GOTO 0x10E1C
10E7A  F087     NOP
1386:              return 1;
1387:          }
10E7C  0012     RETURN 0
1388:          #endif
1389:          
1390:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1391:          {
1392:          #ifdef _VFPF_CONVERT
1393:              char *cfmt;
1394:          
1395:              cfmt = (char *)fmt;
1274E  C051     MOVFF fmt, cfmt
12750  F055     NOP
12752  C052     MOVFF 0x52, 0x56
12754  F056     NOP
1396:              nout = 0;
12756  0E00     MOVLW 0x0
12758  0100     MOVLB 0x0
1275A  6F61     MOVWF 0x61, BANKED
1275C  0E00     MOVLW 0x0
1275E  6F60     MOVWF nout, BANKED
1397:              while (*cfmt) {
12760  EFC5     GOTO 0x1278A
12762  F093     NOP
1278A  C055     MOVFF cfmt, TBLPTR
1278C  FFF6     NOP
1278E  C056     MOVFF 0x56, TBLPTRH
12790  FFF7     NOP
12792  0E00     MOVLW 0x0
12794  6EF8     MOVWF TBLPTRU, ACCESS
12796  0008     TBLRD*
12798  50F5     MOVF TABLAT, W, ACCESS
1279A  0900     IORLW 0x0
1279C  A4D8     BTFSS STATUS, 2, ACCESS
1279E  EFD3     GOTO 0x127A6
127A0  F093     NOP
127A2  EFD5     GOTO 0x127AA
127A4  F093     NOP
127A6  EFB2     GOTO 0x12764
127A8  F093     NOP
1398:                  nout += vfpfcnvrt(fp, &cfmt, ap);
12764  C04F     MOVFF fp, fp
12766  F045     NOP
12768  C050     MOVFF 0x50, 0x46
1276A  F046     NOP
1276C  0E55     MOVLW 0x55
1276E  6E47     MOVWF fmt, ACCESS
12770  0E00     MOVLW 0x0
12772  6E48     MOVWF 0x48, ACCESS
12774  C053     MOVFF ap, ap
12776  F049     NOP
12778  C054     MOVFF 0x54, 0x4A
1277A  F04A     NOP
1277C  EC01     CALL 0x10A02, 0
1277E  F085     NOP
12780  5045     MOVF fp, W, ACCESS
12782  0100     MOVLB 0x0
12784  2760     ADDWF nout, F, BANKED
12786  5046     MOVF 0x46, W, ACCESS
12788  2361     ADDWFC 0x61, F, BANKED
1399:              }
1400:              return nout;
127AA  C060     MOVFF nout, fp
127AC  F04F     NOP
127AE  C061     MOVFF 0x61, 0x50
127B0  F050     NOP
1401:          #else
1402:              return fputs(fmt, fp);
1403:          #endif
1404:          }
127B2  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/atoi.c  --------------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
5:             {
6:             	int n=0, neg=0;
11FD8  0E00     MOVLW 0x0
11FDA  6E16     MOVWF 0x16, ACCESS
11FDC  0E00     MOVLW 0x0
11FDE  6E15     MOVWF n, ACCESS
11FE0  0E00     MOVLW 0x0
11FE2  6E0F     MOVWF b, ACCESS
11FE4  0E00     MOVLW 0x0
11FE6  6E0E     MOVWF neg, ACCESS
7:             	while (isspace(*s)) s++;
11FE8  EFF8     GOTO 0x11FF0
11FEA  F08F     NOP
11FEC  4A08     INFSNZ s, F, ACCESS
11FEE  2A09     INCF divisor, F, ACCESS
11FF0  0E01     MOVLW 0x1
11FF2  6E14     MOVWF 0x14, ACCESS
11FF4  C008     MOVFF s, TBLPTR
11FF6  FFF6     NOP
11FF8  C009     MOVFF divisor, TBLPTRH
11FFA  FFF7     NOP
11FFC  0E00     MOVLW 0x0
11FFE  6EF8     MOVWF TBLPTRU, ACCESS
12000  0008     TBLRD*
12002  50F5     MOVF TABLAT, W, ACCESS
12004  0A20     XORLW 0x20
12006  B4D8     BTFSC STATUS, 2, ACCESS
12008  EF08     GOTO 0x12010
1200A  F090     NOP
1200C  EF0A     GOTO 0x12014
1200E  F090     NOP
12010  EF29     GOTO 0x12052
12012  F090     NOP
12014  0EF7     MOVLW 0xF7
12016  6E0A     MOVWF exp, ACCESS
12018  0EFF     MOVLW 0xFF
1201A  6E0B     MOVWF arg, ACCESS
1201C  C008     MOVFF s, TBLPTR
1201E  FFF6     NOP
12020  C009     MOVFF divisor, TBLPTRH
12022  FFF7     NOP
12024  0E00     MOVLW 0x0
12026  6EF8     MOVWF TBLPTRU, ACCESS
12028  0008     TBLRD*
1202A  50F5     MOVF TABLAT, W, ACCESS
1202C  6E0C     MOVWF s, ACCESS
1202E  6A0D     CLRF 0xD, ACCESS
12030  500A     MOVF exp, W, ACCESS
12032  260C     ADDWF s, F, ACCESS
12034  500B     MOVF arg, W, ACCESS
12036  220D     ADDWFC 0xD, F, ACCESS
12038  500D     MOVF 0xD, W, ACCESS
1203A  E109     BNZ 0x204E
1203C  0E05     MOVLW 0x5
1203E  5C0C     SUBWF s, W, ACCESS
12040  A0D8     BTFSS STATUS, 0, ACCESS
12042  EF25     GOTO 0x1204A
12044  F090     NOP
12046  EF27     GOTO 0x1204E
12048  F090     NOP
1204A  EF29     GOTO 0x12052
1204C  F090     NOP
1204E  0E00     MOVLW 0x0
12050  6E14     MOVWF 0x14, ACCESS
12052  C014     MOVFF 0x14, c
12054  F010     NOP
12056  6A11     CLRF i, ACCESS
12058  5010     MOVF c, W, ACCESS
1205A  1011     IORWF i, W, ACCESS
1205C  A4D8     BTFSS STATUS, 2, ACCESS
1205E  EF33     GOTO 0x12066
12060  F090     NOP
12062  EF35     GOTO 0x1206A
12064  F090     NOP
12066  EFF6     GOTO 0x11FEC
12068  F08F     NOP
1206A  EF3F     GOTO 0x1207E
1206C  F090     NOP
8:             	switch (*s) {
9:             	case '-': neg=1;
1206E  0E00     MOVLW 0x0
12070  6E0F     MOVWF b, ACCESS
12072  0E01     MOVLW 0x1
12074  6E0E     MOVWF neg, ACCESS
10:            	case '+': s++;
12076  4A08     INFSNZ s, F, ACCESS
12078  2A09     INCF divisor, F, ACCESS
11:            	}
1207A  EF78     GOTO 0x120F0
1207C  F090     NOP
1207E  C008     MOVFF s, TBLPTR
12080  FFF6     NOP
12082  C009     MOVFF divisor, TBLPTRH
12084  FFF7     NOP
12086  0E00     MOVLW 0x0
12088  6EF8     MOVWF TBLPTRU, ACCESS
1208A  0008     TBLRD*
1208C  50F5     MOVF TABLAT, W, ACCESS
1208E  6E0A     MOVWF exp, ACCESS
12090  6A0B     CLRF arg, ACCESS
12092  500B     MOVF arg, W, ACCESS
12094  0A00     XORLW 0x0
12096  B4D8     BTFSC STATUS, 2, ACCESS
12098  EF50     GOTO 0x120A0
1209A  F090     NOP
1209C  EF78     GOTO 0x120F0
1209E  F090     NOP
120A0  500A     MOVF exp, W, ACCESS
120A2  0A2B     XORLW 0x2B
120A4  B4D8     BTFSC STATUS, 2, ACCESS
120A6  EF3B     GOTO 0x12076
120A8  F090     NOP
120AA  0A06     XORLW 0x6
120AC  B4D8     BTFSC STATUS, 2, ACCESS
120AE  EF37     GOTO 0x1206E
120B0  F090     NOP
120B2  EF78     GOTO 0x120F0
120B4  F090     NOP
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
120F0  0ED0     MOVLW 0xD0
120F2  6E0A     MOVWF exp, ACCESS
120F4  0EFF     MOVLW 0xFF
120F6  6E0B     MOVWF arg, ACCESS
120F8  C008     MOVFF s, TBLPTR
120FA  FFF6     NOP
120FC  C009     MOVFF divisor, TBLPTRH
120FE  FFF7     NOP
12100  0E00     MOVLW 0x0
12102  6EF8     MOVWF TBLPTRU, ACCESS
12104  0008     TBLRD*
12106  50F5     MOVF TABLAT, W, ACCESS
12108  6E0C     MOVWF s, ACCESS
1210A  6A0D     CLRF 0xD, ACCESS
1210C  500A     MOVF exp, W, ACCESS
1210E  260C     ADDWF s, F, ACCESS
12110  500B     MOVF arg, W, ACCESS
12112  220D     ADDWFC 0xD, F, ACCESS
12114  500D     MOVF 0xD, W, ACCESS
12116  E10A     BNZ 0x212C
12118  0E0A     MOVLW 0xA
1211A  5C0C     SUBWF s, W, ACCESS
1211C  A0D8     BTFSS STATUS, 0, ACCESS
1211E  EF93     GOTO 0x12126
12120  F090     NOP
12122  EF96     GOTO 0x1212C
12124  F090     NOP
12126  0E01     MOVLW 0x1
12128  EF97     GOTO 0x1212E
1212A  F090     NOP
1212C  0E00     MOVLW 0x0
1212E  6E12     MOVWF sign, ACCESS
12130  6A13     CLRF a, ACCESS
12132  5012     MOVF sign, W, ACCESS
12134  1013     IORWF a, W, ACCESS
12136  A4D8     BTFSS STATUS, 2, ACCESS
12138  EFA0     GOTO 0x12140
1213A  F090     NOP
1213C  EFA2     GOTO 0x12144
1213E  F090     NOP
12140  EF5B     GOTO 0x120B6
12142  F090     NOP
14:            		n = 10*n - (int)(*s++ - '0');
120B6  C015     MOVFF n, __pcstackCOMRAM
120B8  F001     NOP
120BA  C016     MOVFF 0x16, t
120BC  F002     NOP
120BE  0E00     MOVLW 0x0
120C0  6E04     MOVWF 0x4, ACCESS
120C2  0E0A     MOVLW 0xA
120C4  6E03     MOVWF a, ACCESS
120C6  ECDC     CALL 0x12BB8, 0
120C8  F095     NOP
120CA  C008     MOVFF s, TBLPTR
120CC  FFF6     NOP
120CE  C009     MOVFF divisor, TBLPTRH
120D0  FFF7     NOP
120D2  0E00     MOVLW 0x0
120D4  6EF8     MOVWF TBLPTRU, ACCESS
120D6  0008     TBLRD*
120D8  50F5     MOVF TABLAT, W, ACCESS
120DA  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
120DC  0E00     MOVLW 0x0
120DE  5A02     SUBWFB t, F, ACCESS
120E0  0E30     MOVLW 0x30
120E2  2401     ADDWF __pcstackCOMRAM, W, ACCESS
120E4  6E15     MOVWF n, ACCESS
120E6  0E00     MOVLW 0x0
120E8  2002     ADDWFC t, W, ACCESS
120EA  6E16     MOVWF 0x16, ACCESS
120EC  EF3B     GOTO 0x12076
120EE  F090     NOP
15:            	return neg ? n : -n;
12144  500E     MOVF neg, W, ACCESS
12146  100F     IORWF b, W, ACCESS
12148  A4D8     BTFSS STATUS, 2, ACCESS
1214A  EFA9     GOTO 0x12152
1214C  F090     NOP
1214E  EFAB     GOTO 0x12156
12150  F090     NOP
12152  EFB9     GOTO 0x12172
12154  F090     NOP
12156  C015     MOVFF n, exp
12158  F00A     NOP
1215A  C016     MOVFF 0x16, arg
1215C  F00B     NOP
1215E  1E0A     COMF exp, F, ACCESS
12160  1E0B     COMF arg, F, ACCESS
12162  4A0A     INFSNZ exp, F, ACCESS
12164  2A0B     INCF arg, F, ACCESS
12166  C00A     MOVFF exp, s
12168  F008     NOP
1216A  C00B     MOVFF arg, divisor
1216C  F009     NOP
1216E  EFBD     GOTO 0x1217A
12170  F090     NOP
12172  C015     MOVFF n, s
12174  F008     NOP
12176  C016     MOVFF 0x16, divisor
12178  F009     NOP
16:            }
1217A  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/aomod.c  -------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
12304  0E00     MOVLW 0x0
12306  6E12     MOVWF sign, ACCESS
15:            	if(dividend < 0) {
12308  BE08     BTFSC s, 7, ACCESS
1230A  EF8B     GOTO 0x12316
1230C  F091     NOP
1230E  EF89     GOTO 0x12312
12310  F091     NOP
12312  EF9D     GOTO 0x1233A
12314  F091     NOP
16:            		dividend = -dividend;
12316  1E08     COMF s, F, ACCESS
12318  1E07     COMF c, F, ACCESS
1231A  1E06     COMF L, F, ACCESS
1231C  1E05     COMF product, F, ACCESS
1231E  1E04     COMF 0x4, F, ACCESS
12320  1E03     COMF a, F, ACCESS
12322  1E02     COMF t, F, ACCESS
12324  6C01     NEGF __pcstackCOMRAM, ACCESS
12326  0E00     MOVLW 0x0
12328  2202     ADDWFC t, F, ACCESS
1232A  2203     ADDWFC a, F, ACCESS
1232C  2204     ADDWFC 0x4, F, ACCESS
1232E  2205     ADDWFC product, F, ACCESS
12330  2206     ADDWFC L, F, ACCESS
12332  2207     ADDWFC c, F, ACCESS
12334  2208     ADDWFC s, F, ACCESS
17:            		sign = 1;
12336  0E01     MOVLW 0x1
12338  6E12     MOVWF sign, ACCESS
18:            	}
19:            	if(divisor < 0)
1233A  BE10     BTFSC c, 7, ACCESS
1233C  EFA4     GOTO 0x12348
1233E  F091     NOP
12340  EFA2     GOTO 0x12344
12342  F091     NOP
12344  EFB4     GOTO 0x12368
12346  F091     NOP
20:            		divisor = -divisor;
12348  1E10     COMF c, F, ACCESS
1234A  1E0F     COMF b, F, ACCESS
1234C  1E0E     COMF neg, F, ACCESS
1234E  1E0D     COMF 0xD, F, ACCESS
12350  1E0C     COMF s, F, ACCESS
12352  1E0B     COMF arg, F, ACCESS
12354  1E0A     COMF exp, F, ACCESS
12356  6C09     NEGF divisor, ACCESS
12358  0E00     MOVLW 0x0
1235A  220A     ADDWFC exp, F, ACCESS
1235C  220B     ADDWFC arg, F, ACCESS
1235E  220C     ADDWFC s, F, ACCESS
12360  220D     ADDWFC 0xD, F, ACCESS
12362  220E     ADDWFC neg, F, ACCESS
12364  220F     ADDWFC b, F, ACCESS
12366  2210     ADDWFC c, F, ACCESS
21:            	if(divisor != 0) {
12368  5009     MOVF divisor, W, ACCESS
1236A  100A     IORWF exp, W, ACCESS
1236C  100B     IORWF arg, W, ACCESS
1236E  100C     IORWF s, W, ACCESS
12370  100D     IORWF 0xD, W, ACCESS
12372  100E     IORWF neg, W, ACCESS
12374  100F     IORWF b, W, ACCESS
12376  1010     IORWF c, W, ACCESS
12378  B4D8     BTFSC STATUS, 2, ACCESS
1237A  EFC1     GOTO 0x12382
1237C  F091     NOP
1237E  EFC3     GOTO 0x12386
12380  F091     NOP
12382  EF0B     GOTO 0x12416
12384  F092     NOP
22:            		counter = 1;
12386  0E01     MOVLW 0x1
12388  6E11     MOVWF i, ACCESS
23:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
1238A  EFD1     GOTO 0x123A2
1238C  F091     NOP
123A2  AE10     BTFSS c, 7, ACCESS
123A4  EFD6     GOTO 0x123AC
123A6  F091     NOP
123A8  EFD8     GOTO 0x123B0
123AA  F091     NOP
123AC  EFC7     GOTO 0x1238E
123AE  F091     NOP
24:            			divisor <<= 1;
1238E  90D8     BCF STATUS, 0, ACCESS
12390  3609     RLCF divisor, F, ACCESS
12392  360A     RLCF exp, F, ACCESS
12394  360B     RLCF arg, F, ACCESS
12396  360C     RLCF s, F, ACCESS
12398  360D     RLCF 0xD, F, ACCESS
1239A  360E     RLCF neg, F, ACCESS
1239C  360F     RLCF b, F, ACCESS
1239E  3610     RLCF c, F, ACCESS
25:            			counter++;
123A0  2A11     INCF i, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
123B0  5009     MOVF divisor, W, ACCESS
123B2  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
123B4  500A     MOVF exp, W, ACCESS
123B6  5802     SUBWFB t, W, ACCESS
123B8  500B     MOVF arg, W, ACCESS
123BA  5803     SUBWFB a, W, ACCESS
123BC  500C     MOVF s, W, ACCESS
123BE  5804     SUBWFB 0x4, W, ACCESS
123C0  500D     MOVF 0xD, W, ACCESS
123C2  5805     SUBWFB product, W, ACCESS
123C4  500E     MOVF neg, W, ACCESS
123C6  5806     SUBWFB L, W, ACCESS
123C8  500F     MOVF b, W, ACCESS
123CA  5807     SUBWFB c, W, ACCESS
123CC  5010     MOVF c, W, ACCESS
123CE  5808     SUBWFB s, W, ACCESS
123D0  A0D8     BTFSS STATUS, 0, ACCESS
123D2  EFED     GOTO 0x123DA
123D4  F091     NOP
123D6  EFEF     GOTO 0x123DE
123D8  F091     NOP
123DA  EFFF     GOTO 0x123FE
123DC  F091     NOP
29:            				dividend -= divisor;
123DE  5009     MOVF divisor, W, ACCESS
123E0  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
123E2  500A     MOVF exp, W, ACCESS
123E4  5A02     SUBWFB t, F, ACCESS
123E6  500B     MOVF arg, W, ACCESS
123E8  5A03     SUBWFB a, F, ACCESS
123EA  500C     MOVF s, W, ACCESS
123EC  5A04     SUBWFB 0x4, F, ACCESS
123EE  500D     MOVF 0xD, W, ACCESS
123F0  5A05     SUBWFB product, F, ACCESS
123F2  500E     MOVF neg, W, ACCESS
123F4  5A06     SUBWFB L, F, ACCESS
123F6  500F     MOVF b, W, ACCESS
123F8  5A07     SUBWFB c, F, ACCESS
123FA  5010     MOVF c, W, ACCESS
123FC  5A08     SUBWFB s, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
123FE  90D8     BCF STATUS, 0, ACCESS
12400  3210     RRCF c, F, ACCESS
12402  320F     RRCF b, F, ACCESS
12404  320E     RRCF neg, F, ACCESS
12406  320D     RRCF 0xD, F, ACCESS
12408  320C     RRCF s, F, ACCESS
1240A  320B     RRCF arg, F, ACCESS
1240C  320A     RRCF exp, F, ACCESS
1240E  3209     RRCF divisor, F, ACCESS
31:            		} while(--counter != 0);
12410  2E11     DECFSZ i, F, ACCESS
12412  EFD8     GOTO 0x123B0
12414  F091     NOP
32:            	}
33:            	if(sign)
12416  5012     MOVF sign, W, ACCESS
12418  B4D8     BTFSC STATUS, 2, ACCESS
1241A  EF11     GOTO 0x12422
1241C  F092     NOP
1241E  EF13     GOTO 0x12426
12420  F092     NOP
12422  EF23     GOTO 0x12446
12424  F092     NOP
34:            		dividend = -dividend;
12426  1E08     COMF s, F, ACCESS
12428  1E07     COMF c, F, ACCESS
1242A  1E06     COMF L, F, ACCESS
1242C  1E05     COMF product, F, ACCESS
1242E  1E04     COMF 0x4, F, ACCESS
12430  1E03     COMF a, F, ACCESS
12432  1E02     COMF t, F, ACCESS
12434  6C01     NEGF __pcstackCOMRAM, ACCESS
12436  0E00     MOVLW 0x0
12438  2202     ADDWFC t, F, ACCESS
1243A  2203     ADDWFC a, F, ACCESS
1243C  2204     ADDWFC 0x4, F, ACCESS
1243E  2205     ADDWFC product, F, ACCESS
12440  2206     ADDWFC L, F, ACCESS
12442  2207     ADDWFC c, F, ACCESS
12444  2208     ADDWFC s, F, ACCESS
35:            	return dividend;
12446  C001     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
12448  F001     NOP
1244A  C002     MOVFF t, t
1244C  F002     NOP
1244E  C003     MOVFF a, a
12450  F003     NOP
12452  C004     MOVFF 0x4, 0x4
12454  F004     NOP
12456  C005     MOVFF product, product
12458  F005     NOP
1245A  C006     MOVFF L, L
1245C  F006     NOP
1245E  C007     MOVFF c, c
12460  F007     NOP
12462  C008     MOVFF s, s
12464  F008     NOP
36:            }
12466  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/aodiv.c  -------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
1217C  0E00     MOVLW 0x0
1217E  6E12     MOVWF sign, ACCESS
16:            	if(divisor < 0) {
12180  BE10     BTFSC c, 7, ACCESS
12182  EFC7     GOTO 0x1218E
12184  F090     NOP
12186  EFC5     GOTO 0x1218A
12188  F090     NOP
1218A  EFD9     GOTO 0x121B2
1218C  F090     NOP
17:            		divisor = -divisor;
1218E  1E10     COMF c, F, ACCESS
12190  1E0F     COMF b, F, ACCESS
12192  1E0E     COMF neg, F, ACCESS
12194  1E0D     COMF 0xD, F, ACCESS
12196  1E0C     COMF s, F, ACCESS
12198  1E0B     COMF arg, F, ACCESS
1219A  1E0A     COMF exp, F, ACCESS
1219C  6C09     NEGF divisor, ACCESS
1219E  0E00     MOVLW 0x0
121A0  220A     ADDWFC exp, F, ACCESS
121A2  220B     ADDWFC arg, F, ACCESS
121A4  220C     ADDWFC s, F, ACCESS
121A6  220D     ADDWFC 0xD, F, ACCESS
121A8  220E     ADDWFC neg, F, ACCESS
121AA  220F     ADDWFC b, F, ACCESS
121AC  2210     ADDWFC c, F, ACCESS
18:            		sign = 1;
121AE  0E01     MOVLW 0x1
121B0  6E12     MOVWF sign, ACCESS
19:            	}
20:            	if(dividend < 0) {
121B2  BE08     BTFSC s, 7, ACCESS
121B4  EFE0     GOTO 0x121C0
121B6  F090     NOP
121B8  EFDE     GOTO 0x121BC
121BA  F090     NOP
121BC  EFF2     GOTO 0x121E4
121BE  F090     NOP
21:            		dividend = -dividend;
121C0  1E08     COMF s, F, ACCESS
121C2  1E07     COMF c, F, ACCESS
121C4  1E06     COMF L, F, ACCESS
121C6  1E05     COMF product, F, ACCESS
121C8  1E04     COMF 0x4, F, ACCESS
121CA  1E03     COMF a, F, ACCESS
121CC  1E02     COMF t, F, ACCESS
121CE  6C01     NEGF __pcstackCOMRAM, ACCESS
121D0  0E00     MOVLW 0x0
121D2  2202     ADDWFC t, F, ACCESS
121D4  2203     ADDWFC a, F, ACCESS
121D6  2204     ADDWFC 0x4, F, ACCESS
121D8  2205     ADDWFC product, F, ACCESS
121DA  2206     ADDWFC L, F, ACCESS
121DC  2207     ADDWFC c, F, ACCESS
121DE  2208     ADDWFC s, F, ACCESS
22:            		sign ^= 1;
121E0  0E01     MOVLW 0x1
121E2  1A12     XORWF sign, F, ACCESS
23:            	}
24:            	quotient = 0;
121E4  EE20     LFSR 2, 0x13
121E6  F013     NOP
121E8  0E07     MOVLW 0x7
121EA  6ADE     CLRF POSTINC2, ACCESS
121EC  06E8     DECF WREG, F, ACCESS
121EE  E2FD     BC 0x21EA
25:            	if(divisor != 0) {
121F0  5009     MOVF divisor, W, ACCESS
121F2  100A     IORWF exp, W, ACCESS
121F4  100B     IORWF arg, W, ACCESS
121F6  100C     IORWF s, W, ACCESS
121F8  100D     IORWF 0xD, W, ACCESS
121FA  100E     IORWF neg, W, ACCESS
121FC  100F     IORWF b, W, ACCESS
121FE  1010     IORWF c, W, ACCESS
12200  B4D8     BTFSC STATUS, 2, ACCESS
12202  EF05     GOTO 0x1220A
12204  F091     NOP
12206  EF07     GOTO 0x1220E
12208  F091     NOP
1220A  EF59     GOTO 0x122B2
1220C  F091     NOP
26:            		counter = 1;
1220E  0E01     MOVLW 0x1
12210  6E11     MOVWF i, ACCESS
27:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
12212  EF15     GOTO 0x1222A
12214  F091     NOP
1222A  AE10     BTFSS c, 7, ACCESS
1222C  EF1A     GOTO 0x12234
1222E  F091     NOP
12230  EF1C     GOTO 0x12238
12232  F091     NOP
12234  EF0B     GOTO 0x12216
12236  F091     NOP
28:            			divisor <<= 1;
12216  90D8     BCF STATUS, 0, ACCESS
12218  3609     RLCF divisor, F, ACCESS
1221A  360A     RLCF exp, F, ACCESS
1221C  360B     RLCF arg, F, ACCESS
1221E  360C     RLCF s, F, ACCESS
12220  360D     RLCF 0xD, F, ACCESS
12222  360E     RLCF neg, F, ACCESS
12224  360F     RLCF b, F, ACCESS
12226  3610     RLCF c, F, ACCESS
29:            			counter++;
12228  2A11     INCF i, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
12238  90D8     BCF STATUS, 0, ACCESS
1223A  3613     RLCF a, F, ACCESS
1223C  3614     RLCF 0x14, F, ACCESS
1223E  3615     RLCF n, F, ACCESS
12240  3616     RLCF 0x16, F, ACCESS
12242  3617     RLCF p, F, ACCESS
12244  3618     RLCF 0x18, F, ACCESS
12246  3619     RLCF 0x19, F, ACCESS
12248  361A     RLCF i, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
1224A  5009     MOVF divisor, W, ACCESS
1224C  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
1224E  500A     MOVF exp, W, ACCESS
12250  5802     SUBWFB t, W, ACCESS
12252  500B     MOVF arg, W, ACCESS
12254  5803     SUBWFB a, W, ACCESS
12256  500C     MOVF s, W, ACCESS
12258  5804     SUBWFB 0x4, W, ACCESS
1225A  500D     MOVF 0xD, W, ACCESS
1225C  5805     SUBWFB product, W, ACCESS
1225E  500E     MOVF neg, W, ACCESS
12260  5806     SUBWFB L, W, ACCESS
12262  500F     MOVF b, W, ACCESS
12264  5807     SUBWFB c, W, ACCESS
12266  5010     MOVF c, W, ACCESS
12268  5808     SUBWFB s, W, ACCESS
1226A  A0D8     BTFSS STATUS, 0, ACCESS
1226C  EF3A     GOTO 0x12274
1226E  F091     NOP
12270  EF3C     GOTO 0x12278
12272  F091     NOP
12274  EF4D     GOTO 0x1229A
12276  F091     NOP
34:            				dividend -= divisor;
12278  5009     MOVF divisor, W, ACCESS
1227A  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
1227C  500A     MOVF exp, W, ACCESS
1227E  5A02     SUBWFB t, F, ACCESS
12280  500B     MOVF arg, W, ACCESS
12282  5A03     SUBWFB a, F, ACCESS
12284  500C     MOVF s, W, ACCESS
12286  5A04     SUBWFB 0x4, F, ACCESS
12288  500D     MOVF 0xD, W, ACCESS
1228A  5A05     SUBWFB product, F, ACCESS
1228C  500E     MOVF neg, W, ACCESS
1228E  5A06     SUBWFB L, F, ACCESS
12290  500F     MOVF b, W, ACCESS
12292  5A07     SUBWFB c, F, ACCESS
12294  5010     MOVF c, W, ACCESS
12296  5A08     SUBWFB s, F, ACCESS
35:            				quotient |= 1;
12298  8013     BSF a, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
1229A  90D8     BCF STATUS, 0, ACCESS
1229C  3210     RRCF c, F, ACCESS
1229E  320F     RRCF b, F, ACCESS
122A0  320E     RRCF neg, F, ACCESS
122A2  320D     RRCF 0xD, F, ACCESS
122A4  320C     RRCF s, F, ACCESS
122A6  320B     RRCF arg, F, ACCESS
122A8  320A     RRCF exp, F, ACCESS
122AA  3209     RRCF divisor, F, ACCESS
38:            		} while(--counter != 0);
122AC  2E11     DECFSZ i, F, ACCESS
122AE  EF1C     GOTO 0x12238
122B0  F091     NOP
39:            	}
40:            	if(sign)
122B2  5012     MOVF sign, W, ACCESS
122B4  B4D8     BTFSC STATUS, 2, ACCESS
122B6  EF5F     GOTO 0x122BE
122B8  F091     NOP
122BA  EF61     GOTO 0x122C2
122BC  F091     NOP
122BE  EF71     GOTO 0x122E2
122C0  F091     NOP
41:            		quotient = -quotient;
122C2  1E1A     COMF i, F, ACCESS
122C4  1E19     COMF 0x19, F, ACCESS
122C6  1E18     COMF 0x18, F, ACCESS
122C8  1E17     COMF p, F, ACCESS
122CA  1E16     COMF 0x16, F, ACCESS
122CC  1E15     COMF n, F, ACCESS
122CE  1E14     COMF 0x14, F, ACCESS
122D0  6C13     NEGF a, ACCESS
122D2  0E00     MOVLW 0x0
122D4  2214     ADDWFC 0x14, F, ACCESS
122D6  2215     ADDWFC n, F, ACCESS
122D8  2216     ADDWFC 0x16, F, ACCESS
122DA  2217     ADDWFC p, F, ACCESS
122DC  2218     ADDWFC 0x18, F, ACCESS
122DE  2219     ADDWFC 0x19, F, ACCESS
122E0  221A     ADDWFC i, F, ACCESS
42:            	return quotient;
122E2  C013     MOVFF a, __pcstackCOMRAM
122E4  F001     NOP
122E6  C014     MOVFF 0x14, t
122E8  F002     NOP
122EA  C015     MOVFF n, a
122EC  F003     NOP
122EE  C016     MOVFF 0x16, 0x4
122F0  F004     NOP
122F2  C017     MOVFF p, product
122F4  F005     NOP
122F6  C018     MOVFF 0x18, L
122F8  F006     NOP
122FA  C019     MOVFF 0x19, c
122FC  F007     NOP
122FE  C01A     MOVFF i, s
12300  F008     NOP
43:            }
12302  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/abs.c  ---------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
129D0  BE14     BTFSC 0x14, 7, ACCESS
129D2  EFF5     GOTO 0x129EA
129D4  F094     NOP
129D6  5014     MOVF 0x14, W, ACCESS
129D8  E106     BNZ 0x29E6
129DA  0413     DECF a, W, ACCESS
129DC  B0D8     BTFSC STATUS, 0, ACCESS
129DE  EFF3     GOTO 0x129E6
129E0  F094     NOP
129E2  EFF5     GOTO 0x129EA
129E4  F094     NOP
129E6  EF03     GOTO 0x12A06
129E8  F095     NOP
129EA  C013     MOVFF a, n
129EC  F015     NOP
129EE  C014     MOVFF 0x14, 0x16
129F0  F016     NOP
129F2  1E15     COMF n, F, ACCESS
129F4  1E16     COMF 0x16, F, ACCESS
129F6  4A15     INFSNZ n, F, ACCESS
129F8  2A16     INCF 0x16, F, ACCESS
129FA  C015     MOVFF n, a
129FC  F013     NOP
129FE  C016     MOVFF 0x16, 0x14
12A00  F014     NOP
12A02  EF07     GOTO 0x12A0E
12A04  F095     NOP
12A06  C013     MOVFF a, a
12A08  F013     NOP
12A0A  C014     MOVFF 0x14, 0x14
12A0C  F014     NOP
4:             }
12A0E  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.31/pic/sources/c99/common/Umul16.c  ------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
12BB8  5001     MOVF __pcstackCOMRAM, W, ACCESS
12BBA  0203     MULWF a, ACCESS
12BBC  CFF3     MOVFF PROD, product
12BBE  F005     NOP
12BC0  CFF4     MOVFF PRODH, L
12BC2  F006     NOP
38:                    product += (unsigned int)(LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
12BC4  5001     MOVF __pcstackCOMRAM, W, ACCESS
12BC6  0204     MULWF 0x4, ACCESS
12BC8  50F3     MOVF PROD, W, ACCESS
12BCA  2606     ADDWF L, F, ACCESS
39:                    product += (unsigned int)(HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
12BCC  5002     MOVF t, W, ACCESS
12BCE  0203     MULWF a, ACCESS
12BD0  50F3     MOVF PROD, W, ACCESS
12BD2  2606     ADDWF L, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
12BD4  C005     MOVFF product, __pcstackCOMRAM
12BD6  F001     NOP
12BD8  C006     MOVFF L, t
12BDA  F002     NOP
53:            }
12BDC  0012     RETURN 0
